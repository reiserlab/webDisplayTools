<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Arena 3D Viewer - PanelDisplayTools</title>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700&family=IBM+Plex+Mono:wght@400;600&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        :root {
            --bg: #0f1419;
            --surface: #1a1f26;
            --border: #2d3640;
            --text: #e6edf3;
            --text-dim: #8b949e;
            --accent: #00e676;
            --hover: #00c853;
        }

        body {
            font-family: 'IBM Plex Mono', monospace;
            background: var(--bg);
            color: var(--text);
            overflow: hidden;
        }

        /* Controls Panel */
        .controls-panel {
            position: fixed;
            top: 1rem;
            left: 1rem;
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 1.25rem;
            width: 280px;
            z-index: 100;
            max-height: calc(100vh - 2rem);
            overflow-y: auto;
        }

        .controls-panel h1 {
            font-family: 'JetBrains Mono', monospace;
            font-size: 1.1rem;
            color: var(--accent);
            margin-bottom: 0.5rem;
        }

        .controls-panel .subtitle {
            font-size: 0.75rem;
            color: var(--text-dim);
            margin-bottom: 1rem;
            padding-bottom: 0.75rem;
            border-bottom: 1px solid var(--border);
        }

        .control-group {
            margin-bottom: 1rem;
        }

        .control-group label {
            display: block;
            font-size: 0.75rem;
            color: var(--text-dim);
            margin-bottom: 0.3rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        /* Generation Tabs */
        .gen-tabs {
            display: flex;
            gap: 0.3rem;
            flex-wrap: wrap;
        }

        .gen-tab {
            padding: 0.4rem 0.7rem;
            background: var(--bg);
            border: 1px solid var(--border);
            border-radius: 4px;
            color: var(--text-dim);
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.75rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .gen-tab:hover {
            border-color: var(--accent);
            color: var(--text);
        }

        .gen-tab.active {
            background: var(--accent);
            border-color: var(--accent);
            color: var(--bg);
            font-weight: 700;
        }

        /* Number Input */
        .number-input {
            display: flex;
            align-items: center;
            gap: 0.4rem;
        }

        .number-input button {
            width: 32px;
            height: 32px;
            background: var(--bg);
            border: 1px solid var(--border);
            border-radius: 4px;
            color: var(--text);
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .number-input button:hover {
            border-color: var(--accent);
            color: var(--accent);
        }

        .number-input input {
            width: 50px;
            height: 32px;
            background: var(--bg);
            border: 1px solid var(--border);
            border-radius: 4px;
            color: var(--text);
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.9rem;
            text-align: center;
        }

        .number-input span {
            font-size: 0.8rem;
            color: var(--text-dim);
            margin-left: 0.3rem;
        }

        /* Metrics */
        .metric {
            display: flex;
            justify-content: space-between;
            padding: 0.4rem 0;
            border-bottom: 1px solid var(--border);
            font-size: 0.8rem;
        }

        .metric:last-child { border-bottom: none; }
        .metric .label { color: var(--text-dim); }
        .metric .value {
            color: var(--text);
            font-family: 'JetBrains Mono', monospace;
        }

        /* Buttons */
        .btn {
            width: 100%;
            padding: 0.6rem;
            background: var(--accent);
            border: none;
            border-radius: 6px;
            color: var(--bg);
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.85rem;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.2s;
            margin-top: 0.5rem;
        }

        .btn:hover {
            background: var(--hover);
            transform: translateY(-1px);
        }

        .btn.secondary {
            background: var(--surface);
            border: 1px solid var(--accent);
            color: var(--accent);
        }

        .btn.secondary:hover {
            background: rgba(0, 230, 118, 0.1);
        }

        /* 3D Canvas */
        #canvas-container {
            width: 100vw;
            height: 100vh;
        }

        /* Help Panel */
        .help-panel {
            position: fixed;
            bottom: 1rem;
            left: 1rem;
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 0.75rem 1rem;
            font-size: 0.7rem;
            color: var(--text-dim);
            z-index: 100;
        }

        .help-panel strong { color: var(--text); }

        /* Navigation */
        .nav-link {
            display: inline-block;
            color: var(--text-dim);
            text-decoration: none;
            margin-bottom: 0.75rem;
            font-size: 0.8rem;
            transition: color 0.2s;
        }

        .nav-link:hover { color: var(--accent); }

        /* Info overlay */
        .info-overlay {
            position: fixed;
            top: 1rem;
            right: 1rem;
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 1rem;
            z-index: 100;
            font-size: 0.8rem;
        }

        .info-overlay h3 {
            font-family: 'JetBrains Mono', monospace;
            color: var(--accent);
            font-size: 0.9rem;
            margin-bottom: 0.5rem;
        }

        .resolution-display {
            font-family: 'JetBrains Mono', monospace;
            font-size: 1.2rem;
            font-weight: 700;
            color: var(--accent);
            text-align: center;
            padding: 0.5rem;
            background: rgba(0, 230, 118, 0.1);
            border-radius: 4px;
            margin-bottom: 0.5rem;
        }

        /* Pattern Radio Buttons */
        .pattern-radio-group {
            display: flex;
            flex-direction: column;
            gap: 0.4rem;
        }

        .pattern-radio {
            display: flex;
            align-items: center;
            padding: 0.5rem 0.75rem;
            background: var(--bg);
            border: 1px solid var(--border);
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .pattern-radio:hover {
            border-color: var(--accent);
        }

        .pattern-radio.active {
            border-color: var(--accent);
            background: rgba(0, 230, 118, 0.1);
        }

        .pattern-radio input[type="radio"] {
            display: none;
        }

        .pattern-radio .radio-label {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.8rem;
            font-weight: 600;
            color: var(--text);
        }

        .pattern-radio.active .radio-label {
            color: var(--accent);
        }

        .pattern-radio .pattern-value {
            margin-left: auto;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.7rem;
            color: var(--text-dim);
        }

        .pattern-radio.active .pattern-value {
            color: var(--accent);
        }

        /* Loading Overlay */
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(15, 20, 25, 0.85);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s;
        }

        .loading-overlay.visible {
            opacity: 1;
            pointer-events: all;
        }

        .loading-spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--accent);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 1rem;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .loading-text {
            font-family: 'JetBrains Mono', monospace;
            font-size: 1rem;
            color: var(--accent);
        }

        /* Disabled button state */
        .btn.disabled, .gen-tab.disabled {
            opacity: 0.5;
            cursor: not-allowed;
            pointer-events: none;
        }

        /* Screenshot buttons */
        .screenshot-group {
            display: flex;
            gap: 0.5rem;
            margin-top: 0.5rem;
        }

        .screenshot-group .btn {
            flex: 1;
            font-size: 0.7rem;
            padding: 0.5rem;
        }

        /* View Controls Panel (lower right) */
        .view-controls-panel {
            position: fixed;
            bottom: 1rem;
            right: 1rem;
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 1rem;
            z-index: 100;
            width: 200px;
        }

        .view-controls-panel h3 {
            font-family: 'JetBrains Mono', monospace;
            color: var(--accent);
            font-size: 0.85rem;
            margin-bottom: 0.75rem;
        }

        .view-controls-panel .btn {
            margin-top: 0.4rem;
            font-size: 0.75rem;
            padding: 0.5rem;
        }

        .view-controls-panel .btn:first-of-type {
            margin-top: 0;
        }

        /* Zoom buttons row */
        .zoom-row {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 0.5rem;
        }

        .zoom-row .btn {
            flex: 1;
            margin-top: 0;
        }

        /* View select dropdown */
        .view-select {
            width: 100%;
            padding: 0.5rem;
            background: var(--bg);
            border: 1px solid var(--border);
            border-radius: 4px;
            color: var(--text);
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.75rem;
            cursor: pointer;
            margin-bottom: 0.5rem;
        }

        .view-select:hover {
            border-color: var(--accent);
        }

        .view-select:focus {
            outline: none;
            border-color: var(--accent);
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>

    <!-- Controls Panel -->
    <div class="controls-panel">
        <a href="#" class="nav-link" id="back-to-2d">← Back</a>
        <h1>Arena 3D Viewer</h1>
        <p class="subtitle">Configure cylindrical arena with LED panels</p>

        <div class="control-group">
            <label>Panel Generation</label>
            <div class="gen-tabs">
                <button class="gen-tab" data-gen="G3">G3</button>
                <button class="gen-tab" data-gen="G4">G4</button>
                <button class="gen-tab" data-gen="G4.1">G4.1</button>
                <button class="gen-tab" data-gen="G5">G5</button>
                <button class="gen-tab active" data-gen="G6">G6</button>
            </div>
        </div>

        <div class="control-group">
            <label>Panel Rows (Height)</label>
            <div class="number-input">
                <button id="rows-dec">−</button>
                <input type="number" id="num-rows" value="3" min="1" max="8">
                <button id="rows-inc">+</button>
            </div>
        </div>

        <div class="control-group">
            <label>Arena Statistics</label>
            <div class="metric">
                <span class="label">Columns</span>
                <span class="value" id="num-cols-display">12</span>
            </div>
            <div class="metric">
                <span class="label">Total Panels</span>
                <span class="value" id="total-panels">36</span>
            </div>
            <div class="metric">
                <span class="label">Inner Radius</span>
                <span class="value" id="inner-radius">3.52 in</span>
            </div>
            <div class="metric">
                <span class="label">Arena Height</span>
                <span class="value" id="arena-height">5.36 in</span>
            </div>
            <div class="metric">
                <span class="label">Total LEDs</span>
                <span class="value" id="total-leds">14,400</span>
            </div>
        </div>

        <div class="control-group" style="border-top: 1px solid var(--border); padding-top: 1rem; margin-top: 0.5rem;">
            <label>Pattern</label>
            <div class="pattern-radio-group" style="margin-top: 0.5rem;">
                <label class="pattern-radio active" id="pattern-allon-label">
                    <input type="radio" name="pattern" value="allOn" checked>
                    <span class="radio-label">All On</span>
                </label>
                <label class="pattern-radio" id="pattern-grating-label">
                    <input type="radio" name="pattern" value="grating">
                    <span class="radio-label">Grating</span>
                    <span class="pattern-value" id="grating-value-display">20 px</span>
                </label>
                <label class="pattern-radio" id="pattern-sine-label">
                    <input type="radio" name="pattern" value="sine">
                    <span class="radio-label">Sine</span>
                    <span class="pattern-value" id="sine-value-display">λ = 120 px</span>
                </label>
            </div>
            <div id="grating-controls" class="pattern-controls" style="display: none; margin-top: 0.5rem;">
                <label style="font-size: 0.7rem; color: var(--text-dim);">Grating Width (pixels on/off)</label>
                <select id="grating-select" style="width: 100%; margin-top: 0.3rem; padding: 0.4rem; background: var(--bg); border: 1px solid var(--border); border-radius: 4px; color: var(--text); font-family: 'JetBrains Mono', monospace; font-size: 0.8rem;">
                </select>
            </div>
            <div id="sine-controls" class="pattern-controls" style="display: none; margin-top: 0.5rem;">
                <label style="font-size: 0.7rem; color: var(--text-dim);">Sine Wavelength (pixels)</label>
                <select id="sine-select" style="width: 100%; margin-top: 0.3rem; padding: 0.4rem; background: var(--bg); border: 1px solid var(--border); border-radius: 4px; color: var(--text); font-family: 'JetBrains Mono', monospace; font-size: 0.8rem;">
                </select>
            </div>
        </div>

        <button class="btn disabled" id="load-pattern" style="margin-top: 1rem;" title="Coming Soon">Load Pattern (Coming Soon)</button>
        <button class="btn secondary" id="toggle-rotation">Rotate Pattern</button>
    </div>

    <!-- Loading Overlay -->
    <div class="loading-overlay" id="loading-overlay">
        <div class="loading-spinner"></div>
        <div class="loading-text" id="loading-text">Updating...</div>
    </div>

    <!-- Info Overlay -->
    <div class="info-overlay">
        <h3>Avg Angular Resolution</h3>
        <div class="metric">
            <span class="label">Azimuth</span>
            <span class="value" id="azimuth-res">1.50°/px</span>
        </div>
        <div class="metric">
            <span class="label">Vertical</span>
            <span class="value" id="vertical-res">2.50°/px</span>
        </div>
        <div class="metric" style="margin-top: 0.5rem; padding-top: 0.5rem; border-top: 1px solid var(--border);">
            <span class="label">Azimuth px</span>
            <span class="value" id="azimuth-pixels">240</span>
        </div>
        <div class="metric">
            <span class="label">Vertical px</span>
            <span class="value" id="vertical-pixels">60</span>
        </div>
    </div>

    <!-- View Controls Panel (lower right) -->
    <div class="view-controls-panel">
        <h3>View Controls</h3>
        <div class="zoom-row">
            <button class="btn secondary" id="zoom-closer">Closer</button>
            <button class="btn secondary" id="zoom-farther">Farther</button>
        </div>
        <select class="view-select" id="view-select">
            <option value="top-down">Top Down</option>
            <option value="side">Side View</option>
            <option value="fly">Fly View (Center)</option>
            <option value="north">From North (+Z)</option>
            <option value="south">From South (-Z)</option>
            <option value="east">From East (+X)</option>
            <option value="west">From West (-X)</option>
        </select>

        <div style="border-top: 1px solid var(--border); padding-top: 0.75rem; margin-top: 0.75rem;">
            <label style="font-size: 0.7rem; color: var(--text-dim); text-transform: uppercase; letter-spacing: 0.5px;">Screenshot</label>
            <div class="screenshot-group" style="margin-top: 0.4rem;">
                <button class="btn secondary" id="screenshot-arena">Arena</button>
                <button class="btn secondary" id="screenshot-full">+ Stats</button>
            </div>
        </div>
    </div>

    <!-- Help Panel -->
    <div class="help-panel">
        <strong>Controls:</strong> Drag to rotate | Scroll to zoom | Right-drag to pan
    </div>

    <script>
        // Panel specifications (same as arena_editor.html)
        const PANEL_SPECS = {
            'G3': {
                panel_width_mm: 32,
                panel_height_mm: 32,
                panel_depth_mm: 18,
                pixels_horizontal: 8,
                pixels_vertical: 8
            },
            'G4': {
                panel_width_mm: 40.45,
                panel_height_mm: 40.45,
                panel_depth_mm: 18,
                pixels_horizontal: 16,
                pixels_vertical: 16
            },
            'G4.1': {
                panel_width_mm: 40,
                panel_height_mm: 40,
                panel_depth_mm: 6.35,
                pixels_horizontal: 16,
                pixels_vertical: 16
            },
            'G5': {
                panel_width_mm: 40,
                panel_height_mm: 40,
                panel_depth_mm: 6.35,
                pixels_horizontal: 20,
                pixels_vertical: 20
            },
            'G6': {
                panel_width_mm: 45.4,
                panel_height_mm: 45.4,
                panel_depth_mm: 3.45,
                pixels_horizontal: 20,
                pixels_vertical: 20
            }
        };

        // State
        let state = {
            panelType: 'G6',
            numCols: 12,  // panels around (from 2D editor, not editable here)
            numRows: 3,   // panels vertically (default 3)
            activePanels: null,  // array of active column indices, null = all active
            pattern: 'allOn',    // 'allOn', 'grating', 'sine'
            gratingPixels: 20,   // pixels on/off for grating (integer divisor of total)
            sineWavelength: 120, // wavelength in pixels for sine (integer divisor of total)
            phaseOffset: 0       // current phase offset in pixels for auto-rotate
        };

        // 16 grayscale levels (matching panel pattern editor)
        const GRAYSCALE_LEVELS = 16;

        // Loading indicator functions
        function showLoading(message = 'Updating...') {
            document.getElementById('loading-text').textContent = message;
            document.getElementById('loading-overlay').classList.add('visible');
        }

        function hideLoading() {
            document.getElementById('loading-overlay').classList.remove('visible');
        }

        // Wrap buildArena with loading indicator
        function buildArenaWithLoading() {
            showLoading('Building arena...');
            // Use setTimeout to allow the loading overlay to render before heavy computation
            setTimeout(() => {
                buildArena();
                hideLoading();
            }, 50);
        }

        // Parse URL parameters (from 2D editor or direct access)
        // Defaults: G6, 10 columns, 3 rows, all panels active
        function parseUrlParams() {
            const params = new URLSearchParams(window.location.search);
            if (params.has('gen')) state.panelType = params.get('gen');
            if (params.has('cols')) state.numCols = parseInt(params.get('cols'));
            if (params.has('rows')) state.numRows = parseInt(params.get('rows'));
            if (params.has('active')) {
                // active is comma-separated list of column indices (0-based)
                const activeStr = params.get('active');
                if (activeStr) {
                    state.activePanels = activeStr.split(',').map(n => parseInt(n));
                }
            }
            // If no cols parameter (direct access from index), default to 10
            if (!params.has('cols')) {
                state.numCols = 10;
            }
        }

        // Three.js objects
        let scene, camera, renderer, controls;
        let arenaGroup;
        let autoRotate = false;

        // LED mesh references for efficient animation (update colors without rebuilding)
        let ledMeshes = []; // Array of {mesh, colIndex, px, py} for updating brightness

        // Initialize
        function init() {
            const container = document.getElementById('canvas-container');

            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0f1419);

            // Camera - default to top-down view
            camera = new THREE.PerspectiveCamera(
                60,
                window.innerWidth / window.innerHeight,
                0.1,
                1000
            );
            // Will be positioned after arena is built to fit the view

            // Renderer (preserveDrawingBuffer needed for screenshots)
            renderer = new THREE.WebGLRenderer({ antialias: true, preserveDrawingBuffer: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            container.appendChild(renderer.domElement);

            // Controls
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.minDistance = 0.1; // Allow getting close to center for fly view
            controls.maxDistance = 50;

            // Lighting
            const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.3);
            directionalLight.position.set(5, 10, 5);
            scene.add(directionalLight);

            // Grid helper (floor reference)
            const gridHelper = new THREE.GridHelper(20, 20, 0x2d3640, 0x1a1f26);
            gridHelper.position.y = -5;
            scene.add(gridHelper);

            // Arena group
            arenaGroup = new THREE.Group();
            scene.add(arenaGroup);

            // Parse URL params and update UI
            parseUrlParams();
            populatePatternSelects(); // Populate dropdowns with valid divisors
            updateUIFromState();

            // Build initial arena
            buildArena();

            // Set initial camera to top-down view, zoomed to fit
            setTopDownView();

            // Event listeners
            setupEventListeners();

            // Start animation
            animate();
        }

        function updateUIFromState() {
            // Update generation tabs
            document.querySelectorAll('.gen-tab').forEach(t => t.classList.remove('active'));
            const activeTab = document.querySelector(`.gen-tab[data-gen="${state.panelType}"]`);
            if (activeTab) activeTab.classList.add('active');

            // Update number inputs (rows only, cols is read-only from 2D editor)
            document.getElementById('num-rows').value = state.numRows;

            // Update pattern radio selection
            updatePatternUI();
        }

        // Get integer divisors of a number
        function getIntegerDivisors(n) {
            const divisors = [];
            for (let i = 1; i <= n; i++) {
                if (n % i === 0) {
                    divisors.push(i);
                }
            }
            return divisors;
        }

        // Get total azimuth pixels
        function getTotalAzimuthPixels() {
            const specs = PANEL_SPECS[state.panelType];
            return state.numCols * specs.pixels_horizontal;
        }

        // Populate grating and sine select dropdowns with valid divisors
        function populatePatternSelects() {
            const totalPixels = getTotalAzimuthPixels();
            const divisors = getIntegerDivisors(totalPixels);

            // Populate grating select (grating width = pixels on = pixels off)
            // Valid values: divisors that make sense for gratings (not too large)
            const gratingSelect = document.getElementById('grating-select');
            gratingSelect.innerHTML = '';
            // For grating, the period is 2x the width, so we want divisors where period divides total
            // Period = 2 * gratingWidth, so gratingWidth can be any divisor/2 where divisor is even
            // Or simpler: any value where totalPixels % (2*value) === 0
            const validGratings = divisors.filter(d => d <= totalPixels / 2 && totalPixels % (2 * d) === 0);
            validGratings.forEach(d => {
                const option = document.createElement('option');
                option.value = d;
                const numBars = totalPixels / (2 * d);
                option.textContent = `${d} px (${numBars} cycles)`;
                if (d === state.gratingPixels) option.selected = true;
                gratingSelect.appendChild(option);
            });

            // If current value not in list, select closest valid one
            if (!validGratings.includes(state.gratingPixels)) {
                state.gratingPixels = validGratings.length > 0 ? validGratings[Math.floor(validGratings.length / 2)] : 1;
                gratingSelect.value = state.gratingPixels;
            }

            // Populate sine select (wavelength in pixels)
            const sineSelect = document.getElementById('sine-select');
            sineSelect.innerHTML = '';
            // For sine, wavelength should divide total pixels evenly
            // Use divisors that are at least 2 pixels (need 2+ pixels per wavelength for a sine)
            const validSines = divisors.filter(d => d >= 4); // need at least 4 pixels for visible sine
            validSines.forEach(d => {
                const option = document.createElement('option');
                option.value = d;
                const numCycles = totalPixels / d;
                option.textContent = `λ = ${d} px (${numCycles} cycles)`;
                if (d === state.sineWavelength) option.selected = true;
                sineSelect.appendChild(option);
            });

            // If current value not in list, select a sensible default
            if (!validSines.includes(state.sineWavelength)) {
                // Pick something around 1/2 to 1/4 of total pixels
                const target = Math.floor(totalPixels / 4);
                state.sineWavelength = validSines.reduce((prev, curr) =>
                    Math.abs(curr - target) < Math.abs(prev - target) ? curr : prev, validSines[0]);
                sineSelect.value = state.sineWavelength;
            }

            // Update display values
            updatePatternDisplayValues();
        }

        function updatePatternDisplayValues() {
            document.getElementById('grating-value-display').textContent = `${state.gratingPixels} px`;
            document.getElementById('sine-value-display').textContent = `λ = ${state.sineWavelength} px`;
        }

        function updatePatternUI() {
            // Update radio button active states
            document.querySelectorAll('.pattern-radio').forEach(r => r.classList.remove('active'));

            if (state.pattern === 'allOn') {
                document.getElementById('pattern-allon-label').classList.add('active');
                document.getElementById('grating-controls').style.display = 'none';
                document.getElementById('sine-controls').style.display = 'none';
            } else if (state.pattern === 'grating') {
                document.getElementById('pattern-grating-label').classList.add('active');
                document.getElementById('grating-controls').style.display = 'block';
                document.getElementById('sine-controls').style.display = 'none';
            } else if (state.pattern === 'sine') {
                document.getElementById('pattern-sine-label').classList.add('active');
                document.getElementById('grating-controls').style.display = 'none';
                document.getElementById('sine-controls').style.display = 'block';
            }

            updatePatternDisplayValues();
        }

        function setTopDownView() {
            // Calculate arena radius for zoom
            const specs = PANEL_SPECS[state.panelType];
            const panelWidth = specs.panel_width_mm / 25.4;
            const alpha = (2 * Math.PI) / state.numCols;
            const cRadius = panelWidth / (Math.tan(alpha / 2)) / 2;

            // Position camera directly above, looking down
            const viewHeight = cRadius * 2.5; // enough to see the whole arena
            camera.position.set(0, viewHeight, 0.01); // tiny Z offset to avoid gimbal lock
            controls.target.set(0, 0, 0);
            controls.update();
        }

        // Apply a standard view preset
        function applyStandardView(viewType) {
            const specs = PANEL_SPECS[state.panelType];
            const panelWidth = specs.panel_width_mm / 25.4;
            const alpha = (2 * Math.PI) / state.numCols;
            const cRadius = panelWidth / (Math.tan(alpha / 2)) / 2;
            const panelHeight = specs.panel_height_mm / 25.4;
            const arenaHeight = panelHeight * state.numRows;

            // Distance for outside views - far enough to see entire arena
            const viewDistance = cRadius * 3;

            switch (viewType) {
                case 'top-down':
                    camera.position.set(0, viewDistance, 0.01);
                    controls.target.set(0, 0, 0);
                    break;
                case 'side':
                    camera.position.set(viewDistance, arenaHeight / 2, 0);
                    controls.target.set(0, 0, 0);
                    break;
                case 'fly':
                    // Camera at center, looking outward
                    camera.position.set(0, 0, 0);
                    controls.target.set(0, 0, cRadius);
                    break;
                case 'north':
                    // Looking from +Z toward center
                    camera.position.set(0, arenaHeight / 2, viewDistance);
                    controls.target.set(0, 0, 0);
                    break;
                case 'south':
                    // Looking from -Z toward center
                    camera.position.set(0, arenaHeight / 2, -viewDistance);
                    controls.target.set(0, 0, 0);
                    break;
                case 'east':
                    // Looking from +X toward center
                    camera.position.set(viewDistance, arenaHeight / 2, 0);
                    controls.target.set(0, 0, 0);
                    break;
                case 'west':
                    // Looking from -X toward center
                    camera.position.set(-viewDistance, arenaHeight / 2, 0);
                    controls.target.set(0, 0, 0);
                    break;
            }
            controls.update();
        }

        function setupEventListeners() {
            // Back navigation - detect if we came from 2D editor or index
            document.getElementById('back-to-2d').addEventListener('click', (e) => {
                e.preventDefault();
                const params = new URLSearchParams(window.location.search);
                // If we have URL params, we came from 2D editor
                if (params.has('gen') || params.has('cols')) {
                    showLoading('Loading 2D Editor...');
                    setTimeout(() => {
                        window.location.href = 'arena_editor.html';
                    }, 100);
                } else {
                    // Direct access from index
                    showLoading('Loading...');
                    setTimeout(() => {
                        window.location.href = 'index.html';
                    }, 100);
                }
            });

            // Generation tabs (change panel type, but numCols comes from 2D editor)
            document.querySelectorAll('.gen-tab').forEach(tab => {
                tab.addEventListener('click', () => {
                    document.querySelectorAll('.gen-tab').forEach(t => t.classList.remove('active'));
                    tab.classList.add('active');
                    state.panelType = tab.dataset.gen;
                    state.phaseOffset = 0;
                    populatePatternSelects(); // Repopulate with new total pixels
                    buildArenaWithLoading();
                });
            });

            // Row controls (columns are fixed from 2D editor)
            const numRowsInput = document.getElementById('num-rows');
            document.getElementById('rows-dec').addEventListener('click', () => {
                if (state.numRows > 1) {
                    state.numRows--;
                    numRowsInput.value = state.numRows;
                    buildArenaWithLoading();
                }
            });
            document.getElementById('rows-inc').addEventListener('click', () => {
                if (state.numRows < 8) {
                    state.numRows++;
                    numRowsInput.value = state.numRows;
                    buildArenaWithLoading();
                }
            });
            numRowsInput.addEventListener('change', () => {
                const val = parseInt(numRowsInput.value);
                if (val >= 1 && val <= 8) {
                    state.numRows = val;
                    buildArenaWithLoading();
                } else {
                    numRowsInput.value = state.numRows;
                }
            });

            // Pattern radio controls
            document.querySelectorAll('.pattern-radio input[type="radio"]').forEach(radio => {
                radio.addEventListener('change', () => {
                    state.pattern = radio.value;
                    state.phaseOffset = 0; // Reset phase when changing pattern
                    updatePatternUI();
                    buildArenaWithLoading();
                });
            });

            // Also allow clicking on the label to select
            document.querySelectorAll('.pattern-radio').forEach(label => {
                label.addEventListener('click', () => {
                    const radio = label.querySelector('input[type="radio"]');
                    if (radio && !radio.checked) {
                        radio.checked = true;
                        state.pattern = radio.value;
                        state.phaseOffset = 0;
                        updatePatternUI();
                        buildArenaWithLoading();
                    }
                });
            });

            // Grating select dropdown
            document.getElementById('grating-select').addEventListener('change', (e) => {
                state.gratingPixels = parseInt(e.target.value);
                state.phaseOffset = 0;
                updatePatternDisplayValues();
                buildArenaWithLoading();
            });

            // Sine select dropdown
            document.getElementById('sine-select').addEventListener('change', (e) => {
                state.sineWavelength = parseInt(e.target.value);
                state.phaseOffset = 0;
                updatePatternDisplayValues();
                buildArenaWithLoading();
            });

            // Auto-rotate toggle (phase shift pattern, not spin world)
            // Disable pan/zoom during rotation for better performance
            document.getElementById('toggle-rotation').addEventListener('click', () => {
                autoRotate = !autoRotate;
                controls.enabled = !autoRotate; // Disable controls during rotation
                document.getElementById('toggle-rotation').textContent = autoRotate ? 'Stop Pattern Rotation' : 'Rotate Pattern';
            });

            // View controls - zoom buttons
            document.getElementById('zoom-closer').addEventListener('click', () => {
                // Move camera closer to target by 20%
                const direction = new THREE.Vector3();
                direction.subVectors(camera.position, controls.target);
                direction.multiplyScalar(0.8); // 80% of current distance
                camera.position.copy(controls.target).add(direction);
                controls.update();
            });

            document.getElementById('zoom-farther').addEventListener('click', () => {
                // Move camera farther from target by 25%
                const direction = new THREE.Vector3();
                direction.subVectors(camera.position, controls.target);
                direction.multiplyScalar(1.25); // 125% of current distance
                camera.position.copy(controls.target).add(direction);
                controls.update();
            });

            // View controls - view selector (auto-apply on change)
            document.getElementById('view-select').addEventListener('change', () => {
                const viewType = document.getElementById('view-select').value;
                applyStandardView(viewType);
            });

            // Window resize
            window.addEventListener('resize', onWindowResize);

            // Screenshot buttons
            document.getElementById('screenshot-arena').addEventListener('click', () => {
                takeScreenshot(false);
            });
            document.getElementById('screenshot-full').addEventListener('click', () => {
                takeScreenshot(true);
            });
        }

        // Generate descriptive filename with timestamp
        function generateFilename(includeUI) {
            const now = new Date();
            const timestamp = now.toISOString().replace(/[:.]/g, '-').slice(0, 19);
            const pattern = state.pattern === 'allOn' ? 'all' :
                           state.pattern === 'grating' ? `grat${state.gratingPixels}` :
                           `sine${state.sineWavelength}`;
            const suffix = includeUI ? '_stats' : '';
            return `arena_${state.panelType}_${state.numCols}c${state.numRows}r_${pattern}${suffix}_${timestamp}.png`;
        }

        // Take screenshot of the arena view
        function takeScreenshot(includeUI) {
            // Render one frame to ensure latest state
            renderer.render(scene, camera);

            const filename = generateFilename(includeUI);

            if (includeUI) {
                // Use canvas composite approach
                const canvasWidth = renderer.domElement.width;
                const canvasHeight = renderer.domElement.height;

                const finalCanvas = document.createElement('canvas');
                finalCanvas.width = canvasWidth;
                finalCanvas.height = canvasHeight;
                const ctx = finalCanvas.getContext('2d');

                // Draw the 3D canvas
                ctx.drawImage(renderer.domElement, 0, 0);

                // Draw UI overlays on top
                drawUIToCanvas(ctx, canvasWidth, canvasHeight);

                // Download the composite image
                downloadCanvas(finalCanvas, filename);
            } else {
                // Just the arena - direct canvas download
                downloadCanvas(renderer.domElement, filename);
            }
        }

        // Draw UI elements to canvas (simplified version)
        function drawUIToCanvas(ctx, canvasWidth, canvasHeight) {
            const padding = 16;
            const panelWidth = 260;
            const lineHeight = 22;

            // Left panel - Configuration info
            const leftPanelHeight = 220;
            ctx.fillStyle = 'rgba(26, 31, 38, 0.95)';
            ctx.fillRect(padding, padding, panelWidth, leftPanelHeight);
            ctx.strokeStyle = '#2d3640';
            ctx.lineWidth = 1;
            ctx.strokeRect(padding, padding, panelWidth, leftPanelHeight);

            // Title
            ctx.font = 'bold 16px JetBrains Mono, monospace';
            ctx.fillStyle = '#00e676';
            ctx.fillText('Arena 3D Viewer', padding + 16, padding + 30);

            // Stats
            ctx.font = '13px IBM Plex Mono, monospace';
            const stats = [
                { label: 'Panel Type:', value: state.panelType, color: '#e6edf3' },
                { label: 'Columns:', value: state.numCols, color: '#e6edf3' },
                { label: 'Rows:', value: state.numRows, color: '#e6edf3' },
                { label: 'Pattern:', value: state.pattern, color: '#e6edf3' },
                { label: 'Total LEDs:', value: document.getElementById('total-leds').textContent, color: '#00e676' },
                { label: 'Azimuth:', value: document.getElementById('azimuth-res').textContent, color: '#e6edf3' },
                { label: 'Vertical:', value: document.getElementById('vertical-res').textContent, color: '#e6edf3' }
            ];

            let y = padding + 60;
            stats.forEach((stat) => {
                ctx.fillStyle = '#8b949e';
                ctx.fillText(stat.label, padding + 16, y);
                ctx.fillStyle = stat.color;
                ctx.fillText(stat.value, padding + 120, y);
                y += lineHeight;
            });

            // Right panel - Angular Resolution (top right)
            const rightPanelWidth = 200;
            const rightPanelHeight = 130;
            const rightX = canvasWidth - rightPanelWidth - padding;

            ctx.fillStyle = 'rgba(26, 31, 38, 0.95)';
            ctx.fillRect(rightX, padding, rightPanelWidth, rightPanelHeight);
            ctx.strokeRect(rightX, padding, rightPanelWidth, rightPanelHeight);

            ctx.font = 'bold 14px JetBrains Mono, monospace';
            ctx.fillStyle = '#00e676';
            ctx.fillText('Angular Resolution', rightX + 16, padding + 28);

            ctx.font = '13px IBM Plex Mono, monospace';
            ctx.fillStyle = '#8b949e';
            ctx.fillText('Azimuth:', rightX + 16, padding + 55);
            ctx.fillStyle = '#e6edf3';
            ctx.fillText(document.getElementById('azimuth-res').textContent, rightX + 100, padding + 55);

            ctx.fillStyle = '#8b949e';
            ctx.fillText('Vertical:', rightX + 16, padding + 77);
            ctx.fillStyle = '#e6edf3';
            ctx.fillText(document.getElementById('vertical-res').textContent, rightX + 100, padding + 77);

            ctx.fillStyle = '#8b949e';
            ctx.fillText('Pixels:', rightX + 16, padding + 105);
            ctx.fillStyle = '#00e676';
            ctx.fillText(`${document.getElementById('azimuth-pixels').textContent} × ${document.getElementById('vertical-pixels').textContent}`, rightX + 100, padding + 105);
        }

        // Download canvas as PNG
        function downloadCanvas(canvas, filename) {
            const link = document.createElement('a');
            link.download = filename;
            link.href = canvas.toDataURL('image/png');
            link.click();
        }

        function buildArena() {
            // Clear existing arena
            while (arenaGroup.children.length > 0) {
                const child = arenaGroup.children[0];
                if (child.geometry) child.geometry.dispose();
                if (child.material) {
                    if (Array.isArray(child.material)) {
                        child.material.forEach(m => m.dispose());
                    } else {
                        child.material.dispose();
                    }
                }
                arenaGroup.remove(child);
            }

            // Clear LED mesh references
            ledMeshes = [];

            const specs = PANEL_SPECS[state.panelType];
            const numCols = state.numCols;
            const numRows = state.numRows;

            // Convert mm to inches (working units)
            const panelWidth = specs.panel_width_mm / 25.4;  // width of one panel
            const panelHeight = specs.panel_height_mm / 25.4; // height of one panel (square)
            const panelDepth = specs.panel_depth_mm / 25.4;

            // Calculate radius based on panel width
            const alpha = (2 * Math.PI) / numCols;
            const cRadius = panelWidth / (Math.tan(alpha / 2)) / 2;

            // Total column height = panel height × number of rows
            const columnHeight = panelHeight * numRows;

            // Create one column (rectangle) per active position around the arena
            // If activePanels is null, all columns are active
            const activeCount = state.activePanels ? state.activePanels.length : numCols;

            for (let col = 0; col < numCols; col++) {
                // Skip inactive columns
                if (state.activePanels && !state.activePanels.includes(col)) {
                    continue;
                }

                const angle = col * alpha;

                // Column position at radius
                const x = cRadius * Math.cos(angle);
                const z = cRadius * Math.sin(angle);

                // Create column with all LEDs (rectangle: panelWidth × columnHeight)
                // Pass column index for pattern calculation
                const columnGroup = createColumnWithLEDs(specs, panelWidth, columnHeight, panelDepth, angle, numRows, col, numCols);
                columnGroup.position.set(x, 0, z);

                arenaGroup.add(columnGroup);
            }

            // Update metrics
            updateMetrics(specs, numCols, numRows, cRadius, columnHeight);
        }

        // Calculate LED brightness based on pattern
        // Returns value from 0 to 1, quantized to 16 levels (0, 1/15, 2/15, ..., 15/15)
        function getLEDBrightness(px, py, colIndex, numCols, totalPixelsH) {
            // Global pixel X position across the entire arena, with phase offset for rotation
            const totalAzimuthPixels = numCols * totalPixelsH;
            // Apply phase offset (wrapping around)
            const globalPixelX = ((colIndex * totalPixelsH + px) + state.phaseOffset + totalAzimuthPixels) % totalAzimuthPixels;

            if (state.pattern === 'allOn') {
                return 1.0; // Full brightness
            } else if (state.pattern === 'grating') {
                // Square wave grating: gratingPixels pixels on, gratingPixels pixels off
                const period = state.gratingPixels * 2;
                const phase = globalPixelX % period;
                return phase < state.gratingPixels ? 1.0 : 0.0;
            } else if (state.pattern === 'sine') {
                // Sine wave: wavelength in pixels
                const wavelengthPixels = state.sineWavelength;
                const phase = (globalPixelX / wavelengthPixels) * 2 * Math.PI;
                // Map sine [-1, 1] to [0, 1]
                const normalized = (Math.sin(phase) + 1) / 2;
                // Quantize to 16 levels: 0, 1, 2, ..., 15 -> 0/15, 1/15, ..., 15/15
                // Use round instead of floor to better distribute across all levels
                const level = Math.round(normalized * (GRAYSCALE_LEVELS - 1));
                return level / (GRAYSCALE_LEVELS - 1);
            }
            return 1.0;
        }

        // Convert brightness (0-1) to green LED color
        function brightnessToColor(brightness) {
            // Use a slight minimum brightness so "off" LEDs still show faintly
            // This helps visualize the sine wave better
            const green = Math.floor(0xe6 * brightness);
            return (green << 8); // Green channel only
        }

        function createColumnWithLEDs(specs, width, height, depth, angle, numRows, colIndex, numCols) {
            const group = new THREE.Group();

            // Rotate entire group so the column face points toward center
            // angle=0 means column is at +X axis, needs to face -X (toward center)
            group.rotation.y = -angle - Math.PI / 2;

            // Column background (black rectangle) - thin box
            // width = panel width, height = total column height (panels stacked)
            const columnGeom = new THREE.BoxGeometry(width, height, depth * 0.1);
            const columnMat = new THREE.MeshLambertMaterial({ color: 0x111111 });
            const column = new THREE.Mesh(columnGeom, columnMat);
            group.add(column);

            // Border material - white, thicker lines
            const borderMat = new THREE.LineBasicMaterial({ color: 0xffffff, linewidth: 2 });
            const halfW = width / 2;
            const halfH = height / 2;
            const panelThickness = depth * 0.05;

            // Create borders on BOTH sides (front +Z and back -Z)
            const borderOffsets = [panelThickness, -panelThickness];

            for (const borderZ of borderOffsets) {
                // Outer rectangle border
                const borderGeom = new THREE.BufferGeometry();
                const borderVertices = new Float32Array([
                    -halfW, -halfH, borderZ,
                     halfW, -halfH, borderZ,
                     halfW, -halfH, borderZ,
                     halfW,  halfH, borderZ,
                     halfW,  halfH, borderZ,
                    -halfW,  halfH, borderZ,
                    -halfW,  halfH, borderZ,
                    -halfW, -halfH, borderZ
                ]);
                borderGeom.setAttribute('position', new THREE.BufferAttribute(borderVertices, 3));
                const border = new THREE.LineSegments(borderGeom, borderMat);
                group.add(border);

                // Horizontal lines between panel rows (if multiple rows)
                if (numRows > 1) {
                    const panelH = height / numRows;
                    for (let r = 1; r < numRows; r++) {
                        const lineY = -halfH + r * panelH;
                        const lineGeom = new THREE.BufferGeometry();
                        const lineVerts = new Float32Array([
                            -halfW, lineY, borderZ,
                             halfW, lineY, borderZ
                        ]);
                        lineGeom.setAttribute('position', new THREE.BufferAttribute(lineVerts, 3));
                        const line = new THREE.Line(lineGeom, borderMat);
                        group.add(line);
                    }
                }
            }

            // LED dots on the inner face (+Z side, facing center)
            // LEDs should be evenly spaced with half-spacing inset from edges
            // This creates a regular grid that would tile continuously
            const totalPixelsV = specs.pixels_vertical * numRows;
            const totalPixelsH = specs.pixels_horizontal;

            // Spacing is width/numPixels, first LED is at half-spacing from edge
            const ledSpacingX = width / totalPixelsH;
            const ledSpacingY = height / totalPixelsV;
            const ledSize = Math.min(ledSpacingX, ledSpacingY) * 0.35; // LED size relative to spacing

            // Check if this panel type uses rotated rectangle LEDs (G4.1, G5, G6)
            const useRotatedRectLEDs = ['G4.1', 'G5', 'G6'].includes(state.panelType);

            // 0604 LED package: 0.6mm x 0.4mm = 1.5:1 aspect ratio
            // The LED is a rectangle rotated 45 degrees on the panel
            const ledAspectRatio = 1.5; // length/width ratio for 0604 LEDs

            for (let py = 0; py < totalPixelsV; py++) {
                for (let px = 0; px < totalPixelsH; px++) {
                    // Calculate brightness based on pattern
                    const brightness = getLEDBrightness(px, py, colIndex, numCols, totalPixelsH);

                    // Position: start at -halfW + halfSpacing, then increment by spacing
                    const localX = -halfW + ledSpacingX / 2 + px * ledSpacingX;
                    const localY = -halfH + ledSpacingY / 2 + py * ledSpacingY;
                    const localZ = panelThickness + 0.001; // just in front of border

                    if (useRotatedRectLEDs) {
                        // Create rectangle rotated 45 degrees for G4.1, G5, G6
                        // 0604 package: 0.6mm x 0.4mm = 1.5:1 aspect ratio
                        const baseSize = ledSize * 0.5;
                        const rectW = baseSize;                      // half-width of rectangle
                        const rectH = baseSize * ledAspectRatio;     // half-height of rectangle (longer)

                        // Create rectangle shape (before rotation)
                        // Rectangle vertices at corners: (-w,-h), (w,-h), (w,h), (-w,h)
                        // Then rotate 45 degrees: x' = x*cos - y*sin, y' = x*sin + y*cos
                        const cos45 = Math.SQRT1_2; // cos(45°) = sin(45°) = √2/2
                        const sin45 = Math.SQRT1_2;

                        // Transform rectangle corners by 45-degree rotation
                        // Corner 1: (-w, -h) -> rotated
                        const c1x = (-rectW) * cos45 - (-rectH) * sin45;
                        const c1y = (-rectW) * sin45 + (-rectH) * cos45;
                        // Corner 2: (w, -h) -> rotated
                        const c2x = (rectW) * cos45 - (-rectH) * sin45;
                        const c2y = (rectW) * sin45 + (-rectH) * cos45;
                        // Corner 3: (w, h) -> rotated
                        const c3x = (rectW) * cos45 - (rectH) * sin45;
                        const c3y = (rectW) * sin45 + (rectH) * cos45;
                        // Corner 4: (-w, h) -> rotated
                        const c4x = (-rectW) * cos45 - (rectH) * sin45;
                        const c4y = (-rectW) * sin45 + (rectH) * cos45;

                        // Create filled rectangle shape
                        const rectShape = new THREE.Shape();
                        rectShape.moveTo(c1x, c1y);
                        rectShape.lineTo(c2x, c2y);
                        rectShape.lineTo(c3x, c3y);
                        rectShape.lineTo(c4x, c4y);
                        rectShape.lineTo(c1x, c1y);

                        const rectGeom = new THREE.ShapeGeometry(rectShape);
                        const ledColor = brightnessToColor(brightness);
                        const rectMat = new THREE.MeshBasicMaterial({ color: ledColor });
                        const rect = new THREE.Mesh(rectGeom, rectMat);
                        rect.position.set(localX, localY, localZ);
                        group.add(rect);

                        // Store reference for efficient animation updates
                        ledMeshes.push({
                            mesh: rect,
                            colIndex: colIndex,
                            px: px,
                            py: py,
                            totalPixelsH: totalPixelsH,
                            numCols: numCols
                        });

                        // Add outline for all LEDs (visible when LED is dim/off)
                        const outlineGeom = new THREE.BufferGeometry();
                        const outlineVerts = new Float32Array([
                            c1x, c1y, 0,
                            c2x, c2y, 0,
                            c2x, c2y, 0,
                            c3x, c3y, 0,
                            c3x, c3y, 0,
                            c4x, c4y, 0,
                            c4x, c4y, 0,
                            c1x, c1y, 0
                        ]);
                        outlineGeom.setAttribute('position', new THREE.BufferAttribute(outlineVerts, 3));
                        const outlineMat = new THREE.LineBasicMaterial({ color: 0x333333 });
                        const outline = new THREE.LineSegments(outlineGeom, outlineMat);
                        outline.position.set(localX, localY, localZ + 0.0001);
                        group.add(outline);
                    } else {
                        // Circle LEDs for G3, G4
                        const ledGeom = new THREE.CircleGeometry(ledSize, 8);
                        const ledColor = brightnessToColor(brightness);
                        const ledMat = new THREE.MeshBasicMaterial({ color: ledColor });
                        const led = new THREE.Mesh(ledGeom, ledMat);
                        led.position.set(localX, localY, localZ);
                        group.add(led);

                        // Store reference for efficient animation updates
                        ledMeshes.push({
                            mesh: led,
                            colIndex: colIndex,
                            px: px,
                            py: py,
                            totalPixelsH: totalPixelsH,
                            numCols: numCols
                        });

                        // Add circle outline
                        const circlePoints = [];
                        const segments = 16;
                        for (let i = 0; i <= segments; i++) {
                            const theta = (i / segments) * Math.PI * 2;
                            circlePoints.push(new THREE.Vector3(
                                Math.cos(theta) * ledSize,
                                Math.sin(theta) * ledSize,
                                0
                            ));
                        }
                        const circleGeom = new THREE.BufferGeometry().setFromPoints(circlePoints);
                        const circleMat = new THREE.LineBasicMaterial({ color: 0x333333 });
                        const circle = new THREE.Line(circleGeom, circleMat);
                        circle.position.set(localX, localY, localZ + 0.0001);
                        group.add(circle);
                    }
                }
            }

            return group;
        }

        // Update all LED colors without rebuilding geometry (efficient animation)
        function updateLEDColors() {
            for (const ledRef of ledMeshes) {
                const brightness = getLEDBrightness(
                    ledRef.px, ledRef.py, ledRef.colIndex,
                    ledRef.numCols, ledRef.totalPixelsH
                );
                const newColor = brightnessToColor(brightness);
                ledRef.mesh.material.color.setHex(newColor);
            }
        }

        function updateMetrics(specs, numCols, numRows, cRadius, arenaHeight) {
            const activeCount = state.activePanels ? state.activePanels.length : numCols;
            const totalPanels = activeCount * numRows;
            const totalLEDs = totalPanels * specs.pixels_horizontal * specs.pixels_vertical;

            // Azimuth resolution: angular distance between horizontal pixels
            // Each panel spans (360/numCols) degrees, divided by pixels_horizontal
            const azimuthRes = 360 / (numCols * specs.pixels_horizontal);

            // Vertical resolution: angular distance between vertical pixels as seen from center
            // This depends on the viewing angle from center to the panel
            // For a fly at center, the vertical angle subtended by the panel height
            // tan(verticalAngle/2) = (arenaHeight/2) / cRadius
            // Convert to degrees per pixel
            const panelHeight = specs.panel_height_mm / 25.4;
            const halfAngleRad = Math.atan((arenaHeight / 2) / cRadius);
            const totalVerticalDegrees = 2 * halfAngleRad * (180 / Math.PI);
            const verticalRes = totalVerticalDegrees / (numRows * specs.pixels_vertical);

            const azimuthPixels = numCols * specs.pixels_horizontal;
            const verticalPixels = numRows * specs.pixels_vertical;

            document.getElementById('num-cols-display').textContent = activeCount;
            document.getElementById('total-panels').textContent = totalPanels;
            document.getElementById('inner-radius').textContent = cRadius.toFixed(2) + ' in';
            document.getElementById('arena-height').textContent = arenaHeight.toFixed(2) + ' in';
            document.getElementById('total-leds').textContent = totalLEDs.toLocaleString();
            document.getElementById('azimuth-res').textContent = azimuthRes.toFixed(2) + '°/px';
            document.getElementById('vertical-res').textContent = verticalRes.toFixed(2) + '°/px';
            document.getElementById('azimuth-pixels').textContent = azimuthPixels;
            document.getElementById('vertical-pixels').textContent = verticalPixels;
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // Animation timing
        let lastPhaseTime = 0;
        const phaseInterval = 50; // ms between phase shifts (faster now that it's efficient)

        function animate(currentTime) {
            requestAnimationFrame(animate);

            // Phase shift pattern when auto-rotate is active
            if (autoRotate && state.pattern !== 'allOn') {
                if (currentTime - lastPhaseTime > phaseInterval) {
                    lastPhaseTime = currentTime;
                    state.phaseOffset++;
                    const totalPixels = getTotalAzimuthPixels();
                    if (state.phaseOffset >= totalPixels) {
                        state.phaseOffset = 0;
                    }
                    // Efficient update: just change LED colors, don't rebuild geometry
                    updateLEDColors();
                }
            }

            controls.update();
            renderer.render(scene, camera);
        }

        // Start
        init();
    </script>
</body>
</html>
