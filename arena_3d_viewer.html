<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Arena 3D Viewer - PanelDisplayTools</title>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700&family=IBM+Plex+Mono:wght@400;600&display=swap" rel="stylesheet">
    <script src="js/arena-configs.js"></script>
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.182.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.182.0/examples/jsm/"
            }
        }
    </script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        :root {
            --bg: #0f1419;
            --surface: #1a1f26;
            --border: #2d3640;
            --text: #e6edf3;
            --text-dim: #8b949e;
            --accent: #00e676;
            --hover: #00c853;
        }

        body {
            font-family: 'IBM Plex Mono', monospace;
            background: var(--bg);
            color: var(--text);
            overflow: hidden;
        }

        /* Controls Panel */
        .controls-panel {
            position: fixed;
            top: 1rem;
            left: 1rem;
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 1.25rem;
            width: 280px;
            z-index: 100;
            max-height: calc(100vh - 2rem);
            overflow-y: auto;
        }

        .controls-panel h1 {
            font-family: 'JetBrains Mono', monospace;
            font-size: 1.1rem;
            color: var(--accent);
            margin-bottom: 0.5rem;
        }

        .controls-panel .subtitle {
            font-size: 0.75rem;
            color: var(--text-dim);
            margin-bottom: 1rem;
            padding-bottom: 0.75rem;
            border-bottom: 1px solid var(--border);
        }

        .control-group {
            margin-bottom: 1rem;
        }

        .control-group label {
            display: block;
            font-size: 0.75rem;
            color: var(--text-dim);
            margin-bottom: 0.3rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        /* Config Select */
        .config-select {
            width: 100%;
            padding: 0.5rem 0.6rem;
            background: var(--bg);
            border: 1px solid var(--border);
            border-radius: 4px;
            color: var(--text);
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.8rem;
            cursor: pointer;
        }

        .config-select:hover {
            border-color: var(--accent);
        }

        .config-select:focus {
            outline: none;
            border-color: var(--accent);
        }

        .config-select option {
            background: var(--surface);
            color: var(--text);
        }

        .config-select optgroup {
            background: var(--bg);
            color: var(--accent);
            font-weight: bold;
        }

        /* Config info line */
        .config-info {
            font-size: 0.75rem;
            color: var(--text-dim);
            margin-top: 0.5rem;
            padding: 0.4rem 0.5rem;
            background: var(--bg);
            border-radius: 4px;
        }

        .info-note {
            font-size: 0.65rem;
            color: var(--text-dim);
            margin-top: 0.4rem;
            line-height: 1.4;
            opacity: 0.7;
        }

        /* Toggle buttons for labels */
        .toggle-tabs {
            display: flex;
            gap: 0.3rem;
            flex-wrap: wrap;
        }

        .toggle-tab {
            padding: 0.4rem 0.7rem;
            background: var(--bg);
            border: 1px solid var(--border);
            border-radius: 4px;
            color: var(--text-dim);
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.75rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .toggle-tab:hover {
            border-color: var(--accent);
            color: var(--text);
        }

        .toggle-tab.active {
            background: rgba(0, 230, 118, 0.1);
            border-color: var(--accent);
            color: var(--accent);
        }

        /* Metrics */
        .metric {
            display: flex;
            justify-content: space-between;
            padding: 0.6rem 0;
            border-bottom: 1px solid var(--border);
            font-size: 0.8rem;
        }

        .metric:last-child { border-bottom: none; }
        .metric .label { color: var(--text-dim); }
        .metric .value {
            color: var(--text);
            font-family: 'JetBrains Mono', monospace;
        }

        /* Buttons */
        .btn {
            width: 100%;
            padding: 0.6rem;
            background: var(--accent);
            border: none;
            border-radius: 6px;
            color: var(--bg);
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.85rem;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.2s;
            margin-top: 0.5rem;
        }

        .btn:hover {
            background: var(--hover);
            transform: translateY(-1px);
        }

        .btn.secondary {
            background: var(--surface);
            border: 1px solid var(--accent);
            color: var(--accent);
        }

        .btn.secondary:hover {
            background: rgba(0, 230, 118, 0.1);
        }

        .btn.small {
            padding: 0.4rem 0.6rem;
            font-size: 0.75rem;
        }

        /* 3D Canvas */
        #canvas-container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }

        /* Help Panel */
        .help-panel {
            position: fixed;
            bottom: 1rem;
            left: 1rem;
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 0.75rem 1rem;
            font-size: 0.7rem;
            color: var(--text-dim);
            z-index: 100;
        }

        .help-panel strong { color: var(--text); }

        /* Navigation */
        .nav-link {
            display: inline-block;
            color: var(--text-dim);
            text-decoration: none;
            margin-bottom: 0.75rem;
            font-size: 0.8rem;
            transition: color 0.2s;
        }

        .nav-link:hover { color: var(--accent); }

        /* Info overlay */
        .info-overlay {
            position: fixed;
            top: 1rem;
            right: 1rem;
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 1rem;
            z-index: 100;
            font-size: 0.8rem;
        }

        .info-overlay h3 {
            font-family: 'JetBrains Mono', monospace;
            color: var(--accent);
            font-size: 0.9rem;
            margin-bottom: 0.5rem;
        }

        .resolution-display {
            font-family: 'JetBrains Mono', monospace;
            font-size: 1.2rem;
            font-weight: 700;
            color: var(--accent);
            text-align: center;
            padding: 0.5rem;
            background: rgba(0, 230, 118, 0.1);
            border-radius: 4px;
            margin-bottom: 0.5rem;
        }

        /* Pattern Buttons (inline row) */
        .pattern-btn-group {
            display: flex;
            gap: 0.3rem;
            margin-top: 0.5rem;
        }

        .pattern-btn {
            flex: 1;
            padding: 0.4rem 0.3rem;
            background: var(--bg);
            border: 1px solid var(--border);
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.7rem;
            font-weight: 600;
            color: var(--text);
            text-align: center;
        }

        .pattern-btn:hover {
            border-color: var(--accent);
        }

        .pattern-btn.active {
            border-color: var(--accent);
            background: rgba(0, 230, 118, 0.1);
            color: var(--accent);
        }

        .pattern-btn input[type="radio"] {
            display: none;
        }

        /* Loading Overlay */
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(15, 20, 25, 0.85);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s;
        }

        .loading-overlay.visible {
            opacity: 1;
            pointer-events: all;
        }

        .loading-spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--accent);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 1rem;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .loading-text {
            font-family: 'JetBrains Mono', monospace;
            font-size: 1rem;
            color: var(--accent);
        }

        /* Disabled button state */
        .btn.disabled {
            opacity: 0.5;
            cursor: not-allowed;
            pointer-events: none;
        }

        /* Screenshot buttons */
        .screenshot-group {
            display: flex;
            gap: 0.5rem;
            margin-top: 0.5rem;
        }

        .screenshot-group .btn {
            flex: 1;
            font-size: 0.7rem;
            padding: 0.35rem 0.3rem;
        }

        /* Statistics Panel (upper right) */
        .stats-panel {
            position: fixed;
            top: 1rem;
            right: 1rem;
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 1rem;
            z-index: 100;
            width: 200px;
            font-size: 0.8rem;
        }

        .stats-panel h3 {
            font-family: 'JetBrains Mono', monospace;
            color: var(--accent);
            font-size: 0.85rem;
            margin-bottom: 0.5rem;
        }

        /* View Controls Panel (lower right) */
        .view-controls-panel {
            position: fixed;
            bottom: 1rem;
            right: 1rem;
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 1rem;
            z-index: 100;
            width: 200px;
        }

        .view-controls-panel h3 {
            font-family: 'JetBrains Mono', monospace;
            color: var(--accent);
            font-size: 0.85rem;
            margin-bottom: 0.75rem;
        }

        .view-controls-panel .btn {
            margin-top: 0.4rem;
            font-size: 0.75rem;
            padding: 0.5rem;
        }

        .view-controls-panel .btn:first-of-type {
            margin-top: 0;
        }

        /* Zoom buttons row */
        .zoom-row {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 0.5rem;
        }

        .zoom-row .btn {
            flex: 1;
            margin-top: 0;
        }

        /* View select dropdown */
        .view-select {
            width: 100%;
            padding: 0.5rem;
            background: var(--bg);
            border: 1px solid var(--border);
            border-radius: 4px;
            color: var(--text);
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.75rem;
            cursor: pointer;
            margin-bottom: 0.5rem;
        }

        .view-select:hover {
            border-color: var(--accent);
        }

        .view-select:focus {
            outline: none;
            border-color: var(--accent);
        }

        /* Divider */
        .divider {
            border-top: 1px solid var(--border);
            margin: 0.75rem 0;
        }

        /* Pattern Loading Section */
        .pattern-info {
            background: var(--bg);
            border: 1px solid var(--border);
            border-radius: 4px;
            padding: 0.5rem;
            margin-top: 0.5rem;
            font-size: 0.7rem;
            font-family: 'JetBrains Mono', monospace;
        }

        .pattern-info .filename {
            color: var(--accent);
            font-weight: 600;
            margin-bottom: 0.25rem;
            word-break: break-all;
        }

        .pattern-info .details {
            color: var(--text-dim);
        }

        .pattern-info .details span {
            display: inline-block;
            margin-right: 0.75rem;
        }

        /* Frame Controls */
        .frame-controls {
            margin-top: 0.75rem;
        }

        .frame-slider-row {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 0.5rem;
        }

        .frame-slider {
            flex: 1;
            -webkit-appearance: none;
            height: 4px;
            background: var(--border);
            border-radius: 2px;
            outline: none;
        }

        .frame-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 14px;
            height: 14px;
            background: var(--accent);
            border-radius: 50%;
            cursor: pointer;
        }

        .frame-slider::-moz-range-thumb {
            width: 14px;
            height: 14px;
            background: var(--accent);
            border-radius: 50%;
            cursor: pointer;
            border: none;
        }

        .frame-display {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.7rem;
            color: var(--text-dim);
            min-width: 60px;
            text-align: right;
        }

        .playback-row {
            display: flex;
            gap: 0.5rem;
            align-items: center;
        }

        .playback-row .btn {
            flex: 1;
        }

        .fps-select {
            width: 80px;
            padding: 0.4rem;
            background: var(--bg);
            border: 1px solid var(--border);
            border-radius: 4px;
            color: var(--text);
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.7rem;
        }

        /* FOV Controls */
        .fov-controls {
            margin-top: 0.5rem;
        }

        .fov-slider-row {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .fov-slider {
            flex: 1;
            -webkit-appearance: none;
            height: 4px;
            background: var(--border);
            border-radius: 2px;
            outline: none;
        }

        .fov-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 12px;
            height: 12px;
            background: var(--accent);
            border-radius: 50%;
            cursor: pointer;
        }

        .fov-slider::-moz-range-thumb {
            width: 12px;
            height: 12px;
            background: var(--accent);
            border-radius: 50%;
            cursor: pointer;
            border: none;
        }

        .fov-display {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.7rem;
            color: var(--text-dim);
            min-width: 40px;
            text-align: right;
        }

        .fov-presets {
            display: flex;
            gap: 0.3rem;
            margin-top: 0.4rem;
        }

        .fov-presets .btn {
            flex: 1;
            font-size: 0.7rem;
            padding: 0.35rem 0.3rem;
            white-space: nowrap;
        }

        /* Unsaved indicator */
        .unsaved-badge {
            display: inline-block;
            background: #f59e0b;
            color: #000;
            font-size: 0.6rem;
            font-weight: bold;
            padding: 0.1rem 0.3rem;
            border-radius: 3px;
            margin-left: 0.3rem;
            vertical-align: middle;
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>

    <!-- Controls Panel -->
    <div class="controls-panel">
        <a href="#" class="nav-link" id="back-link">← Back</a>
        <h1>Arena 3D Viewer</h1>
        <p class="subtitle">View arena configuration in 3D</p>

        <div class="control-group">
            <label>Arena Configuration</label>
            <select class="config-select" id="config-select">
                <optgroup label="G6 Arenas" id="config-group-G6"></optgroup>
                <optgroup label="G4.1 Arenas" id="config-group-G41"></optgroup>
                <optgroup label="G4 Arenas" id="config-group-G4"></optgroup>
                <optgroup label="G3 Arenas" id="config-group-G3"></optgroup>
            </select>
            <div class="config-info" id="config-info">G6 • 2×10 • 360°</div>
            <p class="info-note">G4.1 & G6 actively tested. G3 & G4 for comparison.</p>
        </div>

        <button class="btn secondary small" id="load-file">Load from File</button>

        <div class="divider"></div>

        <div class="control-group">
            <label>Labels</label>
            <div class="toggle-tabs">
                <button class="toggle-tab" id="toggle-col-labels">Col #</button>
                <button class="toggle-tab" id="toggle-panel-labels">Panel #</button>
            </div>
        </div>

        <div class="divider"></div>

        <!-- Test Patterns: 3 inline buttons -->
        <div class="control-group">
            <label>Test Patterns</label>
            <div class="pattern-btn-group">
                <label class="pattern-btn active" id="pattern-allon-label">
                    <input type="radio" name="pattern" value="allOn" checked>
                    All On
                </label>
                <label class="pattern-btn" id="pattern-grating-label">
                    <input type="radio" name="pattern" value="grating">
                    Grating
                </label>
                <label class="pattern-btn" id="pattern-sine-label">
                    <input type="radio" name="pattern" value="sine">
                    Sine
                </label>
            </div>
            <!-- Pattern parameter controls (shown when grating or sine selected) -->
            <div id="grating-controls" class="pattern-controls" style="display: none; margin-top: 0.5rem;">
                <select id="grating-select" style="width: 100%; padding: 0.4rem; background: var(--bg); border: 1px solid var(--border); border-radius: 4px; color: var(--text); font-family: 'JetBrains Mono', monospace; font-size: 0.75rem;">
                </select>
            </div>
            <div id="sine-controls" class="pattern-controls" style="display: none; margin-top: 0.5rem;">
                <select id="sine-select" style="width: 100%; padding: 0.4rem; background: var(--bg); border: 1px solid var(--border); border-radius: 4px; color: var(--text); font-family: 'JetBrains Mono', monospace; font-size: 0.75rem;">
                </select>
            </div>
        </div>

        <div class="divider"></div>

        <!-- Load Pattern File -->
        <div class="control-group">
            <label>Load Pattern File</label>
            <button class="btn" id="load-pattern" style="margin-top: 0.5rem;">Load .pat File</button>
            <div class="pattern-info" id="pattern-info" style="display: none;">
                <div class="filename" id="pattern-filename">pattern.pat</div>
                <div class="details">
                    <span id="pattern-gen">G6</span>
                    <span id="pattern-dims">40×200</span>
                    <span id="pattern-frames">1 frame</span>
                    <span id="pattern-gs">GS16</span>
                </div>
            </div>
            <button class="btn secondary" id="clear-pattern" style="display: none; margin-top: 0.5rem;">Clear Pattern</button>
        </div>

        <div class="divider"></div>

        <!-- Playback Controls (at bottom) -->
        <div class="control-group">
            <label>Playback</label>
            <div class="playback-row" style="margin-top: 0.5rem;">
                <button class="btn secondary" id="play-pause-btn">▶ Play</button>
                <select class="fps-select" id="fps-select">
                    <option value="-30">-30 FPS</option>
                    <option value="-20">-20 FPS</option>
                    <option value="-10">-10 FPS</option>
                    <option value="-5">-5 FPS</option>
                    <option value="5">5 FPS</option>
                    <option value="10" selected>10 FPS</option>
                    <option value="20">20 FPS</option>
                    <option value="30">30 FPS</option>
                </select>
            </div>
            <!-- Frame slider (only visible for multi-frame patterns) -->
            <div class="frame-controls" id="frame-controls" style="display: none;">
                <div class="frame-slider-row">
                    <input type="range" class="frame-slider" id="frame-slider" min="1" max="1" value="1">
                    <span class="frame-display" id="frame-display">1 / 1</span>
                </div>
            </div>
        </div>

    </div>

    <!-- Loading Overlay -->
    <div class="loading-overlay" id="loading-overlay">
        <div class="loading-spinner"></div>
        <div class="loading-text" id="loading-text">Updating...</div>
    </div>

    <!-- Statistics Panel (upper right) -->
    <div class="stats-panel">
        <h3>Statistics</h3>
        <div class="metric">
            <span class="label">Columns</span>
            <span class="value" id="num-cols-display">10</span>
        </div>
        <div class="metric">
            <span class="label">Total Panels</span>
            <span class="value" id="total-panels">20</span>
        </div>
        <div class="metric">
            <span class="label">Inner Radius</span>
            <span class="value" id="inner-radius">70.0 mm</span>
        </div>
        <div class="metric">
            <span class="label">Arena Height</span>
            <span class="value" id="arena-height">90.8 mm</span>
        </div>
        <div class="metric">
            <span class="label">Total LEDs</span>
            <span class="value" id="total-leds">8,000</span>
        </div>
        <div style="border-top: 1px solid var(--border); margin-top: 0.5rem; padding-top: 0.5rem;">
            <div class="metric">
                <span class="label">Azimuth Res</span>
                <span class="value" id="azimuth-res">1.80°/px</span>
            </div>
            <div class="metric">
                <span class="label">Vertical Res</span>
                <span class="value" id="vertical-res">3.72°/px</span>
            </div>
            <div class="metric">
                <span class="label">Azimuth px</span>
                <span class="value" id="azimuth-pixels">200</span>
            </div>
            <div class="metric">
                <span class="label">Vertical px</span>
                <span class="value" id="vertical-pixels">40</span>
            </div>
        </div>
    </div>

    <!-- View Controls Panel (lower right) -->
    <div class="view-controls-panel">
        <h3>View Controls</h3>
        <div class="zoom-row">
            <button class="btn secondary" id="zoom-closer">Closer</button>
            <button class="btn secondary" id="zoom-farther">Farther</button>
        </div>
        <select class="view-select" id="view-select">
            <option value="top-down">Top Down</option>
            <option value="side">Side View</option>
            <option value="fly">Fly View (Center)</option>
            <option value="north">From North</option>
            <option value="south">From South</option>
            <option value="east">From East</option>
            <option value="west">From West</option>
        </select>

        <div class="fov-controls">
            <label style="font-size: 0.7rem; color: var(--text-dim); text-transform: uppercase; letter-spacing: 0.5px;">Field of View</label>
            <div class="fov-slider-row">
                <input type="range" class="fov-slider" id="fov-slider" min="30" max="120" value="60">
                <span class="fov-display" id="fov-display">60°</span>
            </div>
            <div class="fov-presets">
                <button class="btn secondary" data-fov="60">Normal</button>
                <button class="btn secondary" data-fov="120">Wide</button>
            </div>
        </div>

        <div style="border-top: 1px solid var(--border); padding-top: 0.75rem; margin-top: 0.75rem;">
            <label style="font-size: 0.7rem; color: var(--text-dim); text-transform: uppercase; letter-spacing: 0.5px;">Screenshot</label>
            <div class="screenshot-group" style="margin-top: 0.4rem;">
                <button class="btn secondary" id="screenshot-arena">Arena</button>
                <button class="btn secondary" id="screenshot-full">+ Stats</button>
            </div>
        </div>
    </div>

    <!-- Help Panel -->
    <div class="help-panel">
        <strong>Controls:</strong> Drag to rotate | Scroll to zoom | Right-drag to pan
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { CSS2DRenderer, CSS2DObject } from 'three/addons/renderers/CSS2DRenderer.js';
        import { parsePatFile, verifyPatternOrientation, findMatchingConfig } from './js/pat-parser.js';

        // State
        let state = {
            configSource: {
                type: 'standard',  // 'standard', 'file', 'custom'
                name: 'G6_2x10'
            },
            arena: {
                generation: 'G6',
                num_rows: 2,
                num_cols: 10,
                columns_installed: null,
                column_order: 'cw',
                angle_offset_deg: 0
            },
            pattern: 'allOn',    // 'allOn', 'grating', 'sine', 'custom'
            gratingPixels: 20,   // pixels on/off for grating
            sineWavelength: 120, // wavelength in pixels
            phaseOffset: 0,      // current phase offset for auto-rotate
            showColumnLabels: false,
            showPanelLabels: false,
            // Custom pattern state
            customPattern: null,     // Loaded pattern data from pat-parser
            currentFrame: 0,         // 0-indexed frame number
            isPlaying: false,        // Playback state
            playbackFPS: 10,         // Frames per second
            playbackIntervalId: null // setInterval ID for playback
        };

        // 16 grayscale levels
        const GRAYSCALE_LEVELS = 16;

        // Column numbering convention:
        // - c0/cN-1 boundary is at SOUTH (-Z in Three.js coords)
        // - CW order: c0 just LEFT of south, columns increase counter-clockwise
        // - CCW order: c0 just RIGHT of south, columns increase clockwise (mirror)
        // In Three.js: +Z is north, -Z is south, angle 0 is +X (east)
        const BASE_OFFSET_RAD = -Math.PI / 2;  // Rotate baseline from +X to -Z (south)

        // Loading indicator functions
        function showLoading(message = 'Updating...') {
            document.getElementById('loading-text').textContent = message;
            document.getElementById('loading-overlay').classList.add('visible');
        }

        function hideLoading() {
            document.getElementById('loading-overlay').classList.remove('visible');
        }

        // Wrap buildArena with loading indicator
        function buildArenaWithLoading() {
            showLoading('Building arena...');
            setTimeout(() => {
                buildArena();
                hideLoading();
            }, 50);
        }

        // Populate config dropdown from STANDARD_CONFIGS
        function populateConfigDropdown() {
            const groups = getConfigsByGeneration();

            for (const [gen, configs] of Object.entries(groups)) {
                const groupId = gen === 'G4.1' ? 'G41' : gen;
                const optgroup = document.getElementById(`config-group-${groupId}`);
                if (!optgroup) continue;

                optgroup.innerHTML = '';
                for (const config of configs) {
                    const option = document.createElement('option');
                    option.value = config.name;
                    option.textContent = config.label;
                    optgroup.appendChild(option);
                }
            }
        }

        // Load a standard config by name
        function loadStandardConfig(name) {
            const config = getConfig(name);
            if (!config) return;

            state.configSource = { type: 'standard', name };
            state.arena = { ...config.arena };
            state.phaseOffset = 0;

            document.getElementById('config-select').value = name;
            updateConfigInfo();
            populatePatternSelects();
            buildArenaWithLoading();
        }

        // Update config info display
        function updateConfigInfo() {
            const { generation, num_rows, num_cols, columns_installed } = state.arena;
            const installedCols = getInstalledColumnCount();
            const coverage = Math.round(360 * installedCols / num_cols);
            document.getElementById('config-info').textContent =
                `${generation} • ${num_rows}×${num_cols} • ${coverage}°`;
        }

        // Get installed column count
        function getInstalledColumnCount() {
            if (state.arena.columns_installed === null) {
                return state.arena.num_cols;
            }
            const maxIndex = Math.max(...state.arena.columns_installed);
            if (maxIndex < state.arena.num_cols) {
                return state.arena.columns_installed.length;
            } else {
                const uniqueCols = new Set(state.arena.columns_installed.map(p => p % state.arena.num_cols));
                return uniqueCols.size;
            }
        }

        // Get set of installed column indices (0-indexed)
        function getInstalledColumnsSet() {
            if (state.arena.columns_installed === null) {
                return new Set([...Array(state.arena.num_cols).keys()]);
            }
            const maxIndex = Math.max(...state.arena.columns_installed);
            if (maxIndex < state.arena.num_cols) {
                return new Set(state.arena.columns_installed);
            } else {
                return new Set(state.arena.columns_installed.map(p => p % state.arena.num_cols));
            }
        }

        // Parse URL parameters (supports both new config= and legacy params)
        function parseUrlParams() {
            const params = new URLSearchParams(window.location.search);

            // New format: ?config=NAME
            if (params.has('config')) {
                const configName = params.get('config');
                const config = getConfig(configName);
                if (config) {
                    state.configSource = { type: 'standard', name: configName };
                    state.arena = { ...config.arena };
                    return;
                }
            }

            // Legacy format: ?gen=G6&cols=10&rows=2&active=0,1,2...
            if (params.has('gen') || params.has('cols')) {
                state.configSource = { type: 'custom', name: null };
                if (params.has('gen')) state.arena.generation = params.get('gen');
                if (params.has('cols')) state.arena.num_cols = parseInt(params.get('cols'));
                if (params.has('rows')) state.arena.num_rows = parseInt(params.get('rows'));
                if (params.has('order')) state.arena.column_order = params.get('order');
                if (params.has('offset')) state.arena.angle_offset_deg = parseFloat(params.get('offset'));
                if (params.has('active')) {
                    const activeStr = params.get('active');
                    if (activeStr) {
                        state.arena.columns_installed = activeStr.split(',').map(n => parseInt(n));
                    }
                } else {
                    state.arena.columns_installed = null;
                }
                return;
            }

            // Default: G6_2x10
            loadStandardConfig('G6_2x10');
        }

        // Three.js objects
        let scene, camera, renderer, labelRenderer, controls;
        let arenaGroup;
        let ledMeshes = [];

        // Initialize
        function init() {
            const container = document.getElementById('canvas-container');

            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0f1419);

            // Camera
            camera = new THREE.PerspectiveCamera(
                60,
                window.innerWidth / window.innerHeight,
                0.1,
                1000
            );

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true, preserveDrawingBuffer: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            container.appendChild(renderer.domElement);

            // CSS2D Renderer for labels
            labelRenderer = new CSS2DRenderer();
            labelRenderer.setSize(window.innerWidth, window.innerHeight);
            labelRenderer.domElement.style.position = 'absolute';
            labelRenderer.domElement.style.top = '0px';
            labelRenderer.domElement.style.pointerEvents = 'none';
            container.appendChild(labelRenderer.domElement);

            // Controls
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.minDistance = 0.1;
            controls.maxDistance = 50;

            // Lighting
            const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.3);
            directionalLight.position.set(5, 10, 5);
            scene.add(directionalLight);

            // Grid helper
            const gridHelper = new THREE.GridHelper(20, 20, 0x2d3640, 0x1a1f26);
            gridHelper.position.y = -5;
            scene.add(gridHelper);

            // Arena group (includes panels and labels)
            arenaGroup = new THREE.Group();
            scene.add(arenaGroup);

            // Populate dropdown and parse URL
            populateConfigDropdown();
            parseUrlParams();

            // Update UI to match state
            if (state.configSource.type === 'standard') {
                document.getElementById('config-select').value = state.configSource.name;
            }
            updateConfigInfo();
            populatePatternSelects();

            // Build initial arena
            buildArena();

            // Set initial view
            setInitialView();

            // Initialize FOV display
            const initialFOV = parseInt(document.getElementById('fov-slider').value);
            document.getElementById('fov-display').textContent = `${initialFOV}°`;

            // Event listeners
            setupEventListeners();

            // Start animation
            animate();
        }

        // Get integer divisors of a number
        function getIntegerDivisors(n) {
            const divisors = [];
            for (let i = 1; i <= n; i++) {
                if (n % i === 0) {
                    divisors.push(i);
                }
            }
            return divisors;
        }

        // Get total azimuth pixels
        function getTotalAzimuthPixels() {
            const specs = PANEL_SPECS[state.arena.generation];
            return state.arena.num_cols * specs.pixels_per_panel;
        }

        // Populate grating and sine select dropdowns
        function populatePatternSelects() {
            const totalPixels = getTotalAzimuthPixels();
            const divisors = getIntegerDivisors(totalPixels);

            // Grating select
            const gratingSelect = document.getElementById('grating-select');
            gratingSelect.innerHTML = '';
            const validGratings = divisors.filter(d => d <= totalPixels / 2 && totalPixels % (2 * d) === 0);
            validGratings.forEach(d => {
                const option = document.createElement('option');
                option.value = d;
                const numBars = totalPixels / (2 * d);
                option.textContent = `${d} px (${numBars} cycles)`;
                if (d === state.gratingPixels) option.selected = true;
                gratingSelect.appendChild(option);
            });

            if (!validGratings.includes(state.gratingPixels)) {
                state.gratingPixels = validGratings.length > 0 ? validGratings[Math.floor(validGratings.length / 2)] : 1;
                gratingSelect.value = state.gratingPixels;
            }

            // Sine select
            const sineSelect = document.getElementById('sine-select');
            sineSelect.innerHTML = '';
            const validSines = divisors.filter(d => d >= 4);
            validSines.forEach(d => {
                const option = document.createElement('option');
                option.value = d;
                const numCycles = totalPixels / d;
                option.textContent = `λ = ${d} px (${numCycles} cycles)`;
                if (d === state.sineWavelength) option.selected = true;
                sineSelect.appendChild(option);
            });

            if (!validSines.includes(state.sineWavelength)) {
                const target = Math.floor(totalPixels / 4);
                state.sineWavelength = validSines.reduce((prev, curr) =>
                    Math.abs(curr - target) < Math.abs(prev - target) ? curr : prev, validSines[0]);
                sineSelect.value = state.sineWavelength;
            }

        }

        function updatePatternUI() {
            document.querySelectorAll('.pattern-btn').forEach(r => r.classList.remove('active'));

            if (state.pattern === 'allOn') {
                document.getElementById('pattern-allon-label').classList.add('active');
                document.getElementById('grating-controls').style.display = 'none';
                document.getElementById('sine-controls').style.display = 'none';
            } else if (state.pattern === 'grating') {
                document.getElementById('pattern-grating-label').classList.add('active');
                document.getElementById('grating-controls').style.display = 'block';
                document.getElementById('sine-controls').style.display = 'none';
            } else if (state.pattern === 'sine') {
                document.getElementById('pattern-sine-label').classList.add('active');
                document.getElementById('grating-controls').style.display = 'none';
                document.getElementById('sine-controls').style.display = 'block';
            }
        }

        function setInitialView() {
            const specs = PANEL_SPECS[state.arena.generation];
            const panelWidth = specs.panel_width_mm / 25.4;
            const alpha = (2 * Math.PI) / state.arena.num_cols;
            const cRadius = panelWidth / (Math.tan(alpha / 2)) / 2;
            // Arena geometry is centered at Y=0
            const midlineY = 0;

            // Initial view: top-down (matches dropdown default)
            const viewDistance = cRadius * 3;
            camera.position.set(0, viewDistance, 0.01);
            controls.target.set(0, midlineY, 0);
            controls.update();
        }

        function applyStandardView(viewType) {
            const specs = PANEL_SPECS[state.arena.generation];
            const panelWidth = specs.panel_width_mm / 25.4;
            const alpha = (2 * Math.PI) / state.arena.num_cols;
            const cRadius = panelWidth / (Math.tan(alpha / 2)) / 2;
            const viewDistance = cRadius * 3;
            // Arena geometry is centered at Y=0 (columns go from -halfH to +halfH)
            // So arena midline is at Y=0
            const midlineY = 0;

            switch (viewType) {
                case 'top-down':
                    // Top-down with north at top of screen (camera looking down -Y)
                    camera.position.set(0, viewDistance, 0.01);
                    controls.target.set(0, midlineY, 0);
                    break;
                case 'side':
                    camera.position.set(viewDistance, midlineY, 0);
                    controls.target.set(0, midlineY, 0);
                    break;
                case 'fly':
                    // Fly view: inside arena at midline, looking toward north
                    // In our coords: north = -Z (since we negated Z to match MATLAB)
                    camera.position.set(0, midlineY, 0);
                    controls.target.set(0, midlineY, -cRadius);
                    break;
                case 'north':
                    // From North: camera at north (-Z), looking toward south (+Z)
                    camera.position.set(0, midlineY, -viewDistance);
                    controls.target.set(0, midlineY, 0);
                    break;
                case 'south':
                    // From South: camera at south (+Z), looking toward north (-Z)
                    camera.position.set(0, midlineY, viewDistance);
                    controls.target.set(0, midlineY, 0);
                    break;
                case 'east':
                    camera.position.set(viewDistance, midlineY, 0);
                    controls.target.set(0, midlineY, 0);
                    break;
                case 'west':
                    camera.position.set(-viewDistance, midlineY, 0);
                    controls.target.set(0, midlineY, 0);
                    break;
            }
            controls.update();
        }

        // Simple YAML parser
        function parseYAML(yamlText) {
            const config = {};
            let currentSection = config;

            const lines = yamlText.split('\n');
            for (const line of lines) {
                if (line.trim().startsWith('#') || line.trim() === '') continue;

                if (line.match(/^(\w+):$/)) {
                    const sectionName = line.match(/^(\w+):$/)[1];
                    config[sectionName] = {};
                    currentSection = config[sectionName];
                    continue;
                }

                const kvMatch = line.match(/^\s+(\w+):\s*(.+?)(?:\s*#.*)?$/);
                if (kvMatch) {
                    const key = kvMatch[1];
                    let value = kvMatch[2].trim();

                    if (value === 'null') {
                        currentSection[key] = null;
                    } else if (value.startsWith('[') && value.endsWith(']')) {
                        const arrayContent = value.slice(1, -1);
                        currentSection[key] = arrayContent.trim() === '' ? [] :
                            arrayContent.split(',').map(v => {
                                v = v.trim();
                                const num = parseFloat(v);
                                return isNaN(num) ? v.replace(/^"|"$/g, '') : num;
                            });
                    } else if (value.startsWith('"') && value.endsWith('"')) {
                        currentSection[key] = value.slice(1, -1);
                    } else if (!isNaN(parseFloat(value))) {
                        currentSection[key] = parseFloat(value);
                    } else {
                        currentSection[key] = value;
                    }
                }
            }

            return config;
        }

        // Load .pat pattern file
        function loadPatternFile() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.pat';

            input.addEventListener('change', async (e) => {
                const file = e.target.files[0];
                if (!file) return;

                try {
                    showLoading('Parsing pattern...');
                    const arrayBuffer = await file.arrayBuffer();
                    const patternData = parsePatFile(arrayBuffer);

                    // Run verification and log to console
                    const checks = verifyPatternOrientation(patternData);
                    const allPassed = checks.every(c => c.pass);
                    if (!allPassed) {
                        console.warn('Pattern orientation verification found issues - check console output');
                    }

                    // Log pattern details to console (duplicate logging since parser also logs)
                    console.log('Pattern parsing complete. See details above.');

                    // Store pattern data
                    state.customPattern = patternData;
                    state.currentFrame = 0;
                    state.pattern = 'custom';

                    // Auto-detect matching arena config
                    const matchingConfig = findMatchingConfig(patternData, STANDARD_CONFIGS);
                    if (matchingConfig) {
                        console.log(`Auto-detected arena config: ${matchingConfig}`);
                        loadStandardConfig(matchingConfig);
                    } else {
                        console.log('No matching arena config found - using current config');
                        // Update arena to match pattern dimensions
                        state.arena.generation = patternData.generation;
                        state.arena.num_rows = patternData.rowCount;
                        state.arena.num_cols = patternData.colCount;
                        updateConfigInfo();
                        buildArenaWithLoading();
                    }

                    // Update UI
                    updatePatternInfoDisplay(file.name, patternData);
                    updateFrameControls();

                    // Deselect built-in patterns
                    document.querySelectorAll('.pattern-btn').forEach(r => r.classList.remove('active'));
                    document.getElementById('grating-controls').style.display = 'none';
                    document.getElementById('sine-controls').style.display = 'none';

                    hideLoading();

                } catch (err) {
                    hideLoading();
                    console.error('Error loading pattern:', err);
                    alert('Error loading pattern: ' + err.message);
                }
            });

            input.click();
        }

        // Update pattern info display
        function updatePatternInfoDisplay(filename, patternData) {
            document.getElementById('pattern-info').style.display = 'block';
            document.getElementById('pattern-filename').textContent = filename;
            document.getElementById('pattern-gen').textContent = patternData.generation;
            document.getElementById('pattern-dims').textContent = `${patternData.pixelRows}×${patternData.pixelCols}`;
            document.getElementById('pattern-frames').textContent = patternData.numFrames === 1 ? '1 frame' : `${patternData.numFrames} frames`;
            document.getElementById('pattern-gs').textContent = patternData.gs_val === 2 ? 'GS2' : 'GS16';
            document.getElementById('clear-pattern').style.display = 'block';
        }

        // Update frame controls visibility and range
        function updateFrameControls() {
            const frameControls = document.getElementById('frame-controls');
            if (state.customPattern && state.customPattern.numFrames > 1) {
                frameControls.style.display = 'block';
                const slider = document.getElementById('frame-slider');
                slider.max = state.customPattern.numFrames;
                slider.value = state.currentFrame + 1;
                updateFrameDisplay();
            } else {
                frameControls.style.display = 'none';
            }
        }

        // Update frame display text
        function updateFrameDisplay() {
            const total = state.customPattern ? state.customPattern.numFrames : 1;
            document.getElementById('frame-display').textContent = `${state.currentFrame + 1} / ${total}`;
            document.getElementById('frame-slider').value = state.currentFrame + 1;
        }

        // Enable/disable controls during playback
        function setControlsEnabled(enabled) {
            // Disable arena config dropdown
            document.getElementById('config-select').disabled = !enabled;
            // Disable test pattern radio buttons
            document.querySelectorAll('input[name="pattern"]').forEach(el => el.disabled = !enabled);
            // Disable pattern-specific controls
            document.getElementById('grating-select').disabled = !enabled;
            document.getElementById('sine-select').disabled = !enabled;
            // Disable Load/Clear Pattern buttons
            document.getElementById('load-pattern').disabled = !enabled;
            document.getElementById('clear-pattern').disabled = !enabled;
        }

        // Start playback
        function startPlayback() {
            if (state.playbackIntervalId) return;

            // Don't start playback for "All On" pattern (nothing to animate)
            if (state.pattern === 'allOn') {
                return;
            }

            state.isPlaying = true;
            document.getElementById('play-pause-btn').textContent = '⏸ Pause';
            setControlsEnabled(false);

            const direction = state.playbackFPS > 0 ? 1 : -1;
            const intervalMs = 1000 / Math.abs(state.playbackFPS);
            state.playbackIntervalId = setInterval(() => {
                if (state.customPattern) {
                    // Loaded .pat file: cycle through frames
                    state.currentFrame = (state.currentFrame + direction + state.customPattern.numFrames) % state.customPattern.numFrames;
                    updateFrameDisplay();
                    updateLEDColors();
                } else if (state.pattern === 'grating' || state.pattern === 'sine') {
                    // Test pattern: rotate phase
                    const totalPixels = getTotalAzimuthPixels();
                    state.phaseOffset = (state.phaseOffset + direction + totalPixels) % totalPixels;
                    updateLEDColors();
                }
            }, intervalMs);
        }

        // Stop playback
        function stopPlayback() {
            if (state.playbackIntervalId) {
                clearInterval(state.playbackIntervalId);
                state.playbackIntervalId = null;
            }
            state.isPlaying = false;
            document.getElementById('play-pause-btn').textContent = '▶ Play';
            setControlsEnabled(true);
        }

        // Clear loaded pattern
        function clearPattern() {
            stopPlayback();
            state.customPattern = null;
            state.currentFrame = 0;
            state.pattern = 'allOn';

            document.getElementById('pattern-info').style.display = 'none';
            document.getElementById('frame-controls').style.display = 'none';
            document.getElementById('clear-pattern').style.display = 'none';

            // Re-select "All On" pattern
            document.getElementById('pattern-allon-label').classList.add('active');
            document.querySelector('input[value="allOn"]').checked = true;

            buildArenaWithLoading();
        }

        // Update camera FOV
        function updateCameraFOV(fov, compensateDistance = false) {
            const oldFOV = camera.fov;
            camera.fov = fov;
            camera.updateProjectionMatrix();
            document.getElementById('fov-display').textContent = `${fov}°`;
            document.getElementById('fov-slider').value = fov;

            // Optionally compensate camera distance to maintain apparent scene size
            // Scale factor based on ratio of tan(fov/2): larger FOV needs closer camera
            if (compensateDistance && oldFOV !== fov) {
                const oldTan = Math.tan((oldFOV / 2) * Math.PI / 180);
                const newTan = Math.tan((fov / 2) * Math.PI / 180);
                const scale = oldTan / newTan;

                const direction = new THREE.Vector3();
                direction.subVectors(camera.position, controls.target);
                direction.multiplyScalar(scale);
                camera.position.copy(controls.target).add(direction);
                controls.update();
            }
        }

        // Load config from file
        function loadConfigFromFile() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.yaml,.yml';

            input.addEventListener('change', async (e) => {
                const file = e.target.files[0];
                if (!file) return;

                try {
                    const text = await file.text();
                    const config = parseYAML(text);

                    if (config.arena) {
                        state.configSource = { type: 'file', name: file.name };
                        state.arena = { ...config.arena };
                        // Backward compatibility: accept old field name panels_installed
                        if (state.arena.panels_installed !== undefined && state.arena.columns_installed === undefined) {
                            state.arena.columns_installed = state.arena.panels_installed;
                            delete state.arena.panels_installed;
                        }
                        state.phaseOffset = 0;

                        updateConfigInfo();
                        populatePatternSelects();
                        buildArenaWithLoading();
                    }
                } catch (err) {
                    alert('Error loading config: ' + err.message);
                }
            });

            input.click();
        }

        function setupEventListeners() {
            // Back navigation
            document.getElementById('back-link').addEventListener('click', (e) => {
                e.preventDefault();
                const params = new URLSearchParams(window.location.search);
                if (params.has('config') || params.has('gen') || params.has('cols')) {
                    showLoading('Loading 2D Editor...');
                    setTimeout(() => {
                        window.location.href = 'arena_editor.html';
                    }, 100);
                } else {
                    showLoading('Loading...');
                    setTimeout(() => {
                        window.location.href = 'index.html';
                    }, 100);
                }
            });

            // Config dropdown change - clear any loaded pattern before switching arenas
            document.getElementById('config-select').addEventListener('change', (e) => {
                clearPattern();
                loadStandardConfig(e.target.value);
            });

            // Load from file
            document.getElementById('load-file').addEventListener('click', loadConfigFromFile);

            // Label toggle buttons - rebuild arena since labels are attached to column groups
            document.getElementById('toggle-col-labels').addEventListener('click', () => {
                state.showColumnLabels = !state.showColumnLabels;
                document.getElementById('toggle-col-labels').classList.toggle('active', state.showColumnLabels);
                buildArenaWithLoading();
            });

            document.getElementById('toggle-panel-labels').addEventListener('click', () => {
                state.showPanelLabels = !state.showPanelLabels;
                document.getElementById('toggle-panel-labels').classList.toggle('active', state.showPanelLabels);
                buildArenaWithLoading();
            });

            // Pattern radio controls
            document.querySelectorAll('.pattern-btn input[type="radio"]').forEach(radio => {
                radio.addEventListener('change', () => {
                    // Clear custom pattern when selecting built-in pattern
                    if (state.customPattern) {
                        stopPlayback();
                        state.customPattern = null;
                        state.currentFrame = 0;
                        document.getElementById('pattern-info').style.display = 'none';
                        document.getElementById('frame-controls').style.display = 'none';
                        document.getElementById('clear-pattern').style.display = 'none';
                    }
                    state.pattern = radio.value;
                    state.phaseOffset = 0;
                    updatePatternUI();
                    buildArenaWithLoading();
                });
            });

            document.querySelectorAll('.pattern-btn').forEach(label => {
                label.addEventListener('click', () => {
                    const radio = label.querySelector('input[type="radio"]');
                    if (radio && !radio.checked) {
                        // Clear custom pattern when selecting built-in pattern
                        if (state.customPattern) {
                            stopPlayback();
                            state.customPattern = null;
                            state.currentFrame = 0;
                            document.getElementById('pattern-info').style.display = 'none';
                            document.getElementById('frame-controls').style.display = 'none';
                            document.getElementById('clear-pattern').style.display = 'none';
                        }
                        radio.checked = true;
                        state.pattern = radio.value;
                        state.phaseOffset = 0;
                        updatePatternUI();
                        buildArenaWithLoading();
                    }
                });
            });

            // Grating select
            document.getElementById('grating-select').addEventListener('change', (e) => {
                state.gratingPixels = parseInt(e.target.value);
                state.phaseOffset = 0;
                buildArenaWithLoading();
            });

            // Sine select
            document.getElementById('sine-select').addEventListener('change', (e) => {
                state.sineWavelength = parseInt(e.target.value);
                state.phaseOffset = 0;
                buildArenaWithLoading();
            });

            // Zoom buttons
            document.getElementById('zoom-closer').addEventListener('click', () => {
                const direction = new THREE.Vector3();
                direction.subVectors(camera.position, controls.target);
                direction.multiplyScalar(0.8);
                camera.position.copy(controls.target).add(direction);
                controls.update();
            });

            document.getElementById('zoom-farther').addEventListener('click', () => {
                const direction = new THREE.Vector3();
                direction.subVectors(camera.position, controls.target);
                direction.multiplyScalar(1.25);
                camera.position.copy(controls.target).add(direction);
                controls.update();
            });

            // View selector
            document.getElementById('view-select').addEventListener('change', () => {
                const viewType = document.getElementById('view-select').value;
                applyStandardView(viewType);
            });

            // Window resize
            window.addEventListener('resize', onWindowResize);

            // Screenshot buttons
            document.getElementById('screenshot-arena').addEventListener('click', () => {
                takeScreenshot(false);
            });
            document.getElementById('screenshot-full').addEventListener('click', () => {
                takeScreenshot(true);
            });

            // Pattern loading
            document.getElementById('load-pattern').addEventListener('click', loadPatternFile);
            document.getElementById('clear-pattern').addEventListener('click', clearPattern);

            // Frame controls
            document.getElementById('frame-slider').addEventListener('input', (e) => {
                state.currentFrame = parseInt(e.target.value) - 1;
                updateFrameDisplay();
                updateLEDColors();
            });

            document.getElementById('play-pause-btn').addEventListener('click', () => {
                if (state.isPlaying) {
                    stopPlayback();
                } else {
                    startPlayback();
                }
            });

            document.getElementById('fps-select').addEventListener('change', (e) => {
                state.playbackFPS = parseInt(e.target.value);
                // If currently playing, restart with new FPS
                if (state.isPlaying) {
                    stopPlayback();
                    startPlayback();
                }
            });

            // FOV controls
            document.getElementById('fov-slider').addEventListener('input', (e) => {
                updateCameraFOV(parseInt(e.target.value));
            });

            // FOV preset buttons
            document.querySelectorAll('.fov-presets .btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    const fov = parseInt(btn.dataset.fov);
                    updateCameraFOV(fov, true);  // Compensate distance when using presets
                });
            });
        }

        function generateFilename(includeUI) {
            const now = new Date();
            const timestamp = now.toISOString().replace(/[:.]/g, '-').slice(0, 19);
            const pattern = state.pattern === 'allOn' ? 'all' :
                           state.pattern === 'grating' ? `grat${state.gratingPixels}` :
                           `sine${state.sineWavelength}`;
            const suffix = includeUI ? '_stats' : '';
            return `arena_${state.arena.generation}_${state.arena.num_cols}c${state.arena.num_rows}r_${pattern}${suffix}_${timestamp}.png`;
        }

        function takeScreenshot(includeUI) {
            renderer.render(scene, camera);
            const filename = generateFilename(includeUI);

            if (includeUI) {
                const canvasWidth = renderer.domElement.width;
                const canvasHeight = renderer.domElement.height;

                const finalCanvas = document.createElement('canvas');
                finalCanvas.width = canvasWidth;
                finalCanvas.height = canvasHeight;
                const ctx = finalCanvas.getContext('2d');

                ctx.drawImage(renderer.domElement, 0, 0);
                drawUIToCanvas(ctx, canvasWidth, canvasHeight);
                downloadCanvas(finalCanvas, filename);
            } else {
                downloadCanvas(renderer.domElement, filename);
            }
        }

        function drawUIToCanvas(ctx, canvasWidth, canvasHeight) {
            const padding = 16;
            const panelWidth = 260;
            const lineHeight = 22;

            // Left panel
            const leftPanelHeight = 220;
            ctx.fillStyle = 'rgba(26, 31, 38, 0.95)';
            ctx.fillRect(padding, padding, panelWidth, leftPanelHeight);
            ctx.strokeStyle = '#2d3640';
            ctx.lineWidth = 1;
            ctx.strokeRect(padding, padding, panelWidth, leftPanelHeight);

            ctx.font = 'bold 16px JetBrains Mono, monospace';
            ctx.fillStyle = '#00e676';
            ctx.fillText('Arena 3D Viewer', padding + 16, padding + 30);

            ctx.font = '13px IBM Plex Mono, monospace';
            const stats = [
                { label: 'Panel Type:', value: state.arena.generation, color: '#e6edf3' },
                { label: 'Columns:', value: state.arena.num_cols, color: '#e6edf3' },
                { label: 'Rows:', value: state.arena.num_rows, color: '#e6edf3' },
                { label: 'Pattern:', value: state.pattern, color: '#e6edf3' },
                { label: 'Total LEDs:', value: document.getElementById('total-leds').textContent, color: '#00e676' },
                { label: 'Azimuth:', value: document.getElementById('azimuth-res').textContent, color: '#e6edf3' },
                { label: 'Vertical:', value: document.getElementById('vertical-res').textContent, color: '#e6edf3' }
            ];

            let y = padding + 60;
            stats.forEach((stat) => {
                ctx.fillStyle = '#8b949e';
                ctx.fillText(stat.label, padding + 16, y);
                ctx.fillStyle = stat.color;
                ctx.fillText(stat.value, padding + 120, y);
                y += lineHeight;
            });

            // Right panel
            const rightPanelWidth = 200;
            const rightPanelHeight = 130;
            const rightX = canvasWidth - rightPanelWidth - padding;

            ctx.fillStyle = 'rgba(26, 31, 38, 0.95)';
            ctx.fillRect(rightX, padding, rightPanelWidth, rightPanelHeight);
            ctx.strokeRect(rightX, padding, rightPanelWidth, rightPanelHeight);

            ctx.font = 'bold 14px JetBrains Mono, monospace';
            ctx.fillStyle = '#00e676';
            ctx.fillText('Angular Resolution', rightX + 16, padding + 28);

            ctx.font = '13px IBM Plex Mono, monospace';
            ctx.fillStyle = '#8b949e';
            ctx.fillText('Azimuth:', rightX + 16, padding + 55);
            ctx.fillStyle = '#e6edf3';
            ctx.fillText(document.getElementById('azimuth-res').textContent, rightX + 100, padding + 55);

            ctx.fillStyle = '#8b949e';
            ctx.fillText('Vertical:', rightX + 16, padding + 77);
            ctx.fillStyle = '#e6edf3';
            ctx.fillText(document.getElementById('vertical-res').textContent, rightX + 100, padding + 77);

            ctx.fillStyle = '#8b949e';
            ctx.fillText('Pixels:', rightX + 16, padding + 105);
            ctx.fillStyle = '#00e676';
            ctx.fillText(`${document.getElementById('azimuth-pixels').textContent} × ${document.getElementById('vertical-pixels').textContent}`, rightX + 100, padding + 105);
        }

        function downloadCanvas(canvas, filename) {
            const link = document.createElement('a');
            link.download = filename;
            link.href = canvas.toDataURL('image/png');
            link.click();
        }

        // Recursively dispose of objects including CSS2D labels
        function disposeObject(obj) {
            if (obj.children) {
                while (obj.children.length > 0) {
                    disposeObject(obj.children[0]);
                    obj.remove(obj.children[0]);
                }
            }
            if (obj.geometry) obj.geometry.dispose();
            if (obj.material) {
                if (Array.isArray(obj.material)) {
                    obj.material.forEach(m => m.dispose());
                } else {
                    obj.material.dispose();
                }
            }
            // Clean up CSS2D label elements
            if (obj.element && obj.element.parentNode) {
                obj.element.parentNode.removeChild(obj.element);
            }
        }

        function buildArena() {
            // Clear existing arena (including labels)
            while (arenaGroup.children.length > 0) {
                disposeObject(arenaGroup.children[0]);
                arenaGroup.remove(arenaGroup.children[0]);
            }

            ledMeshes = [];

            const specs = PANEL_SPECS[state.arena.generation];
            const numCols = state.arena.num_cols;
            const numRows = state.arena.num_rows;
            const installedSet = getInstalledColumnsSet();

            // Convert mm to inches (working units)
            const panelWidth = specs.panel_width_mm / 25.4;
            const panelHeight = specs.panel_height_mm / 25.4;
            const panelDepth = specs.panel_depth_mm / 25.4;

            // Calculate radius
            const alpha = (2 * Math.PI) / numCols;
            const halfPanel = alpha / 2;  // Offset so c0 starts at boundary, not centered
            const cRadius = panelWidth / (Math.tan(alpha / 2)) / 2;
            const angleOffsetRad = (state.arena.angle_offset_deg * Math.PI) / 180;

            const columnHeight = panelHeight * numRows;

            // Place columns with proper CW/CCW ordering
            // CW: c0 just LEFT of south (looking from above), columns increase counter-clockwise
            // CCW: c0 just RIGHT of south, columns increase clockwise (mirror)
            // Note: Three.js uses right-handed coords but top-down view has +Z toward viewer,
            // so we negate Z to match MATLAB's top-down appearance
            for (let col = 0; col < numCols; col++) {
                if (!installedSet.has(col)) continue;

                let angle;
                if (state.arena.column_order === 'cw') {
                    // CW: start left of south, go counter-clockwise
                    angle = BASE_OFFSET_RAD - halfPanel - col * alpha + angleOffsetRad;
                } else {
                    // CCW: start right of south, go clockwise
                    angle = BASE_OFFSET_RAD + halfPanel + col * alpha + angleOffsetRad;
                }

                const x = cRadius * Math.cos(angle);
                const z = -cRadius * Math.sin(angle);  // Negate Z to match MATLAB top-down view

                const columnGroup = createColumnWithLEDs(specs, panelWidth, columnHeight, panelDepth, -angle, numRows, col, numCols);
                columnGroup.position.set(x, 0, z);

                arenaGroup.add(columnGroup);
            }

            updateMetrics(specs, numCols, numRows, cRadius, columnHeight);
        }

        function updateLabels() {
            // Labels are now added directly to column groups in buildArena
            // This function is kept for compatibility but labels are rebuilt with arena
        }

        function createLabel(text, color, fontWeight) {
            const div = document.createElement('div');
            div.className = 'arena-label';
            div.textContent = text;
            div.style.color = color;
            div.style.fontFamily = "'JetBrains Mono', monospace";
            div.style.fontSize = '14px';
            div.style.fontWeight = fontWeight;
            div.style.padding = '2px 6px';
            div.style.background = 'rgba(15, 20, 25, 0.85)';
            div.style.borderRadius = '4px';
            div.style.border = `1px solid ${color}`;
            div.style.whiteSpace = 'nowrap';

            const label = new CSS2DObject(div);
            return label;
        }

        function getLEDBrightness(px, py, colIndex, numCols, totalPixelsH) {
            const totalAzimuthPixels = numCols * totalPixelsH;
            // For CCW mode, mirror the pixel index within each panel
            // to ensure grating tiles correctly when columns are placed clockwise
            const effectivePx = (state.arena && state.arena.column_order === 'ccw')
                ? (totalPixelsH - 1 - px)
                : px;
            const globalPixelX = ((colIndex * totalPixelsH + effectivePx) + state.phaseOffset + totalAzimuthPixels) % totalAzimuthPixels;

            if (state.pattern === 'custom' && state.customPattern) {
                // Custom pattern from .pat file
                return getCustomPatternBrightness(px, py, colIndex);
            } else if (state.pattern === 'allOn') {
                return 1.0;
            } else if (state.pattern === 'grating') {
                const period = state.gratingPixels * 2;
                const phase = globalPixelX % period;
                return phase < state.gratingPixels ? 1.0 : 0.0;
            } else if (state.pattern === 'sine') {
                const wavelengthPixels = state.sineWavelength;
                const phase = (globalPixelX / wavelengthPixels) * 2 * Math.PI;
                const normalized = (Math.sin(phase) + 1) / 2;
                const level = Math.round(normalized * (GRAYSCALE_LEVELS - 1));
                return level / (GRAYSCALE_LEVELS - 1);
            }
            return 1.0;
        }

        // Get brightness from custom loaded pattern
        function getCustomPatternBrightness(px, py, colIndex) {
            const pat = state.customPattern;
            if (!pat || !pat.frames || pat.frames.length === 0) {
                return 1.0;
            }

            const frame = pat.frames[state.currentFrame];
            if (!frame) {
                return 1.0;
            }

            // Get panel pixel size (panelSize from parser)
            const pixelsPerPanel = pat.panelSize;

            // Calculate which row of panels this py falls into
            const panelRow = Math.floor(py / pixelsPerPanel);
            const localPy = py % pixelsPerPanel;

            // Global pixel coordinates
            // px is local to the panel (0 to pixelsPerPanel-1)
            // colIndex is the column index
            // Pattern data is stored row-major: row 0 = bottom, higher rows go up
            // globalX = col * pixelsPerPanel + px
            // globalY = panelRow * pixelsPerPanel + localPy

            const globalX = colIndex * pixelsPerPanel + px;
            const globalY = panelRow * pixelsPerPanel + localPy;

            // Index into flattened frame array (row-major)
            const pixelIndex = globalY * pat.pixelCols + globalX;

            if (pixelIndex < 0 || pixelIndex >= frame.length) {
                return 0.0;  // Out of bounds
            }

            const value = frame[pixelIndex];

            // Normalize based on grayscale mode
            const maxValue = pat.gs_val === 2 ? 1 : 15;
            return value / maxValue;
        }

        function brightnessToColor(brightness) {
            const green = Math.floor(0xe6 * brightness);
            return (green << 8);
        }

        function createColumnWithLEDs(specs, width, height, depth, angle, numRows, colIndex, numCols) {
            const group = new THREE.Group();

            group.rotation.y = -angle - Math.PI / 2;

            // Column background
            const columnGeom = new THREE.BoxGeometry(width, height, depth * 0.1);
            const columnMat = new THREE.MeshLambertMaterial({ color: 0x111111 });
            const column = new THREE.Mesh(columnGeom, columnMat);
            group.add(column);

            // Border
            const borderMat = new THREE.LineBasicMaterial({ color: 0xffffff, linewidth: 2 });
            const halfW = width / 2;
            const halfH = height / 2;
            const panelThickness = depth * 0.05;

            const borderOffsets = [panelThickness, -panelThickness];

            for (const borderZ of borderOffsets) {
                const borderGeom = new THREE.BufferGeometry();
                const borderVertices = new Float32Array([
                    -halfW, -halfH, borderZ,
                     halfW, -halfH, borderZ,
                     halfW, -halfH, borderZ,
                     halfW,  halfH, borderZ,
                     halfW,  halfH, borderZ,
                    -halfW,  halfH, borderZ,
                    -halfW,  halfH, borderZ,
                    -halfW, -halfH, borderZ
                ]);
                borderGeom.setAttribute('position', new THREE.Float32BufferAttribute(borderVertices, 3));
                const border = new THREE.LineSegments(borderGeom, borderMat);
                group.add(border);

                if (numRows > 1) {
                    const panelH = height / numRows;
                    for (let r = 1; r < numRows; r++) {
                        const lineY = -halfH + r * panelH;
                        const lineGeom = new THREE.BufferGeometry();
                        const lineVerts = new Float32Array([
                            -halfW, lineY, borderZ,
                             halfW, lineY, borderZ
                        ]);
                        lineGeom.setAttribute('position', new THREE.Float32BufferAttribute(lineVerts, 3));
                        const line = new THREE.Line(lineGeom, borderMat);
                        group.add(line);
                    }
                }
            }

            // LEDs - use accurate dimensions from specs
            const totalPixelsV = specs.pixels_per_panel * numRows;
            const totalPixelsH = specs.pixels_per_panel;

            const ledSpacingX = width / totalPixelsH;
            const ledSpacingY = height / totalPixelsV;

            // Use actual LED dimensions from specs (convert mm to inches)
            const isRectLED = specs.led_type === 'rect';
            let ledW, ledH, ledRadius;

            if (isRectLED) {
                // Rectangular SMD LEDs (G4.1, G6) - mounted at 45°
                ledW = (specs.led_width_mm || 1.0) / 25.4;
                ledH = (specs.led_height_mm || 0.5) / 25.4;
            } else {
                // Round LEDs (G3, G4)
                ledRadius = (specs.led_diameter_mm || 2.0) / 25.4 / 2;
            }

            for (let py = 0; py < totalPixelsV; py++) {
                for (let px = 0; px < totalPixelsH; px++) {
                    const brightness = getLEDBrightness(px, py, colIndex, numCols, totalPixelsH);

                    const localX = -halfW + ledSpacingX / 2 + px * ledSpacingX;
                    const localY = -halfH + ledSpacingY / 2 + py * ledSpacingY;
                    const localZ = panelThickness + 0.001;

                    if (isRectLED) {
                        // Rectangular LED rotated 45°
                        const rectW = ledW / 2;
                        const rectH = ledH / 2;

                        const cos45 = Math.SQRT1_2;
                        const sin45 = Math.SQRT1_2;

                        const c1x = (-rectW) * cos45 - (-rectH) * sin45;
                        const c1y = (-rectW) * sin45 + (-rectH) * cos45;
                        const c2x = (rectW) * cos45 - (-rectH) * sin45;
                        const c2y = (rectW) * sin45 + (-rectH) * cos45;
                        const c3x = (rectW) * cos45 - (rectH) * sin45;
                        const c3y = (rectW) * sin45 + (rectH) * cos45;
                        const c4x = (-rectW) * cos45 - (rectH) * sin45;
                        const c4y = (-rectW) * sin45 + (rectH) * cos45;

                        const rectShape = new THREE.Shape();
                        rectShape.moveTo(c1x, c1y);
                        rectShape.lineTo(c2x, c2y);
                        rectShape.lineTo(c3x, c3y);
                        rectShape.lineTo(c4x, c4y);
                        rectShape.lineTo(c1x, c1y);

                        const rectGeom = new THREE.ShapeGeometry(rectShape);
                        const ledColor = brightnessToColor(brightness);
                        const rectMat = new THREE.MeshBasicMaterial({ color: ledColor });
                        const rect = new THREE.Mesh(rectGeom, rectMat);
                        rect.position.set(localX, localY, localZ);
                        group.add(rect);

                        ledMeshes.push({
                            mesh: rect,
                            colIndex: colIndex,
                            px: px,
                            py: py,
                            totalPixelsH: totalPixelsH,
                            numCols: numCols
                        });

                        const outlineGeom = new THREE.BufferGeometry();
                        const outlineVerts = new Float32Array([
                            c1x, c1y, 0,
                            c2x, c2y, 0,
                            c2x, c2y, 0,
                            c3x, c3y, 0,
                            c3x, c3y, 0,
                            c4x, c4y, 0,
                            c4x, c4y, 0,
                            c1x, c1y, 0
                        ]);
                        outlineGeom.setAttribute('position', new THREE.Float32BufferAttribute(outlineVerts, 3));
                        const outlineMat = new THREE.LineBasicMaterial({ color: 0x333333 });
                        const outline = new THREE.LineSegments(outlineGeom, outlineMat);
                        outline.position.set(localX, localY, localZ + 0.0001);
                        group.add(outline);
                    } else {
                        // Round LED
                        const ledGeom = new THREE.CircleGeometry(ledRadius, 16);
                        const ledColor = brightnessToColor(brightness);
                        const ledMat = new THREE.MeshBasicMaterial({ color: ledColor });
                        const led = new THREE.Mesh(ledGeom, ledMat);
                        led.position.set(localX, localY, localZ);
                        group.add(led);

                        ledMeshes.push({
                            mesh: led,
                            colIndex: colIndex,
                            px: px,
                            py: py,
                            totalPixelsH: totalPixelsH,
                            numCols: numCols
                        });

                        const circlePoints = [];
                        const segments = 16;
                        for (let i = 0; i <= segments; i++) {
                            const theta = (i / segments) * Math.PI * 2;
                            circlePoints.push(new THREE.Vector3(
                                Math.cos(theta) * ledRadius,
                                Math.sin(theta) * ledRadius,
                                0
                            ));
                        }
                        const circleGeom = new THREE.BufferGeometry().setFromPoints(circlePoints);
                        const circleMat = new THREE.LineBasicMaterial({ color: 0x333333 });
                        const circle = new THREE.Line(circleGeom, circleMat);
                        circle.position.set(localX, localY, localZ + 0.0001);
                        group.add(circle);
                    }
                }
            }

            // Add panel labels on back side (if enabled)
            if (state.showPanelLabels) {
                const panelH = height / numRows;
                for (let row = 0; row < numRows; row++) {
                    const panelNumber = colIndex * numRows + row;
                    const panelLabel = createLabel(panelNumber.toString(), '#ffff00', 'normal');
                    // Position on back side of panel, centered
                    panelLabel.position.set(0, -halfH + row * panelH + panelH / 2, -panelThickness - 0.01);
                    group.add(panelLabel);
                }
            }

            // Add column label on ground (if enabled)
            if (state.showColumnLabels) {
                const colLabel = createLabel(`c${colIndex}`, '#00897b', 'bold');
                // Position on ground, slightly outside the column
                colLabel.position.set(0, -halfH - 0.1, -panelThickness - 0.05);
                group.add(colLabel);
            }

            return group;
        }

        function updateLEDColors() {
            for (const ledRef of ledMeshes) {
                const brightness = getLEDBrightness(
                    ledRef.px, ledRef.py, ledRef.colIndex,
                    ledRef.numCols, ledRef.totalPixelsH
                );
                const newColor = brightnessToColor(brightness);
                ledRef.mesh.material.color.setHex(newColor);
            }
        }

        function updateMetrics(specs, numCols, numRows, cRadius, arenaHeight) {
            const installedCols = getInstalledColumnCount();
            const totalPanels = installedCols * numRows;
            const totalLEDs = totalPanels * specs.pixels_per_panel * specs.pixels_per_panel;

            const azimuthRes = 360 / (numCols * specs.pixels_per_panel);

            const panelHeight = specs.panel_height_mm / 25.4;
            const halfAngleRad = Math.atan((arenaHeight / 2) / cRadius);
            const totalVerticalDegrees = 2 * halfAngleRad * (180 / Math.PI);
            const verticalRes = totalVerticalDegrees / (numRows * specs.pixels_per_panel);

            const azimuthPixels = numCols * specs.pixels_per_panel;
            const verticalPixels = numRows * specs.pixels_per_panel;

            // Display in mm
            const radiusMM = cRadius * 25.4;
            const heightMM = arenaHeight * 25.4;

            document.getElementById('num-cols-display').textContent = installedCols;
            document.getElementById('total-panels').textContent = totalPanels;
            document.getElementById('inner-radius').textContent = radiusMM.toFixed(1) + ' mm';
            document.getElementById('arena-height').textContent = heightMM.toFixed(1) + ' mm';
            document.getElementById('total-leds').textContent = totalLEDs.toLocaleString();
            document.getElementById('azimuth-res').textContent = azimuthRes.toFixed(2) + '°/px';
            document.getElementById('vertical-res').textContent = verticalRes.toFixed(2) + '°/px';
            document.getElementById('azimuth-pixels').textContent = azimuthPixels;
            document.getElementById('vertical-pixels').textContent = verticalPixels;
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            labelRenderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate(currentTime) {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
            labelRenderer.render(scene, camera);
        }

        // Expose test function for debugging (can load pattern from URL)
        window.testLoadPattern = async function(url) {
            try {
                const response = await fetch(url);
                const buffer = await response.arrayBuffer();
                const patternData = parsePatFile(buffer);

                // Run verification
                const checks = verifyPatternOrientation(patternData);
                const allPassed = checks.every(c => c.pass);
                if (!allPassed) {
                    console.warn('Pattern orientation verification found issues');
                }

                // Store pattern data
                state.customPattern = patternData;
                state.currentFrame = 0;
                state.pattern = 'custom';

                // Auto-detect matching arena config
                const matchingConfig = findMatchingConfig(patternData, STANDARD_CONFIGS);
                if (matchingConfig) {
                    console.log(`Auto-detected arena config: ${matchingConfig}`);
                    loadStandardConfig(matchingConfig);
                } else {
                    state.arena.generation = patternData.generation;
                    state.arena.num_rows = patternData.rowCount;
                    state.arena.num_cols = patternData.colCount;
                    updateConfigInfo();
                    buildArenaWithLoading();
                }

                // Update UI
                const filename = url.split('/').pop();
                updatePatternInfoDisplay(filename, patternData);
                updateFrameControls();

                // Deselect built-in patterns
                document.querySelectorAll('.pattern-btn').forEach(r => r.classList.remove('active'));
                document.getElementById('grating-controls').style.display = 'none';
                document.getElementById('sine-controls').style.display = 'none';

                return { success: true, pattern: patternData };
            } catch (e) {
                console.error('Error loading pattern:', e);
                return { success: false, error: e.message };
            }
        };

        // Start
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', init);
        } else {
            init();
        }
    </script>
</body>
</html>
