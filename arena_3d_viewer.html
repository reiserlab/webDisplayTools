<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Arena 3D Viewer - PanelDisplayTools</title>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700&family=IBM+Plex+Mono:wght@400;600&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        :root {
            --bg: #0f1419;
            --surface: #1a1f26;
            --border: #2d3640;
            --text: #e6edf3;
            --text-dim: #8b949e;
            --accent: #00e676;
            --hover: #00c853;
        }

        body {
            font-family: 'IBM Plex Mono', monospace;
            background: var(--bg);
            color: var(--text);
            overflow: hidden;
        }

        /* Controls Panel */
        .controls-panel {
            position: fixed;
            top: 1rem;
            left: 1rem;
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 1.25rem;
            width: 280px;
            z-index: 100;
            max-height: calc(100vh - 2rem);
            overflow-y: auto;
        }

        .controls-panel h1 {
            font-family: 'JetBrains Mono', monospace;
            font-size: 1.1rem;
            color: var(--accent);
            margin-bottom: 0.5rem;
        }

        .controls-panel .subtitle {
            font-size: 0.75rem;
            color: var(--text-dim);
            margin-bottom: 1rem;
            padding-bottom: 0.75rem;
            border-bottom: 1px solid var(--border);
        }

        .control-group {
            margin-bottom: 1rem;
        }

        .control-group label {
            display: block;
            font-size: 0.75rem;
            color: var(--text-dim);
            margin-bottom: 0.3rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        /* Generation Tabs */
        .gen-tabs {
            display: flex;
            gap: 0.3rem;
            flex-wrap: wrap;
        }

        .gen-tab {
            padding: 0.4rem 0.7rem;
            background: var(--bg);
            border: 1px solid var(--border);
            border-radius: 4px;
            color: var(--text-dim);
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.75rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .gen-tab:hover {
            border-color: var(--accent);
            color: var(--text);
        }

        .gen-tab.active {
            background: var(--accent);
            border-color: var(--accent);
            color: var(--bg);
            font-weight: 700;
        }

        /* Number Input */
        .number-input {
            display: flex;
            align-items: center;
            gap: 0.4rem;
        }

        .number-input button {
            width: 32px;
            height: 32px;
            background: var(--bg);
            border: 1px solid var(--border);
            border-radius: 4px;
            color: var(--text);
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .number-input button:hover {
            border-color: var(--accent);
            color: var(--accent);
        }

        .number-input input {
            width: 50px;
            height: 32px;
            background: var(--bg);
            border: 1px solid var(--border);
            border-radius: 4px;
            color: var(--text);
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.9rem;
            text-align: center;
        }

        .number-input span {
            font-size: 0.8rem;
            color: var(--text-dim);
            margin-left: 0.3rem;
        }

        /* Metrics */
        .metric {
            display: flex;
            justify-content: space-between;
            padding: 0.4rem 0;
            border-bottom: 1px solid var(--border);
            font-size: 0.8rem;
        }

        .metric:last-child { border-bottom: none; }
        .metric .label { color: var(--text-dim); }
        .metric .value {
            color: var(--text);
            font-family: 'JetBrains Mono', monospace;
        }

        /* Buttons */
        .btn {
            width: 100%;
            padding: 0.6rem;
            background: var(--accent);
            border: none;
            border-radius: 6px;
            color: var(--bg);
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.85rem;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.2s;
            margin-top: 0.5rem;
        }

        .btn:hover {
            background: var(--hover);
            transform: translateY(-1px);
        }

        .btn.secondary {
            background: var(--surface);
            border: 1px solid var(--accent);
            color: var(--accent);
        }

        .btn.secondary:hover {
            background: rgba(0, 230, 118, 0.1);
        }

        /* 3D Canvas */
        #canvas-container {
            width: 100vw;
            height: 100vh;
        }

        /* Help Panel */
        .help-panel {
            position: fixed;
            bottom: 1rem;
            left: 1rem;
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 0.75rem 1rem;
            font-size: 0.7rem;
            color: var(--text-dim);
            z-index: 100;
        }

        .help-panel strong { color: var(--text); }

        /* Navigation */
        .nav-link {
            display: inline-block;
            color: var(--text-dim);
            text-decoration: none;
            margin-bottom: 0.75rem;
            font-size: 0.8rem;
            transition: color 0.2s;
        }

        .nav-link:hover { color: var(--accent); }

        /* Info overlay */
        .info-overlay {
            position: fixed;
            top: 1rem;
            right: 1rem;
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 1rem;
            z-index: 100;
            font-size: 0.8rem;
        }

        .info-overlay h3 {
            font-family: 'JetBrains Mono', monospace;
            color: var(--accent);
            font-size: 0.9rem;
            margin-bottom: 0.5rem;
        }

        .resolution-display {
            font-family: 'JetBrains Mono', monospace;
            font-size: 1.2rem;
            font-weight: 700;
            color: var(--accent);
            text-align: center;
            padding: 0.5rem;
            background: rgba(0, 230, 118, 0.1);
            border-radius: 4px;
            margin-bottom: 0.5rem;
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>

    <!-- Controls Panel -->
    <div class="controls-panel">
        <a href="arena_editor.html" class="nav-link">← Back to 2D Editor</a>
        <h1>Arena 3D Viewer</h1>
        <p class="subtitle">Configure cylindrical arena with LED panels</p>

        <div class="control-group">
            <label>Panel Generation</label>
            <div class="gen-tabs">
                <button class="gen-tab" data-gen="G3">G3</button>
                <button class="gen-tab" data-gen="G4">G4</button>
                <button class="gen-tab" data-gen="G4.1">G4.1</button>
                <button class="gen-tab" data-gen="G5">G5</button>
                <button class="gen-tab active" data-gen="G6">G6</button>
            </div>
        </div>

        <div class="control-group">
            <label>Panel Rows (Height)</label>
            <div class="number-input">
                <button id="rows-dec">−</button>
                <input type="number" id="num-rows" value="3" min="1" max="8">
                <button id="rows-inc">+</button>
            </div>
        </div>

        <div class="control-group">
            <label>Arena Statistics</label>
            <div class="metric">
                <span class="label">Columns</span>
                <span class="value" id="num-cols-display">12</span>
            </div>
            <div class="metric">
                <span class="label">Total Panels</span>
                <span class="value" id="total-panels">36</span>
            </div>
            <div class="metric">
                <span class="label">Inner Radius</span>
                <span class="value" id="inner-radius">3.52 in</span>
            </div>
            <div class="metric">
                <span class="label">Arena Height</span>
                <span class="value" id="arena-height">5.36 in</span>
            </div>
            <div class="metric">
                <span class="label">Total LEDs</span>
                <span class="value" id="total-leds">14,400</span>
            </div>
        </div>

        <div class="control-group" style="border-top: 1px solid var(--border); padding-top: 1rem; margin-top: 0.5rem;">
            <label>Pattern</label>
            <button class="btn" id="pattern-all-on" style="margin-top: 0.3rem;">All On</button>
            <div class="number-input" style="margin-top: 0.5rem;">
                <span style="font-size: 0.75rem; color: var(--text-dim); min-width: 50px;">Grating</span>
                <button id="grating-dec">−</button>
                <input type="number" id="grating-cols" value="2" min="1" max="20" style="width: 40px;">
                <button id="grating-inc">+</button>
                <span style="font-size: 0.7rem; color: var(--text-dim);">cols</span>
            </div>
            <div class="number-input" style="margin-top: 0.5rem;">
                <span style="font-size: 0.75rem; color: var(--text-dim); min-width: 50px;">Sine</span>
                <button id="sine-dec">−</button>
                <input type="number" id="sine-wavelength" value="4" min="2" max="40" style="width: 40px;">
                <button id="sine-inc">+</button>
                <span style="font-size: 0.7rem; color: var(--text-dim);">λ cols</span>
            </div>
        </div>

        <button class="btn" id="reset-view" style="margin-top: 1rem;">Reset Camera View</button>
        <button class="btn" id="fly-view">Fly View (From Center)</button>
        <button class="btn secondary" id="toggle-rotation">Toggle Auto-Rotate</button>
    </div>

    <!-- Info Overlay -->
    <div class="info-overlay">
        <h3>Avg Angular Resolution</h3>
        <div class="metric">
            <span class="label">Azimuth</span>
            <span class="value" id="azimuth-res">1.50°/px</span>
        </div>
        <div class="metric">
            <span class="label">Vertical</span>
            <span class="value" id="vertical-res">2.50°/px</span>
        </div>
        <div class="metric" style="margin-top: 0.5rem; padding-top: 0.5rem; border-top: 1px solid var(--border);">
            <span class="label">Azimuth px</span>
            <span class="value" id="azimuth-pixels">240</span>
        </div>
        <div class="metric">
            <span class="label">Vertical px</span>
            <span class="value" id="vertical-pixels">60</span>
        </div>
    </div>

    <!-- Help Panel -->
    <div class="help-panel">
        <strong>Controls:</strong> Drag to rotate | Scroll to zoom | Right-drag to pan
    </div>

    <script>
        // Panel specifications (same as arena_editor.html)
        const PANEL_SPECS = {
            'G3': {
                panel_width_mm: 32,
                panel_height_mm: 32,
                panel_depth_mm: 18,
                pixels_horizontal: 8,
                pixels_vertical: 8
            },
            'G4': {
                panel_width_mm: 40.45,
                panel_height_mm: 40.45,
                panel_depth_mm: 18,
                pixels_horizontal: 16,
                pixels_vertical: 16
            },
            'G4.1': {
                panel_width_mm: 40,
                panel_height_mm: 40,
                panel_depth_mm: 6.35,
                pixels_horizontal: 16,
                pixels_vertical: 16
            },
            'G5': {
                panel_width_mm: 40,
                panel_height_mm: 40,
                panel_depth_mm: 6.35,
                pixels_horizontal: 20,
                pixels_vertical: 20
            },
            'G6': {
                panel_width_mm: 45.4,
                panel_height_mm: 45.4,
                panel_depth_mm: 3.45,
                pixels_horizontal: 20,
                pixels_vertical: 20
            }
        };

        // State
        let state = {
            panelType: 'G6',
            numCols: 12,  // panels around (from 2D editor, not editable here)
            numRows: 3,   // panels vertically (default 3)
            activePanels: null,  // array of active column indices, null = all active
            pattern: 'allOn',    // 'allOn', 'grating', 'sine'
            gratingCols: 2,      // columns on/off for grating
            sineWavelength: 4    // wavelength in columns for sine
        };

        // 16 grayscale levels (matching panel pattern editor)
        const GRAYSCALE_LEVELS = 16;

        // Parse URL parameters (from 2D editor)
        function parseUrlParams() {
            const params = new URLSearchParams(window.location.search);
            if (params.has('gen')) state.panelType = params.get('gen');
            if (params.has('cols')) state.numCols = parseInt(params.get('cols'));
            if (params.has('rows')) state.numRows = parseInt(params.get('rows'));
            if (params.has('active')) {
                // active is comma-separated list of column indices (0-based)
                const activeStr = params.get('active');
                if (activeStr) {
                    state.activePanels = activeStr.split(',').map(n => parseInt(n));
                }
            }
        }

        // Three.js objects
        let scene, camera, renderer, controls;
        let arenaGroup;
        let autoRotate = false;

        // Initialize
        function init() {
            const container = document.getElementById('canvas-container');

            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0f1419);

            // Camera - default to top-down view
            camera = new THREE.PerspectiveCamera(
                60,
                window.innerWidth / window.innerHeight,
                0.1,
                1000
            );
            // Will be positioned after arena is built to fit the view

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            container.appendChild(renderer.domElement);

            // Controls
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.minDistance = 0.1; // Allow getting close to center for fly view
            controls.maxDistance = 50;

            // Lighting
            const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.3);
            directionalLight.position.set(5, 10, 5);
            scene.add(directionalLight);

            // Grid helper (floor reference)
            const gridHelper = new THREE.GridHelper(20, 20, 0x2d3640, 0x1a1f26);
            gridHelper.position.y = -5;
            scene.add(gridHelper);

            // Arena group
            arenaGroup = new THREE.Group();
            scene.add(arenaGroup);

            // Parse URL params and update UI
            parseUrlParams();
            updateUIFromState();

            // Build initial arena
            buildArena();

            // Set initial camera to top-down view, zoomed to fit
            setTopDownView();

            // Event listeners
            setupEventListeners();

            // Start animation
            animate();
        }

        function updateUIFromState() {
            // Update generation tabs
            document.querySelectorAll('.gen-tab').forEach(t => t.classList.remove('active'));
            const activeTab = document.querySelector(`.gen-tab[data-gen="${state.panelType}"]`);
            if (activeTab) activeTab.classList.add('active');

            // Update number inputs (rows only, cols is read-only from 2D editor)
            document.getElementById('num-rows').value = state.numRows;
            document.getElementById('grating-cols').value = state.gratingCols;
            document.getElementById('sine-wavelength').value = state.sineWavelength;
        }

        function setTopDownView() {
            // Calculate arena radius for zoom
            const specs = PANEL_SPECS[state.panelType];
            const panelWidth = specs.panel_width_mm / 25.4;
            const alpha = (2 * Math.PI) / state.numCols;
            const cRadius = panelWidth / (Math.tan(alpha / 2)) / 2;

            // Position camera directly above, looking down
            const viewHeight = cRadius * 2.5; // enough to see the whole arena
            camera.position.set(0, viewHeight, 0.01); // tiny Z offset to avoid gimbal lock
            controls.target.set(0, 0, 0);
            controls.update();
        }

        function setupEventListeners() {
            // Generation tabs (change panel type, but numCols comes from 2D editor)
            document.querySelectorAll('.gen-tab').forEach(tab => {
                tab.addEventListener('click', () => {
                    document.querySelectorAll('.gen-tab').forEach(t => t.classList.remove('active'));
                    tab.classList.add('active');
                    state.panelType = tab.dataset.gen;
                    buildArena();
                });
            });

            // Row controls (columns are fixed from 2D editor)
            const numRowsInput = document.getElementById('num-rows');
            document.getElementById('rows-dec').addEventListener('click', () => {
                if (state.numRows > 1) {
                    state.numRows--;
                    numRowsInput.value = state.numRows;
                    buildArena();
                }
            });
            document.getElementById('rows-inc').addEventListener('click', () => {
                if (state.numRows < 8) {
                    state.numRows++;
                    numRowsInput.value = state.numRows;
                    buildArena();
                }
            });
            numRowsInput.addEventListener('change', () => {
                const val = parseInt(numRowsInput.value);
                if (val >= 1 && val <= 8) {
                    state.numRows = val;
                    buildArena();
                } else {
                    numRowsInput.value = state.numRows;
                }
            });

            // Pattern controls
            document.getElementById('pattern-all-on').addEventListener('click', () => {
                state.pattern = 'allOn';
                buildArena();
            });

            // Grating controls
            const gratingInput = document.getElementById('grating-cols');
            document.getElementById('grating-dec').addEventListener('click', () => {
                if (state.gratingCols > 1) {
                    state.gratingCols--;
                    gratingInput.value = state.gratingCols;
                    state.pattern = 'grating';
                    buildArena();
                }
            });
            document.getElementById('grating-inc').addEventListener('click', () => {
                if (state.gratingCols < 20) {
                    state.gratingCols++;
                    gratingInput.value = state.gratingCols;
                    state.pattern = 'grating';
                    buildArena();
                }
            });
            gratingInput.addEventListener('change', () => {
                const val = parseInt(gratingInput.value);
                if (val >= 1 && val <= 20) {
                    state.gratingCols = val;
                    state.pattern = 'grating';
                    buildArena();
                } else {
                    gratingInput.value = state.gratingCols;
                }
            });

            // Sine wave controls
            const sineInput = document.getElementById('sine-wavelength');
            document.getElementById('sine-dec').addEventListener('click', () => {
                if (state.sineWavelength > 2) {
                    state.sineWavelength--;
                    sineInput.value = state.sineWavelength;
                    state.pattern = 'sine';
                    buildArena();
                }
            });
            document.getElementById('sine-inc').addEventListener('click', () => {
                if (state.sineWavelength < 40) {
                    state.sineWavelength++;
                    sineInput.value = state.sineWavelength;
                    state.pattern = 'sine';
                    buildArena();
                }
            });
            sineInput.addEventListener('change', () => {
                const val = parseInt(sineInput.value);
                if (val >= 2 && val <= 40) {
                    state.sineWavelength = val;
                    state.pattern = 'sine';
                    buildArena();
                } else {
                    sineInput.value = state.sineWavelength;
                }
            });

            // Camera reset
            document.getElementById('reset-view').addEventListener('click', () => {
                camera.position.set(0, 5, 12);
                controls.target.set(0, 0, 0);
                controls.update();
            });

            // Fly view - camera at center looking outward
            document.getElementById('fly-view').addEventListener('click', () => {
                // Position camera at center of arena, slightly elevated
                camera.position.set(0, 0, 0);
                // Look outward toward a panel (along positive Z)
                controls.target.set(0, 0, 5);
                controls.update();
            });

            // Auto-rotate toggle
            document.getElementById('toggle-rotation').addEventListener('click', () => {
                autoRotate = !autoRotate;
                controls.autoRotate = autoRotate;
            });

            // Window resize
            window.addEventListener('resize', onWindowResize);
        }

        function buildArena() {
            // Clear existing arena
            while (arenaGroup.children.length > 0) {
                const child = arenaGroup.children[0];
                if (child.geometry) child.geometry.dispose();
                if (child.material) {
                    if (Array.isArray(child.material)) {
                        child.material.forEach(m => m.dispose());
                    } else {
                        child.material.dispose();
                    }
                }
                arenaGroup.remove(child);
            }

            const specs = PANEL_SPECS[state.panelType];
            const numCols = state.numCols;
            const numRows = state.numRows;

            // Convert mm to inches (working units)
            const panelWidth = specs.panel_width_mm / 25.4;  // width of one panel
            const panelHeight = specs.panel_height_mm / 25.4; // height of one panel (square)
            const panelDepth = specs.panel_depth_mm / 25.4;

            // Calculate radius based on panel width
            const alpha = (2 * Math.PI) / numCols;
            const cRadius = panelWidth / (Math.tan(alpha / 2)) / 2;

            // Total column height = panel height × number of rows
            const columnHeight = panelHeight * numRows;

            // Create one column (rectangle) per active position around the arena
            // If activePanels is null, all columns are active
            const activeCount = state.activePanels ? state.activePanels.length : numCols;

            for (let col = 0; col < numCols; col++) {
                // Skip inactive columns
                if (state.activePanels && !state.activePanels.includes(col)) {
                    continue;
                }

                const angle = col * alpha;

                // Column position at radius
                const x = cRadius * Math.cos(angle);
                const z = cRadius * Math.sin(angle);

                // Create column with all LEDs (rectangle: panelWidth × columnHeight)
                // Pass column index for pattern calculation
                const columnGroup = createColumnWithLEDs(specs, panelWidth, columnHeight, panelDepth, angle, numRows, col, numCols);
                columnGroup.position.set(x, 0, z);

                arenaGroup.add(columnGroup);
            }

            // Update metrics
            updateMetrics(specs, numCols, numRows, cRadius, columnHeight);
        }

        // Calculate LED brightness based on pattern
        function getLEDBrightness(px, py, colIndex, numCols, totalPixelsH) {
            // Global pixel X position across the entire arena
            const globalPixelX = colIndex * totalPixelsH + px;
            const totalAzimuthPixels = numCols * totalPixelsH;

            if (state.pattern === 'allOn') {
                return 1.0; // Full brightness
            } else if (state.pattern === 'grating') {
                // Square wave grating: gratingCols pixels on, gratingCols pixels off
                const period = state.gratingCols * 2;
                const phase = globalPixelX % period;
                return phase < state.gratingCols ? 1.0 : 0.0;
            } else if (state.pattern === 'sine') {
                // Sine wave: wavelength in columns (convert to pixels)
                const wavelengthPixels = state.sineWavelength * totalPixelsH;
                const phase = (globalPixelX / wavelengthPixels) * 2 * Math.PI;
                // Map sine [-1, 1] to [0, 1], then quantize to 16 levels
                const normalized = (Math.sin(phase) + 1) / 2;
                const quantized = Math.floor(normalized * (GRAYSCALE_LEVELS - 1)) / (GRAYSCALE_LEVELS - 1);
                return quantized;
            }
            return 1.0;
        }

        function createColumnWithLEDs(specs, width, height, depth, angle, numRows, colIndex, numCols) {
            const group = new THREE.Group();

            // Rotate entire group so the column face points toward center
            // angle=0 means column is at +X axis, needs to face -X (toward center)
            group.rotation.y = -angle - Math.PI / 2;

            // Column background (black rectangle) - thin box
            // width = panel width, height = total column height (panels stacked)
            const columnGeom = new THREE.BoxGeometry(width, height, depth * 0.1);
            const columnMat = new THREE.MeshLambertMaterial({ color: 0x111111 });
            const column = new THREE.Mesh(columnGeom, columnMat);
            group.add(column);

            // Border material - white, thicker lines
            const borderMat = new THREE.LineBasicMaterial({ color: 0xffffff, linewidth: 2 });
            const halfW = width / 2;
            const halfH = height / 2;
            const panelThickness = depth * 0.05;

            // Create borders on BOTH sides (front +Z and back -Z)
            const borderOffsets = [panelThickness, -panelThickness];

            for (const borderZ of borderOffsets) {
                // Outer rectangle border
                const borderGeom = new THREE.BufferGeometry();
                const borderVertices = new Float32Array([
                    -halfW, -halfH, borderZ,
                     halfW, -halfH, borderZ,
                     halfW, -halfH, borderZ,
                     halfW,  halfH, borderZ,
                     halfW,  halfH, borderZ,
                    -halfW,  halfH, borderZ,
                    -halfW,  halfH, borderZ,
                    -halfW, -halfH, borderZ
                ]);
                borderGeom.setAttribute('position', new THREE.BufferAttribute(borderVertices, 3));
                const border = new THREE.LineSegments(borderGeom, borderMat);
                group.add(border);

                // Horizontal lines between panel rows (if multiple rows)
                if (numRows > 1) {
                    const panelH = height / numRows;
                    for (let r = 1; r < numRows; r++) {
                        const lineY = -halfH + r * panelH;
                        const lineGeom = new THREE.BufferGeometry();
                        const lineVerts = new Float32Array([
                            -halfW, lineY, borderZ,
                             halfW, lineY, borderZ
                        ]);
                        lineGeom.setAttribute('position', new THREE.BufferAttribute(lineVerts, 3));
                        const line = new THREE.Line(lineGeom, borderMat);
                        group.add(line);
                    }
                }
            }

            // LED dots on the inner face (+Z side, facing center)
            // LEDs should be evenly spaced with half-spacing inset from edges
            // This creates a regular grid that would tile continuously
            const totalPixelsV = specs.pixels_vertical * numRows;
            const totalPixelsH = specs.pixels_horizontal;

            // Spacing is width/numPixels, first LED is at half-spacing from edge
            const ledSpacingX = width / totalPixelsH;
            const ledSpacingY = height / totalPixelsV;
            const ledRadius = Math.min(ledSpacingX, ledSpacingY) * 0.35; // LED size relative to spacing

            for (let py = 0; py < totalPixelsV; py++) {
                for (let px = 0; px < totalPixelsH; px++) {
                    // Calculate brightness based on pattern
                    const brightness = getLEDBrightness(px, py, colIndex, numCols, totalPixelsH);

                    // Skip LEDs that are off (brightness = 0)
                    if (brightness === 0) continue;

                    // Create LED with brightness-adjusted color
                    const ledGeom = new THREE.CircleGeometry(ledRadius, 8);
                    const green = Math.floor(0xe6 * brightness);
                    const ledColor = (green << 8); // Green channel only
                    const ledMat = new THREE.MeshBasicMaterial({ color: ledColor });
                    const led = new THREE.Mesh(ledGeom, ledMat);

                    // Position: start at -halfW + halfSpacing, then increment by spacing
                    // This gives proper half-spacing inset from edges
                    const localX = -halfW + ledSpacingX / 2 + px * ledSpacingX;
                    const localY = -halfH + ledSpacingY / 2 + py * ledSpacingY;
                    const localZ = panelThickness + 0.001; // just in front of border

                    led.position.set(localX, localY, localZ);
                    group.add(led);
                }
            }

            return group;
        }

        function updateMetrics(specs, numCols, numRows, cRadius, arenaHeight) {
            const activeCount = state.activePanels ? state.activePanels.length : numCols;
            const totalPanels = activeCount * numRows;
            const totalLEDs = totalPanels * specs.pixels_horizontal * specs.pixels_vertical;

            // Azimuth resolution: angular distance between horizontal pixels
            // Each panel spans (360/numCols) degrees, divided by pixels_horizontal
            const azimuthRes = 360 / (numCols * specs.pixels_horizontal);

            // Vertical resolution: angular distance between vertical pixels as seen from center
            // This depends on the viewing angle from center to the panel
            // For a fly at center, the vertical angle subtended by the panel height
            // tan(verticalAngle/2) = (arenaHeight/2) / cRadius
            // Convert to degrees per pixel
            const panelHeight = specs.panel_height_mm / 25.4;
            const halfAngleRad = Math.atan((arenaHeight / 2) / cRadius);
            const totalVerticalDegrees = 2 * halfAngleRad * (180 / Math.PI);
            const verticalRes = totalVerticalDegrees / (numRows * specs.pixels_vertical);

            const azimuthPixels = numCols * specs.pixels_horizontal;
            const verticalPixels = numRows * specs.pixels_vertical;

            document.getElementById('num-cols-display').textContent = activeCount;
            document.getElementById('total-panels').textContent = totalPanels;
            document.getElementById('inner-radius').textContent = cRadius.toFixed(2) + ' in';
            document.getElementById('arena-height').textContent = arenaHeight.toFixed(2) + ' in';
            document.getElementById('total-leds').textContent = totalLEDs.toLocaleString();
            document.getElementById('azimuth-res').textContent = azimuthRes.toFixed(2) + '°/px';
            document.getElementById('vertical-res').textContent = verticalRes.toFixed(2) + '°/px';
            document.getElementById('azimuth-pixels').textContent = azimuthPixels;
            document.getElementById('vertical-pixels').textContent = verticalPixels;
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }

        // Start
        init();
    </script>
</body>
</html>
