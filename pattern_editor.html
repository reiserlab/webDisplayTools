<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pattern Editor - PanelDisplayTools</title>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700&family=IBM+Plex+Mono:wght@400;600&display=swap" rel="stylesheet">
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.182.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.182.0/examples/jsm/"
            }
        }
    </script>
    <script src="js/arena-configs.js"></script>
    <script src="js/pat-encoder.js"></script>
    <script src="js/arena-geometry.js"></script>
    <script src="js/pattern-editor/tools/generator.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        :root {
            --bg: #0f1419;
            --surface: #1a1f26;
            --border: #2d3640;
            --text: #e6edf3;
            --text-dim: #8b949e;
            --accent: #00e676;
            --hover: #00c853;
            --warning: #ff9800;
            --led-off: #1e2329;
        }

        body {
            font-family: 'IBM Plex Mono', monospace;
            background: var(--bg);
            color: var(--text);
            height: 100vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        /* Development Banner */
        .dev-banner {
            background: linear-gradient(90deg, var(--warning), #f57c00);
            color: var(--bg);
            text-align: center;
            padding: 0.5rem;
            font-size: 0.8rem;
            font-weight: 600;
            font-family: 'JetBrains Mono', monospace;
        }

        .dev-banner a {
            color: var(--bg);
            text-decoration: underline;
        }

        /* Main Layout */
        .app-container {
            display: flex;
            flex: 1;
            overflow: hidden;
        }

        /* Left Panel - Tools */
        .tools-panel {
            width: 320px;
            min-width: 320px;
            background: var(--surface);
            border-right: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .tools-header {
            padding: 1rem 1.25rem;
            border-bottom: 1px solid var(--border);
        }

        .tools-header h1 {
            font-family: 'JetBrains Mono', monospace;
            font-size: 1.1rem;
            color: var(--accent);
            margin-bottom: 0.25rem;
        }

        .tools-header .subtitle {
            font-size: 0.7rem;
            color: var(--text-dim);
        }

        /* Tool Tabs */
        .tool-tabs {
            display: flex;
            border-bottom: 1px solid var(--border);
            background: var(--bg);
        }

        .tool-tab {
            flex: 1;
            padding: 0.7rem 0.5rem;
            background: transparent;
            border: none;
            border-bottom: 2px solid transparent;
            color: var(--text-dim);
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.7rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .tool-tab:hover {
            color: var(--text);
            background: var(--surface);
        }

        .tool-tab.active {
            color: var(--accent);
            border-bottom-color: var(--accent);
            background: var(--surface);
        }

        /* Tool Content */
        .tool-content {
            flex: 1;
            overflow-y: auto;
            padding: 1rem 1.25rem;
        }

        .tool-pane {
            display: none;
        }

        .tool-pane.active {
            display: block;
        }

        .section-title {
            font-size: 0.65rem;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            color: var(--text-dim);
            margin-bottom: 0.75rem;
            font-weight: 600;
        }

        .control-group {
            margin-bottom: 1rem;
        }

        .control-group label {
            display: block;
            font-size: 0.7rem;
            color: var(--text-dim);
            margin-bottom: 0.3rem;
        }

        .control-group select,
        .control-group input[type="number"] {
            width: 100%;
            padding: 0.5rem 0.6rem;
            background: var(--bg);
            border: 1px solid var(--border);
            border-radius: 4px;
            color: var(--text);
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.8rem;
        }

        .control-group select:focus,
        .control-group input:focus {
            outline: none;
            border-color: var(--accent);
        }

        /* Frame Clipboard */
        .clipboard-section {
            border-top: 1px solid var(--border);
            padding: 1rem 1.25rem;
            background: var(--bg);
        }

        .clipboard-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.75rem;
        }

        .clipboard-header h3 {
            font-size: 0.65rem;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            color: var(--text-dim);
            font-weight: 600;
        }

        .clipboard-count {
            font-size: 0.7rem;
            color: var(--accent);
        }

        .clipboard-frames {
            display: flex;
            gap: 0.5rem;
            align-items: center;
        }

        .clipboard-scroll-btn {
            width: 24px;
            height: 40px;
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 4px;
            color: var(--text-dim);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.8rem;
        }

        .clipboard-scroll-btn:hover {
            border-color: var(--accent);
            color: var(--accent);
        }

        .clipboard-scroll-btn:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        .clipboard-thumbnails {
            display: flex;
            gap: 0.4rem;
            flex: 1;
            overflow: hidden;
        }

        .clipboard-thumb {
            width: 40px;
            height: 40px;
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 4px;
            cursor: pointer;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.6rem;
            color: var(--text-dim);
        }

        .clipboard-thumb:hover {
            border-color: var(--accent);
        }

        .clipboard-thumb.selected {
            border-color: var(--accent);
            box-shadow: 0 0 8px rgba(0, 230, 118, 0.3);
        }

        .clipboard-thumb canvas {
            width: 100%;
            height: 100%;
            border-radius: 3px;
        }

        .clipboard-empty {
            flex: 1;
            text-align: center;
            padding: 0.75rem;
            color: var(--text-dim);
            font-size: 0.7rem;
            font-style: italic;
        }

        /* File Operations */
        .file-operations {
            padding: 1rem 1.25rem;
            border-top: 1px solid var(--border);
            background: var(--surface);
        }

        .arena-select-row {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 0.75rem;
        }

        .arena-select-row label {
            font-size: 0.7rem;
            color: var(--text-dim);
            align-self: center;
            white-space: nowrap;
        }

        .arena-select-row select {
            flex: 1;
            padding: 0.4rem 0.5rem;
            background: var(--bg);
            border: 1px solid var(--border);
            border-radius: 4px;
            color: var(--text);
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.75rem;
        }

        .file-buttons {
            display: flex;
            gap: 0.5rem;
        }

        .btn {
            flex: 1;
            padding: 0.6rem;
            background: var(--accent);
            border: none;
            border-radius: 4px;
            color: var(--bg);
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.75rem;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.2s;
        }

        .btn:hover {
            background: var(--hover);
        }

        .btn.secondary {
            background: var(--bg);
            border: 1px solid var(--border);
            color: var(--text);
        }

        .btn.secondary:hover {
            border-color: var(--accent);
            color: var(--accent);
        }

        /* Right Panel - Viewer */
        .viewer-panel {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        /* Viewer Tabs */
        .viewer-tabs {
            display: flex;
            padding: 0.75rem 1rem;
            gap: 0.5rem;
            border-bottom: 1px solid var(--border);
            background: var(--surface);
        }

        .viewer-tab {
            padding: 0.5rem 1rem;
            background: var(--bg);
            border: 1px solid var(--border);
            border-radius: 4px;
            color: var(--text-dim);
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.75rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        .viewer-tab:hover {
            border-color: var(--accent);
            color: var(--text);
        }

        .viewer-tab.active {
            background: rgba(0, 230, 118, 0.1);
            border-color: var(--accent);
            color: var(--accent);
        }

        .viewer-tab.disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }

        .viewer-options {
            margin-left: auto;
            display: flex;
            gap: 1rem;
            align-items: center;
        }

        .viewer-options label {
            display: flex;
            align-items: center;
            gap: 0.4rem;
            font-size: 0.7rem;
            color: var(--text-dim);
            cursor: pointer;
        }

        .viewer-options input[type="checkbox"] {
            accent-color: var(--accent);
        }

        /* Viewer Content */
        .viewer-content {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            background: var(--bg);
            position: relative;
            overflow: hidden;
        }

        .viewer-pane {
            display: none;
            width: 100%;
            height: 100%;
        }

        .viewer-pane.active {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        /* Grid Viewer */
        #gridViewer {
            position: relative;
        }

        .grid-canvas-container {
            position: relative;
        }

        #gridCanvas {
            border: 1px solid var(--border);
            cursor: crosshair;
        }

        /* Edit Mode Toggle */
        .edit-mode-toggle {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .edit-toggle-btn {
            padding: 0.4rem 0.8rem;
            background: var(--bg);
            border: 1px solid var(--border);
            border-radius: 4px;
            color: var(--text-dim);
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.7rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        .edit-toggle-btn:hover {
            border-color: var(--accent);
            color: var(--text);
        }

        .edit-toggle-btn.active {
            background: rgba(0, 230, 118, 0.15);
            border-color: var(--accent);
            color: var(--accent);
        }

        /* Edit Toolbar */
        .edit-toolbar {
            display: none;
            padding: 0.5rem 1rem;
            background: var(--surface);
            border-bottom: 1px solid var(--border);
            gap: 1rem;
            align-items: center;
            flex-wrap: wrap;
        }

        .edit-toolbar.visible {
            display: flex;
        }

        .toolbar-section {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .toolbar-label {
            font-size: 0.65rem;
            color: var(--text-dim);
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        /* Palette in Edit Mode */
        .edit-palette {
            display: flex;
            gap: 2px;
        }

        .palette-swatch {
            width: 20px;
            height: 20px;
            border: 2px solid var(--border);
            border-radius: 2px;
            cursor: pointer;
            transition: all 0.15s;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.55rem;
            font-weight: 700;
            font-family: 'JetBrains Mono', monospace;
        }

        .palette-swatch:hover {
            transform: scale(1.15);
            border-color: var(--accent);
        }

        .palette-swatch.selected {
            border: 2px solid var(--accent);
            box-shadow: 0 0 8px var(--accent);
        }

        .current-color-display {
            font-size: 0.75rem;
            color: var(--accent);
            font-weight: 600;
            min-width: 30px;
        }

        /* Edit Operations */
        .edit-ops-btn {
            padding: 0.35rem 0.6rem;
            background: var(--bg);
            border: 1px solid var(--border);
            border-radius: 3px;
            color: var(--text-dim);
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.65rem;
            cursor: pointer;
            transition: all 0.15s;
        }

        .edit-ops-btn:hover {
            border-color: var(--accent);
            color: var(--accent);
        }

        /* Find/Replace Modal */
        .modal-overlay {
            display: none;
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.7);
            z-index: 100;
            align-items: center;
            justify-content: center;
        }

        .modal-overlay.visible {
            display: flex;
        }

        .modal-content {
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 1.5rem;
            min-width: 300px;
        }

        .modal-title {
            font-family: 'JetBrains Mono', monospace;
            font-size: 1rem;
            color: var(--accent);
            margin-bottom: 1rem;
        }

        .modal-row {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            margin-bottom: 0.75rem;
        }

        .modal-row label {
            font-size: 0.75rem;
            color: var(--text-dim);
            min-width: 60px;
        }

        .modal-row input {
            flex: 1;
            padding: 0.4rem 0.6rem;
            background: var(--bg);
            border: 1px solid var(--border);
            border-radius: 4px;
            color: var(--text);
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.8rem;
        }

        .modal-row input:focus {
            outline: none;
            border-color: var(--accent);
        }

        .modal-buttons {
            display: flex;
            gap: 0.5rem;
            margin-top: 1rem;
            justify-content: flex-end;
        }

        .modal-btn {
            padding: 0.5rem 1rem;
            border-radius: 4px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.75rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        .modal-btn.primary {
            background: var(--accent);
            border: none;
            color: var(--bg);
        }

        .modal-btn.primary:hover {
            background: var(--hover);
        }

        .modal-btn.secondary {
            background: transparent;
            border: 1px solid var(--border);
            color: var(--text);
        }

        .modal-btn.secondary:hover {
            border-color: var(--accent);
            color: var(--accent);
        }

        /* Row/Column Headers for Edit Mode */
        .grid-with-headers {
            display: grid;
            grid-template-columns: 24px 1fr;
            grid-template-rows: 24px 1fr;
            gap: 2px;
        }

        .row-header, .col-header {
            display: flex;
            align-items: center;
            justify-content: center;
            background: var(--surface);
            cursor: pointer;
            font-size: 0.5rem;
            color: var(--text-dim);
            transition: all 0.15s;
        }

        .row-header:hover, .col-header:hover {
            background: var(--accent);
            color: var(--bg);
        }

        .corner-spacer {
            background: var(--surface);
        }

        /* Placeholder content */
        .placeholder {
            text-align: center;
            color: var(--text-dim);
        }

        .placeholder-icon {
            font-size: 4rem;
            margin-bottom: 1rem;
            opacity: 0.3;
        }

        .placeholder h2 {
            font-family: 'JetBrains Mono', monospace;
            font-size: 1.2rem;
            color: var(--text);
            margin-bottom: 0.5rem;
        }

        .placeholder p {
            font-size: 0.85rem;
            max-width: 400px;
            line-height: 1.5;
        }

        /* Playback Controls */
        .playback-controls {
            display: flex;
            align-items: center;
            gap: 1rem;
            padding: 0.75rem 1rem;
            border-top: 1px solid var(--border);
            background: var(--surface);
        }

        .frame-nav {
            display: flex;
            align-items: center;
            gap: 0.3rem;
        }

        .frame-btn {
            width: 28px;
            height: 28px;
            background: var(--bg);
            border: 1px solid var(--border);
            border-radius: 4px;
            color: var(--text-dim);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.8rem;
        }

        .frame-btn:hover {
            border-color: var(--accent);
            color: var(--accent);
        }

        .frame-info {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.8rem;
            color: var(--text);
            min-width: 80px;
            text-align: center;
        }

        .play-btn {
            width: 36px;
            height: 36px;
            background: var(--accent);
            border: none;
            border-radius: 50%;
            color: var(--bg);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1rem;
        }

        .play-btn:hover {
            background: var(--hover);
        }

        .fps-select {
            padding: 0.4rem 0.6rem;
            background: var(--bg);
            border: 1px solid var(--border);
            border-radius: 4px;
            color: var(--text);
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.75rem;
        }

        .capture-btn {
            margin-left: auto;
            padding: 0.5rem 1rem;
            background: var(--bg);
            border: 1px solid var(--accent);
            border-radius: 4px;
            color: var(--accent);
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.75rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        .capture-btn:hover {
            background: var(--accent);
            color: var(--bg);
        }

        /* Status Bar */
        .status-bar {
            display: flex;
            justify-content: space-between;
            padding: 0.5rem 1rem;
            background: var(--surface);
            border-top: 1px solid var(--border);
            font-size: 0.7rem;
            color: var(--text-dim);
        }

        .status-bar .pattern-info {
            display: flex;
            gap: 1.5rem;
        }

        .status-bar .unsaved {
            color: var(--warning);
            font-weight: 600;
        }

        .status-bar .small-btn {
            background: transparent;
            border: 1px solid var(--border);
            color: var(--text-dim);
            padding: 0.1rem 0.3rem;
            font-size: 0.65rem;
            cursor: pointer;
            border-radius: 3px;
            margin-left: 0.3rem;
        }

        .status-bar .small-btn:hover {
            background: var(--border);
            color: var(--text);
        }

        .status-bar .arena-config {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .status-bar .arena-config select {
            background: var(--bg);
            border: 1px solid var(--border);
            color: var(--text);
            padding: 0.15rem 0.3rem;
            font-size: 0.65rem;
            border-radius: 3px;
            cursor: pointer;
        }

        .status-bar .arena-config select:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            background: var(--surface);
        }

        .status-bar .arena-config .lock-btn {
            background: transparent;
            border: none;
            color: var(--text-dim);
            padding: 0.1rem 0.25rem;
            font-size: 0.75rem;
            cursor: pointer;
            border-radius: 3px;
        }

        .status-bar .arena-config .lock-btn:hover {
            background: var(--border);
            color: var(--text);
        }

        .status-bar .arena-config .lock-btn.locked {
            color: var(--accent);
        }

        /* Coming Soon overlay for disabled features */
        .coming-soon-overlay {
            position: absolute;
            inset: 0;
            background: rgba(15, 20, 25, 0.9);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10;
        }

        .coming-soon-badge {
            background: var(--surface);
            border: 1px solid var(--border);
            padding: 1rem 2rem;
            border-radius: 8px;
            text-align: center;
        }

        .coming-soon-badge h3 {
            font-family: 'JetBrains Mono', monospace;
            color: var(--accent);
            margin-bottom: 0.5rem;
        }

        .coming-soon-badge p {
            font-size: 0.8rem;
            color: var(--text-dim);
        }
    </style>
</head>
<body>
    <!-- Development Banner -->
    <div class="dev-banner">
        üöß Pattern Editor v0.3 | 2026-01-31 ‚Äî <a href="https://github.com/reiserlab/webDisplayTools/issues/6" target="_blank">View progress on GitHub</a>
    </div>

    <div class="app-container">
        <!-- Left Panel: Tools -->
        <div class="tools-panel">
            <div class="tools-header">
                <h1>Pattern Editor</h1>
                <div class="subtitle">Create and edit arena patterns</div>
            </div>

            <!-- Tool Tabs -->
            <div class="tool-tabs">
                <button class="tool-tab active" data-tab="generate">Generate</button>
                <button class="tool-tab" data-tab="frame">Animate</button>
                <button class="tool-tab" data-tab="combine">Combine</button>
            </div>

            <!-- Tool Content -->
            <div class="tool-content">
                <!-- Generate Tab -->
                <div class="tool-pane active" id="generatePane">
                    <div class="section-title">Pattern Type</div>
                    <div class="control-group">
                        <select id="patternType">
                            <option value="grating">Square Grating</option>
                            <option value="sine">Sine Grating</option>
                            <option value="starfield">Starfield</option>
                            <option value="edge">Edge</option>
                            <option value="off-on">Off/On</option>
                            <option value="looming" disabled>Looming (coming soon)</option>
                        </select>
                    </div>

                    <!-- Spherical mode toggle (for grating/sine) -->
                    <div id="sphericalModeGroup" class="control-group" style="margin-top: 0.5rem;">
                        <label style="display: flex; align-items: center; gap: 0.5rem;">
                            <input type="checkbox" id="useSpherical">
                            Use spherical coordinates
                            <span style="color: var(--text-dim); font-size: 0.7rem;" title="Uses proper 3D geometry for cylindrical arena projection. Matches MATLAB output.">(?)</span>
                        </label>
                    </div>

                    <!-- Spherical-specific controls -->
                    <div id="sphericalParams" style="display: none;">
                        <div class="control-group">
                            <label>Motion Type</label>
                            <select id="motionType">
                                <option value="rotation">Rotation (horizontal stripes)</option>
                                <option value="expansion">Expansion (concentric rings)</option>
                                <option value="translation">Translation (linear motion)</option>
                            </select>
                        </div>
                        <div class="control-group">
                            <label>Arena Model</label>
                            <select id="arenaModel">
                                <option value="smooth">Smooth cylinder</option>
                                <option value="poly">Polygonal</option>
                            </select>
                        </div>
                        <div class="control-group">
                            <label>Anti-aliasing</label>
                            <select id="aaSamples">
                                <option value="1">None (fastest)</option>
                                <option value="5">Low (5 samples)</option>
                                <option value="15" selected>Standard (15 samples)</option>
                            </select>
                        </div>
                    </div>

                    <div class="section-title">Parameters</div>

                    <!-- Common grating/sine params -->
                    <div id="gratingParams">
                        <div class="control-group">
                            <label id="spatialFreqLabel">Wavelength (pixels)</label>
                            <div style="display: flex; gap: 0.5rem;">
                                <input type="number" id="spatialFreq" value="20" min="1" max="1000" style="flex: 1;">
                                <select id="spatialFreqUnit" style="width: 80px;">
                                    <option value="px" selected>pixels</option>
                                    <option value="rad">radians</option>
                                    <option value="deg">degrees</option>
                                </select>
                            </div>
                        </div>
                        <div class="control-group" id="dutyCycleGroup">
                            <label>Duty Cycle (%)</label>
                            <input type="number" id="dutyCycle" value="50" min="1" max="99">
                        </div>
                    </div>

                    <!-- Starfield params -->
                    <div id="starfieldParams" style="display: none;">
                        <div class="control-group">
                            <label>Dot Count</label>
                            <input type="number" id="dotCount" value="100" min="1" max="1000">
                        </div>
                        <div class="control-group">
                            <label>Dot Size (pixels)</label>
                            <input type="number" id="dotSize" value="1" min="1" max="10">
                        </div>
                        <div class="control-group">
                            <label>Random Seed</label>
                            <input type="number" id="starfieldSeed" value="12345" min="1">
                        </div>
                    </div>

                    <!-- Edge params -->
                    <div id="edgeParams" style="display: none;">
                        <div class="control-group">
                            <label>Edge Position (0-1)</label>
                            <input type="number" id="edgePosition" value="0.5" min="0" max="1" step="0.1">
                        </div>
                        <div class="control-group">
                            <label>Polarity</label>
                            <select id="edgePolarity">
                                <option value="light-to-dark">Light ‚Üí Dark</option>
                                <option value="dark-to-light">Dark ‚Üí Light</option>
                            </select>
                        </div>
                    </div>

                    <!-- Motion params (hidden for off/on) -->
                    <div id="motionParams">
                        <div class="control-group">
                            <label>Step Size (pixels/frame)</label>
                            <input type="number" id="stepSize" value="1" min="1" max="20">
                        </div>
                        <div class="control-group">
                            <label>Direction</label>
                            <select id="direction">
                                <option value="cw">Clockwise</option>
                                <option value="ccw">Counter-clockwise</option>
                            </select>
                        </div>
                        <div class="control-group" id="numFramesGroup">
                            <label>Number of Frames <span id="numFramesHint" style="color: var(--text-dim); font-size: 0.7rem;"></span></label>
                            <input type="number" id="numFramesInput" value="200" min="1" max="10000">
                        </div>
                    </div>

                    <div class="section-title">Brightness</div>
                    <div class="control-group">
                        <label>Grayscale Mode</label>
                        <select id="gsMode">
                            <option value="16">GS16 (4-bit, 0-15)</option>
                            <option value="2">GS2 (binary, 0-1)</option>
                        </select>
                    </div>
                    <div class="control-group">
                        <label>High Level</label>
                        <input type="number" id="highLevel" value="15" min="0" max="15">
                    </div>
                    <div class="control-group">
                        <label>Low Level</label>
                        <input type="number" id="lowLevel" value="0" min="0" max="15">
                    </div>

                    <button class="btn" id="generateBtn" style="margin-top: 1rem;">Generate Pattern ‚Üí</button>
                </div>

                <!-- Frame to Pattern Tab -->
                <div class="tool-pane" id="framePane">
                    <div class="section-title">Sequence Builder</div>
                    <p style="font-size: 0.75rem; color: var(--text-dim); margin-bottom: 1rem;">
                        Select frame(s) from the clipboard below, then configure rotation to generate a pattern.
                    </p>

                    <div class="control-group">
                        <label>Motion Direction</label>
                        <select id="rotateDirection">
                            <option value="h-cw">Horizontal CW</option>
                            <option value="h-ccw">Horizontal CCW</option>
                            <option value="v-up">Vertical Up</option>
                            <option value="v-down">Vertical Down</option>
                        </select>
                    </div>
                    <div class="control-group">
                        <label>Step Size (pixels/frame)</label>
                        <input type="number" id="rotateStep" value="1" min="1" max="20">
                    </div>
                    <div class="control-group">
                        <label>Total Frames <span id="framesHint" style="color: var(--text-dim); font-size: 0.7rem;"></span></label>
                        <input type="number" id="totalFrames" value="200" min="1" max="10000">
                    </div>

                    <button class="btn" id="buildSequenceBtn" style="margin-top: 1rem;">Generate Sequence</button>
                </div>

                <!-- Combine Tab -->
                <div class="tool-pane" id="combinePane">
                    <div class="section-title">Pattern A</div>
                    <div class="control-group">
                        <div style="padding: 0.5rem; background: var(--bg); border-radius: 4px; font-size: 0.75rem; color: var(--text-dim); margin-bottom: 0.5rem;">
                            <span id="patternAInfo">No pattern set</span>
                        </div>
                        <div style="display: flex; gap: 0.5rem;">
                            <button class="btn secondary" id="setPatternA" style="flex: 1;">Use Current as A</button>
                            <button class="btn secondary" id="loadPatternA" style="flex: 1;">Load A...</button>
                            <button class="btn secondary" id="clearPatternA" style="width: auto; padding: 0.4rem 0.8rem;" title="Clear Pattern A">‚úï</button>
                        </div>
                    </div>

                    <div class="section-title">Pattern B</div>
                    <div class="control-group">
                        <div style="padding: 0.5rem; background: var(--bg); border-radius: 4px; font-size: 0.75rem; color: var(--text-dim); margin-bottom: 0.5rem;">
                            <span id="patternBInfo">No pattern set</span>
                        </div>
                        <div style="display: flex; gap: 0.5rem;">
                            <button class="btn secondary" id="setPatternB" style="flex: 1;">Use Current as B</button>
                            <button class="btn secondary" id="loadPatternB" style="flex: 1;">Load B...</button>
                            <button class="btn secondary" id="clearPatternB" style="width: auto; padding: 0.4rem 0.8rem;" title="Clear Pattern B">‚úï</button>
                        </div>
                    </div>

                    <div style="text-align: center; margin: 1rem 0;">
                        <button class="btn secondary" id="swapBtn" style="width: auto; padding: 0.4rem 1rem;">
                            ‚Üï Swap A ‚Üî B
                        </button>
                    </div>

                    <div class="section-title">Combination Mode</div>
                    <div class="control-group">
                        <select id="combineMode">
                            <option value="sequential">Sequential (concatenate)</option>
                            <option value="mask">Mask (threshold)</option>
                            <option value="blend">Blend (50%)</option>
                            <option value="split-h">Horizontal Split (left/right)</option>
                            <option value="split-v">Vertical Split (top/bottom)</option>
                        </select>
                    </div>

                    <!-- Mode-specific options -->
                    <div id="combineMaskOptions" class="control-group" style="display: none;">
                        <label>Threshold (0-15):</label>
                        <input type="number" id="maskThreshold" value="7" min="0" max="15" step="1">
                        <span style="font-size: 0.7rem; color: var(--text-dim);">Pixels above threshold show B</span>
                    </div>

                    <div id="combineSplitOptions" class="control-group" style="display: none;">
                        <label>Split Position:</label>
                        <input type="range" id="splitPosition" value="50" min="0" max="100" step="1" style="width: 100%;">
                        <div style="display: flex; justify-content: space-between; font-size: 0.7rem; color: var(--text-dim);">
                            <span id="splitPositionPercent">50%</span>
                            <span id="splitPositionPixel">pixel ‚Äî</span>
                        </div>
                    </div>

                    <div id="combineLengthOptions" class="control-group" style="display: none; margin-top: 0.5rem; padding: 0.5rem; background: var(--bg); border-radius: 4px;">
                        <label style="font-size: 0.75rem; color: var(--text-dim);">Different frame counts:</label>
                        <select id="lengthHandling" style="margin-top: 0.25rem;">
                            <option value="loop">Loop shorter pattern</option>
                            <option value="truncate">Truncate to shorter</option>
                            <option value="extend">Extend shorter (hold last frame)</option>
                        </select>
                    </div>

                    <button class="btn" id="combineBtn" style="margin-top: 1rem;">Combine Patterns</button>
                </div>
            </div>

            <!-- Frame Clipboard -->
            <div class="clipboard-section">
                <div class="clipboard-header">
                    <h3>Frame Clipboard</h3>
                    <span class="clipboard-count" id="clipboardCount">0 frames</span>
                </div>
                <div class="clipboard-frames">
                    <button class="clipboard-scroll-btn" id="clipboardPrev" disabled>‚óÄ</button>
                    <div class="clipboard-thumbnails" id="clipboardThumbnails">
                        <div class="clipboard-empty">Capture frames to build sequences</div>
                    </div>
                    <button class="clipboard-scroll-btn" id="clipboardNext" disabled>‚ñ∂</button>
                </div>
            </div>

            <!-- File Operations -->
            <div class="file-operations">
                <div class="file-buttons">
                    <button class="btn secondary" id="loadBtn">Load</button>
                    <button class="btn secondary" id="saveBtn">Save</button>
                    <button class="btn secondary" id="newBtn">New</button>
                </div>
            </div>
        </div>

        <!-- Right Panel: Viewer -->
        <div class="viewer-panel">
            <!-- Viewer Tabs -->
            <div class="viewer-tabs">
                <button class="viewer-tab active" data-viewer="grid">2D</button>
                <button class="viewer-tab" data-viewer="edit">Edit</button>
                <button class="viewer-tab" data-viewer="3d">3D</button>
                <button class="viewer-tab disabled" data-viewer="mercator">Mercator</button>
                <button class="viewer-tab disabled" data-viewer="mollweide">Mollweide</button>

                <div class="viewer-options">
                    <label>
                        <input type="checkbox" id="showBoundaries" checked>
                        Panel boundaries
                    </label>
                    <label>
                        <input type="checkbox" id="showNumbers">
                        Panel numbers
                    </label>
                </div>
            </div>

            <!-- Edit Toolbar (visible in edit mode) -->
            <div class="edit-toolbar" id="editToolbar">
                <div class="toolbar-section">
                    <span class="toolbar-label">Color:</span>
                    <div class="edit-palette" id="editPalette"></div>
                    <span class="current-color-display" id="currentColorDisplay">15</span>
                </div>
                <div class="toolbar-section">
                    <span class="toolbar-label">Transform:</span>
                    <button class="edit-ops-btn" id="flipHBtn" title="Flip Horizontal">Flip H</button>
                    <button class="edit-ops-btn" id="flipVBtn" title="Flip Vertical">Flip V</button>
                    <button class="edit-ops-btn" id="invertBtn" title="Invert Brightness">Invert</button>
                    <button class="edit-ops-btn" id="findReplaceBtn" title="Find and Replace">Find/Replace</button>
                </div>
            </div>

            <!-- Viewer Content -->
            <div class="viewer-content">
                <!-- Grid Viewer -->
                <div class="viewer-pane active" id="gridViewer">
                    <div class="placeholder">
                        <div class="placeholder-icon">‚¨ö</div>
                        <h2>No Pattern Loaded</h2>
                        <p>Load a .pat file or generate a new pattern to view it here.</p>
                    </div>
                </div>

                <!-- 3D Viewer -->
                <div class="viewer-pane" id="3dViewer">
                    <div id="threeContainer" style="width: 100%; height: 100%;"></div>
                </div>

                <!-- Mercator Viewer -->
                <div class="viewer-pane" id="mercatorViewer">
                    <div class="coming-soon-overlay">
                        <div class="coming-soon-badge">
                            <h3>Mercator Projection</h3>
                            <p>Optional enhancement</p>
                        </div>
                    </div>
                </div>

                <!-- Mollweide Viewer -->
                <div class="viewer-pane" id="mollweideViewer">
                    <div class="coming-soon-overlay">
                        <div class="coming-soon-badge">
                            <h3>Mollweide Projection</h3>
                            <p>Optional enhancement</p>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Playback Controls -->
            <div class="playback-controls">
                <div class="frame-nav">
                    <button class="frame-btn" id="firstFrameBtn" title="First frame">‚èÆ</button>
                    <button class="frame-btn" id="prevFrameBtn" title="Previous frame">‚óÄ</button>
                    <span class="frame-info" id="frameInfo">1 / 1</span>
                    <button class="frame-btn" id="nextFrameBtn" title="Next frame">‚ñ∂</button>
                    <button class="frame-btn" id="lastFrameBtn" title="Last frame">‚è≠</button>
                </div>

                <div class="stretch-control" style="display: flex; align-items: center; gap: 0.25rem; padding: 0 0.5rem; border-left: 1px solid var(--border);">
                    <label style="font-size: 0.75rem; color: var(--text-dim);">Stretch:</label>
                    <input type="number" id="stretchValue" value="1" min="1" max="255" step="1" style="width: 50px; padding: 0.2rem 0.4rem; font-size: 0.75rem; background: var(--surface); border: 1px solid var(--border); color: var(--text); border-radius: 4px;">
                </div>

                <button class="play-btn" id="playBtn" title="Play/Pause">‚ñ∂</button>

                <select class="fps-select" id="fpsSelect">
                    <option value="-30">-30 FPS</option>
                    <option value="-20">-20 FPS</option>
                    <option value="-10">-10 FPS</option>
                    <option value="-5">-5 FPS</option>
                    <option value="-1">-1 FPS</option>
                    <option value="1">1 FPS</option>
                    <option value="5">5 FPS</option>
                    <option value="10" selected>10 FPS</option>
                    <option value="20">20 FPS</option>
                    <option value="30">30 FPS</option>
                </select>

                <button class="capture-btn" id="captureBtn">‚Üê Capture Frame</button>
            </div>
        </div>
    </div>

    <!-- Status Bar -->
    <div class="status-bar">
        <div class="pattern-info">
            <span id="statusFilename">No pattern</span>
            <button id="renameBtn" class="small-btn" title="Rename pattern">‚úé</button>
            <span id="statusDimensions">‚Äî</span>
            <span id="statusFrames">‚Äî</span>
            <span id="statusGsMode">‚Äî</span>
            <span id="statusUnsaved" style="color: #ff4444; font-weight: bold;"></span>
        </div>
        <div class="arena-config">
            <span style="color: var(--text-dim);">Arena:</span>
            <select id="arenaConfigStatus"></select>
            <button id="arenaLockBtn" class="lock-btn" title="Lock arena config">üîì</button>
        </div>
    </div>

    <!-- Hidden file input -->
    <input type="file" id="fileInput" accept=".pat" style="display: none;">
    <input type="file" id="fileInputA" accept=".pat" style="display: none;">
    <input type="file" id="fileInputB" accept=".pat" style="display: none;">

    <!-- Find/Replace Modal -->
    <div class="modal-overlay" id="findReplaceModal">
        <div class="modal-content">
            <h3 class="modal-title">Find and Replace</h3>
            <div class="modal-row">
                <label>Find:</label>
                <input type="number" id="findValue" min="0" max="15" value="0">
            </div>
            <div class="modal-row">
                <label>Replace:</label>
                <input type="number" id="replaceValue" min="0" max="15" value="15">
            </div>
            <div class="modal-buttons">
                <button class="modal-btn secondary" id="cancelFindReplace">Cancel</button>
                <button class="modal-btn primary" id="applyFindReplace">Replace All</button>
            </div>
        </div>
    </div>

    <script type="module">
        import PatParser from './js/pat-parser.js';
        import ThreeViewer from './js/pattern-editor/viewers/three-viewer.js';
        import { combinePatterns } from './js/pattern-editor/tools/combiner.js';

        // ============================================
        // State Management
        // ============================================
        const state = {
            pattern: null,          // Current loaded/generated pattern
            combinePatternA: null,  // Pattern A for combining (saved separately)
            combinePatternB: null,  // Pattern B for combining (saved separately)
            clipboard: [],          // Array of captured frames
            clipboardOffset: 0,     // Scroll offset for clipboard display
            selectedClipboardIds: [], // Selected clipboard entries for sequence building
            editor: {
                activeTool: 'generate',
                activeViewer: 'grid',
                editMode: false,
                editingClipboardId: null,
                showPanelBoundaries: true,
                showPanelNumbers: false,
                currentFrame: 0,
                drawColor: 15
            },
            playback: {
                isPlaying: false,
                fps: 10,
                intervalId: null
            },
            arena: {
                configName: 'G6_2x10',
                config: null,
                locked: false
            },
            isDirty: false,
            filename: null,
            listeners: new Map()
        };

        // 3D Viewer instance
        let threeViewer = null;

        // Event emitter
        function emit(event, data) {
            const callbacks = state.listeners.get(event) || [];
            callbacks.forEach(cb => cb(data));
        }

        function on(event, callback) {
            if (!state.listeners.has(event)) {
                state.listeners.set(event, []);
            }
            state.listeners.get(event).push(callback);
        }

        // ============================================
        // UI Initialization
        // ============================================
        function initUI() {
            // Populate arena config dropdown (in status bar)
            const arenaSelect = document.getElementById('arenaConfigStatus');
            const configsByGen = getConfigsByGeneration();

            for (const [gen, configs] of Object.entries(configsByGen)) {
                const optgroup = document.createElement('optgroup');
                optgroup.label = gen;
                configs.forEach(name => {
                    const option = document.createElement('option');
                    option.value = name;
                    option.textContent = name;
                    if (name === state.arena.configName) {
                        option.selected = true;
                    }
                    optgroup.appendChild(option);
                });
                arenaSelect.appendChild(optgroup);
            }

            // Load initial config
            state.arena.config = getConfig(state.arena.configName);

            // Tool tabs
            document.querySelectorAll('.tool-tab').forEach(tab => {
                tab.addEventListener('click', () => {
                    const tabName = tab.dataset.tab;
                    setActiveTool(tabName);
                });
            });

            // Viewer tabs
            document.querySelectorAll('.viewer-tab:not(.disabled)').forEach(tab => {
                tab.addEventListener('click', () => {
                    const viewerName = tab.dataset.viewer;
                    setActiveViewer(viewerName);
                });
            });

            // View options
            document.getElementById('showBoundaries').addEventListener('change', (e) => {
                state.editor.showPanelBoundaries = e.target.checked;
                renderCurrentViewer();
            });

            document.getElementById('showNumbers').addEventListener('change', (e) => {
                state.editor.showPanelNumbers = e.target.checked;
                // Update 3D viewer if it exists
                if (threeViewer) {
                    threeViewer.setOptions({ showPanelNumbers: e.target.checked });
                }
                renderCurrentViewer();
            });

            // Edit operations
            document.getElementById('flipHBtn').addEventListener('click', flipHorizontal);
            document.getElementById('flipVBtn').addEventListener('click', flipVertical);
            document.getElementById('invertBtn').addEventListener('click', invertBrightness);
            document.getElementById('findReplaceBtn').addEventListener('click', () => {
                document.getElementById('findReplaceModal').classList.add('visible');
            });
            document.getElementById('cancelFindReplace').addEventListener('click', () => {
                document.getElementById('findReplaceModal').classList.remove('visible');
            });
            document.getElementById('applyFindReplace').addEventListener('click', applyFindReplace);

            // Initialize edit palette
            initEditPalette();

            // File operations
            document.getElementById('loadBtn').addEventListener('click', () => {
                document.getElementById('fileInput').click();
            });

            document.getElementById('fileInput').addEventListener('change', handleFileLoad);

            document.getElementById('saveBtn').addEventListener('click', handleSave);
            document.getElementById('newBtn').addEventListener('click', handleNew);

            document.getElementById('renameBtn').addEventListener('click', () => {
                if (!state.pattern) {
                    alert('No pattern loaded');
                    return;
                }
                const currentName = state.filename || 'pattern.pat';
                const newName = prompt('Enter new filename:', currentName);
                if (newName && newName.trim()) {
                    // Ensure .pat extension
                    let finalName = newName.trim().endsWith('.pat') ? newName.trim() : newName.trim() + '.pat';

                    // Check if user removed the arena config prefix
                    const configPrefix = state.arena.configName + '_';
                    const hadPrefix = currentName.startsWith(configPrefix);
                    const hasPrefix = finalName.startsWith(configPrefix);

                    if (hadPrefix && !hasPrefix) {
                        // User removed the prefix - warn them
                        const keepPrefix = confirm(
                            '‚ö†Ô∏è Warning: You removed the arena config prefix.\n\n' +
                            'MATLAB requires patterns to be in a folder matching the arena config, ' +
                            'OR have the config name as a filename prefix (e.g., "' + configPrefix + '...").\n\n' +
                            'Without this prefix, MATLAB cannot auto-detect the arena configuration.\n\n' +
                            'Click OK to restore the prefix, or Cancel to keep your filename.'
                        );
                        if (keepPrefix) {
                            finalName = addArenaPrefix(finalName);
                        }
                    }

                    state.filename = finalName;
                    state.isDirty = true;
                    updateStatus();
                }
            });

            document.getElementById('arenaConfigStatus').addEventListener('change', (e) => {
                state.arena.configName = e.target.value;
                state.arena.config = getConfig(e.target.value);
                updateStatus();
                updateG3ButtonStates();  // Disable save/load for G3
            });

            // Arena lock/unlock button
            document.getElementById('arenaLockBtn').addEventListener('click', toggleArenaLock);

            // Playback controls
            document.getElementById('playBtn').addEventListener('click', togglePlayback);
            document.getElementById('prevFrameBtn').addEventListener('click', () => navigateFrame(-1));
            document.getElementById('nextFrameBtn').addEventListener('click', () => navigateFrame(1));
            document.getElementById('firstFrameBtn').addEventListener('click', () => goToFrame(0));
            document.getElementById('lastFrameBtn').addEventListener('click', () => {
                if (state.pattern) goToFrame(state.pattern.numFrames - 1);
            });

            document.getElementById('fpsSelect').addEventListener('change', (e) => {
                state.playback.fps = parseInt(e.target.value);
                if (state.playback.isPlaying) {
                    stopPlayback();
                    startPlayback();
                }
            });

            // Capture button
            document.getElementById('captureBtn').addEventListener('click', captureFrame);

            // Generate button and pattern type change
            document.getElementById('generateBtn').addEventListener('click', handleGenerate);
            document.getElementById('patternType').addEventListener('change', updatePatternTypeUI);

            // Spherical mode controls
            document.getElementById('useSpherical').addEventListener('change', () => {
                updatePatternTypeUI();
                updateSpatialFreqLabel();
            });
            document.getElementById('spatialFreqUnit').addEventListener('change', updateSpatialFreqLabel);

            // Combine operations - Pattern A
            document.getElementById('setPatternA').addEventListener('click', handleSetPatternA);
            document.getElementById('loadPatternA').addEventListener('click', () => {
                document.getElementById('fileInputA').click();
            });
            document.getElementById('fileInputA').addEventListener('change', handleLoadPatternA);
            document.getElementById('clearPatternA').addEventListener('click', handleClearPatternA);

            // Combine operations - Pattern B
            document.getElementById('setPatternB').addEventListener('click', handleSetPatternB);
            document.getElementById('loadPatternB').addEventListener('click', () => {
                document.getElementById('fileInputB').click();
            });
            document.getElementById('fileInputB').addEventListener('change', handleLoadPatternB);
            document.getElementById('clearPatternB').addEventListener('click', handleClearPatternB);

            // Combine operations - other
            document.getElementById('swapBtn').addEventListener('click', handleSwap);
            document.getElementById('combineBtn').addEventListener('click', handleCombine);
            document.getElementById('combineMode').addEventListener('change', updateCombineModeUI);
            document.getElementById('splitPosition').addEventListener('input', updateSplitPositionDisplay);
            document.getElementById('buildSequenceBtn').addEventListener('click', handleBuildSequence);

            // Direction change updates default frames
            document.getElementById('rotateDirection').addEventListener('change', updateDefaultFrames);

            // Clipboard scroll buttons
            document.getElementById('clipboardPrev').addEventListener('click', () => scrollClipboard(-1));
            document.getElementById('clipboardNext').addEventListener('click', () => scrollClipboard(1));

            // Stretch value input
            document.getElementById('stretchValue').addEventListener('change', handleStretchChange);

            // Initial status
            updateStatus();
        }

        function setActiveTool(tabName) {
            state.editor.activeTool = tabName;

            document.querySelectorAll('.tool-tab').forEach(t => {
                t.classList.toggle('active', t.dataset.tab === tabName);
            });

            document.querySelectorAll('.tool-pane').forEach(p => {
                p.classList.toggle('active', p.id === tabName + 'Pane');
            });

            // Update combine info when switching to combine tab
            if (tabName === 'combine') {
                updateCombineInfo();
            }
        }

        function setActiveViewer(viewerName) {
            // Map 'edit' to 'grid' for the viewer pane, but track edit mode
            const isEditMode = viewerName === 'edit';
            const actualViewer = isEditMode ? 'grid' : viewerName;

            state.editor.activeViewer = actualViewer;
            state.editor.editMode = isEditMode;

            // Update tab highlighting
            document.querySelectorAll('.viewer-tab').forEach(t => {
                t.classList.toggle('active', t.dataset.viewer === viewerName);
            });

            // Show correct viewer pane (edit uses grid pane)
            document.querySelectorAll('.viewer-pane').forEach(p => {
                p.classList.toggle('active', p.id === actualViewer + 'Viewer');
            });

            // Show/hide edit toolbar
            const toolbar = document.getElementById('editToolbar');
            toolbar.classList.toggle('visible', isEditMode);

            // Update edit palette when entering edit mode
            if (isEditMode && state.pattern) {
                updateEditPalette(state.pattern.gsMode);
            }

            // Initialize or update 3D viewer when switching to it
            if (actualViewer === '3d') {
                init3DViewer();
            }

            renderCurrentViewer();
        }

        function init3DViewer() {
            const container = document.getElementById('threeContainer');
            if (!container) return;

            // Create viewer if it doesn't exist
            if (!threeViewer) {
                threeViewer = new ThreeViewer(container);

                const config = state.arena.config;
                if (config) {
                    const specs = PANEL_SPECS[config.arena.generation];
                    threeViewer.init(config, specs);

                    // Set up frame change callback to sync with playback controls
                    threeViewer.onFrameChange((frameIndex) => {
                        state.editor.currentFrame = frameIndex;
                        updateFrameInfo();
                    });
                }
            }

            // Update pattern if one is loaded
            if (state.pattern && threeViewer) {
                threeViewer.setPattern(state.pattern);
                threeViewer.setFrame(state.editor.currentFrame);
            }
        }

        // ============================================
        // Pattern Loading/Saving
        // ============================================

        /**
         * Normalize pattern properties to use consistent naming
         * Parser returns gs_val, internal code uses gsMode
         */
        function normalizePattern(pattern) {
            return {
                ...pattern,
                gsMode: pattern.gs_val || pattern.gsMode || 16,
                // Keep gs_val for compatibility with encoder
                gs_val: pattern.gs_val || pattern.gsMode || 16
            };
        }

        async function handleFileLoad(e) {
            const file = e.target.files[0];
            if (!file) return;

            try {
                const buffer = await file.arrayBuffer();
                const pattern = normalizePattern(PatParser.parsePatFile(buffer));

                state.pattern = pattern;
                state.filename = file.name;
                state.isDirty = false;
                state.editor.currentFrame = 0;

                // Try to find matching arena config
                const matchingConfig = PatParser.findMatchingConfig(pattern, STANDARD_CONFIGS);
                if (matchingConfig) {
                    state.arena.configName = matchingConfig;
                    state.arena.config = getConfig(matchingConfig);
                    document.getElementById('arenaConfigStatus').value = matchingConfig;
                }

                // Lock arena config after loading pattern
                lockArenaConfig();

                updateStatus();
                renderCurrentViewer();
                updateFrameInfo();

                console.log('Loaded pattern:', pattern);
            } catch (err) {
                console.error('Failed to load pattern:', err);
                alert('Failed to load pattern file: ' + err.message);
            }

            e.target.value = ''; // Reset input
        }

        async function handleLoadPatternB(e) {
            const file = e.target.files[0];
            if (!file) return;

            try {
                const buffer = await file.arrayBuffer();
                state.combinePatternB = normalizePattern(PatParser.parsePatFile(buffer));
                state.combinePatternB.filename = file.name;

                updateCombineInfo();
                console.log('Loaded pattern B:', state.combinePatternB);
            } catch (err) {
                console.error('Failed to load pattern B:', err);
                alert('Failed to load pattern file: ' + err.message);
            }

            e.target.value = '';
        }

        function handleSave() {
            if (!state.pattern) {
                alert('No pattern to save');
                return;
            }

            // Convert state.pattern to format expected by PatEncoder
            const patternData = {
                generation: state.pattern.generation,
                gs_val: state.pattern.gsMode,
                numFrames: state.pattern.numFrames,
                rowCount: Math.floor(state.pattern.pixelRows / PANEL_SPECS[state.pattern.generation].pixels_per_panel),
                colCount: Math.floor(state.pattern.pixelCols / PANEL_SPECS[state.pattern.generation].pixels_per_panel),
                pixelRows: state.pattern.pixelRows,
                pixelCols: state.pattern.pixelCols,
                frames: state.pattern.frames,
                stretchValues: state.pattern.stretchValues || new Array(state.pattern.numFrames).fill(1)
            };

            // Build filename with arena config prefix
            const baseFilename = state.filename || 'pattern.pat';
            const filename = addArenaPrefix(baseFilename);
            PatEncoder.downloadPattern(patternData, filename);

            state.isDirty = false;
            state.filename = filename;  // Update to include prefix
            updateStatus();

            console.log('Saved pattern:', filename);
        }

        /**
         * Add arena config prefix to filename if not already present
         * Format: {configName}_{patternName}.pat
         * Example: G6_2x10_grating_20px.pat
         */
        function addArenaPrefix(filename) {
            const configName = state.arena.configName;
            if (!configName) return filename;

            // Remove .pat extension for processing
            const baseName = filename.replace(/\.pat$/i, '');

            // Check if filename already starts with a config prefix (e.g., G6_2x10_)
            // Config names look like: G6_2x10, G4_3x12, G41_2x12_cw, etc.
            const configPattern = /^(G\d+_?\d*_\d+x\d+[a-z]*_?[a-z]*)_/i;
            if (configPattern.test(baseName)) {
                // Already has a prefix, replace it with current config
                const newBase = baseName.replace(configPattern, configName + '_');
                return newBase + '.pat';
            }

            // No prefix, add one
            return configName + '_' + baseName + '.pat';
        }

        /**
         * Remove arena config prefix from filename (for display or editing)
         */
        function removeArenaPrefix(filename) {
            const baseName = filename.replace(/\.pat$/i, '');
            const configPattern = /^(G\d+_?\d*_\d+x\d+[a-z]*_?[a-z]*)_/i;
            const stripped = baseName.replace(configPattern, '');
            return stripped + '.pat';
        }

        function handleNew() {
            if (state.isDirty) {
                if (!confirm('Discard unsaved changes?')) return;
            }

            // Unlock arena config so user can choose different arena for new pattern
            unlockArenaConfig();

            const config = state.arena.config;
            if (!config) {
                alert('Please select an arena configuration first');
                return;
            }

            // Create empty single-frame pattern
            const pixelRows = config.arena.num_rows * PANEL_SPECS[config.arena.generation].pixels_per_panel;
            const pixelCols = config.arena.num_cols * PANEL_SPECS[config.arena.generation].pixels_per_panel;

            state.pattern = {
                generation: config.arena.generation,
                gsMode: 16,
                numFrames: 1,
                pixelRows: pixelRows,
                pixelCols: pixelCols,
                frames: [new Uint8Array(pixelRows * pixelCols)],
                stretchValues: [1]
            };

            state.filename = 'untitled.pat';
            state.isDirty = true;
            state.editor.currentFrame = 0;

            // Lock again after creating the new pattern
            lockArenaConfig();

            updateStatus();
            renderCurrentViewer();
            updateFrameInfo();
        }

        // ============================================
        // Pattern Generation
        // ============================================

        /**
         * Update UI visibility based on pattern type
         */
        function updatePatternTypeUI() {
            const patternType = document.getElementById('patternType').value;

            // Show/hide parameter sections
            const gratingParams = document.getElementById('gratingParams');
            const starfieldParams = document.getElementById('starfieldParams');
            const edgeParams = document.getElementById('edgeParams');
            const motionParams = document.getElementById('motionParams');
            const dutyCycleGroup = document.getElementById('dutyCycleGroup');
            const numFramesGroup = document.getElementById('numFramesGroup');
            const sphericalModeGroup = document.getElementById('sphericalModeGroup');
            const sphericalParams = document.getElementById('sphericalParams');

            // Reset visibility
            gratingParams.style.display = 'none';
            starfieldParams.style.display = 'none';
            edgeParams.style.display = 'none';
            motionParams.style.display = 'block';
            sphericalModeGroup.style.display = 'none';

            // Check if spherical mode is available for this pattern type
            const supportsSpherical = ['grating', 'sine'].includes(patternType);
            sphericalModeGroup.style.display = supportsSpherical ? 'block' : 'none';

            // Update spherical params visibility based on checkbox
            const useSpherical = document.getElementById('useSpherical').checked;
            sphericalParams.style.display = (supportsSpherical && useSpherical) ? 'block' : 'none';

            // Update spatial frequency label based on mode
            updateSpatialFreqLabel();

            switch (patternType) {
                case 'grating':
                    gratingParams.style.display = 'block';
                    dutyCycleGroup.style.display = 'block';
                    numFramesGroup.style.display = 'none';  // Auto-calculated from wavelength
                    break;
                case 'sine':
                    gratingParams.style.display = 'block';
                    dutyCycleGroup.style.display = 'none';  // No duty cycle for sine
                    numFramesGroup.style.display = 'none';  // Auto-calculated from wavelength
                    break;
                case 'starfield':
                    starfieldParams.style.display = 'block';
                    numFramesGroup.style.display = 'block';
                    updateNumFramesDefault();
                    break;
                case 'edge':
                    edgeParams.style.display = 'block';
                    numFramesGroup.style.display = 'block';
                    updateNumFramesDefault();
                    break;
                case 'off-on':
                    motionParams.style.display = 'none';  // No motion for off/on
                    break;
            }
        }

        /**
         * Update spatial frequency label based on spherical mode
         */
        function updateSpatialFreqLabel() {
            const useSpherical = document.getElementById('useSpherical').checked;
            const label = document.getElementById('spatialFreqLabel');
            const unitSelect = document.getElementById('spatialFreqUnit');

            if (useSpherical) {
                label.textContent = 'Spatial Frequency';
                // Show unit selector
                unitSelect.style.display = 'block';
            } else {
                label.textContent = 'Wavelength (pixels)';
                // Hide unit selector, force pixels
                unitSelect.style.display = 'none';
                unitSelect.value = 'px';
            }
        }

        /**
         * Convert spatial frequency value based on unit selection
         * @param {number} value - The input value
         * @param {string} unit - The unit ('px', 'rad', 'deg')
         * @param {number} pRad - Radians per pixel for the arena
         * @returns {number} Spatial frequency in radians
         */
        function convertSpatialFreqToRadians(value, unit, pRad) {
            switch (unit) {
                case 'px':
                    // Wavelength in pixels -> spatFreq in radians
                    // wavelength (px) * pRad = wavelength (rad)
                    return value * pRad;
                case 'rad':
                    return value;
                case 'deg':
                    return value * Math.PI / 180;
                default:
                    return value;
            }
        }

        /**
         * Update the default number of frames hint based on arena config
         */
        function updateNumFramesDefault() {
            const hint = document.getElementById('numFramesHint');
            if (state.arena.config) {
                const specs = PANEL_SPECS[state.arena.config.arena.generation];
                const pixelCols = state.arena.config.arena.num_cols * specs.pixels_per_panel;
                hint.textContent = `(360¬∞ = ${pixelCols})`;
                document.getElementById('numFramesInput').value = pixelCols;
            }
        }

        function handleGenerate() {
            const config = state.arena.config;
            if (!config) {
                alert('Please select an arena configuration first');
                return;
            }

            const patternType = document.getElementById('patternType').value;
            const gsMode = parseInt(document.getElementById('gsMode').value);
            const highLevel = parseInt(document.getElementById('highLevel').value);
            const lowLevel = parseInt(document.getElementById('lowLevel').value);

            // Build arena object for generator
            const arena = {
                generation: config.arena.generation,
                rows: config.arena.num_rows,
                cols: config.arena.num_cols
            };

            let params = {
                high: highLevel,
                low: lowLevel,
                gsMode: gsMode
            };

            let pattern;
            let filename;

            // Check if spherical mode is enabled
            const useSpherical = document.getElementById('useSpherical').checked &&
                                 ['grating', 'sine'].includes(patternType);

            try {
                switch (patternType) {
                    case 'grating':
                        if (useSpherical) {
                            // Spherical mode parameters
                            const spatialFreqValue = parseFloat(document.getElementById('spatialFreq').value);
                            const spatialFreqUnit = document.getElementById('spatialFreqUnit').value;
                            const specs = PANEL_SPECS[config.arena.generation];
                            const pRad = (2 * Math.PI) / (config.arena.num_cols * specs.pixels_per_panel);

                            params.spatFreq = convertSpatialFreqToRadians(spatialFreqValue, spatialFreqUnit, pRad);
                            params.motionType = document.getElementById('motionType').value;
                            params.waveform = 'square';
                            params.dutyCycle = parseInt(document.getElementById('dutyCycle').value);
                            params.direction = document.getElementById('direction').value;
                            params.stepSize = parseInt(document.getElementById('stepSize').value);
                            params.aaSamples = parseInt(document.getElementById('aaSamples').value);
                            params.arenaModel = document.getElementById('arenaModel').value;
                            params.poleCoord = [0, 0];  // Default pole at north

                            pattern = PatternGenerator.generateSphericalGrating(params, arena);

                            // Generate filename
                            const freqStr = spatialFreqUnit === 'px' ? `${spatialFreqValue}px` :
                                           spatialFreqUnit === 'rad' ? `${spatialFreqValue.toFixed(2)}rad` :
                                           `${spatialFreqValue}deg`;
                            filename = `sph_grating_${params.motionType}_${freqStr}_${params.dutyCycle}pct.pat`;
                        } else {
                            // Legacy flat mode
                            params.wavelength = parseInt(document.getElementById('spatialFreq').value);
                            params.dutyCycle = parseInt(document.getElementById('dutyCycle').value);
                            params.direction = document.getElementById('direction').value;
                            params.stepSize = parseInt(document.getElementById('stepSize').value);
                            pattern = PatternGenerator.generateGrating(params, arena);
                            filename = `grating_${params.wavelength}px_${params.dutyCycle}pct.pat`;
                        }
                        break;

                    case 'sine':
                        if (useSpherical) {
                            // Spherical mode parameters
                            const spatialFreqValue = parseFloat(document.getElementById('spatialFreq').value);
                            const spatialFreqUnit = document.getElementById('spatialFreqUnit').value;
                            const specs = PANEL_SPECS[config.arena.generation];
                            const pRad = (2 * Math.PI) / (config.arena.num_cols * specs.pixels_per_panel);

                            params.spatFreq = convertSpatialFreqToRadians(spatialFreqValue, spatialFreqUnit, pRad);
                            params.motionType = document.getElementById('motionType').value;
                            params.waveform = 'sine';
                            params.direction = document.getElementById('direction').value;
                            params.stepSize = parseInt(document.getElementById('stepSize').value);
                            params.aaSamples = parseInt(document.getElementById('aaSamples').value);
                            params.arenaModel = document.getElementById('arenaModel').value;
                            params.poleCoord = [0, 0];  // Default pole at north

                            pattern = PatternGenerator.generateSphericalGrating(params, arena);

                            // Generate filename
                            const freqStr = spatialFreqUnit === 'px' ? `${spatialFreqValue}px` :
                                           spatialFreqUnit === 'rad' ? `${spatialFreqValue.toFixed(2)}rad` :
                                           `${spatialFreqValue}deg`;
                            filename = `sph_sine_${params.motionType}_${freqStr}.pat`;
                        } else {
                            // Legacy flat mode
                            params.wavelength = parseInt(document.getElementById('spatialFreq').value);
                            params.direction = document.getElementById('direction').value;
                            params.stepSize = parseInt(document.getElementById('stepSize').value);
                            pattern = PatternGenerator.generateSine(params, arena);
                            filename = `sine_${params.wavelength}px.pat`;
                        }
                        break;

                    case 'starfield':
                        params.dotCount = parseInt(document.getElementById('dotCount').value);
                        params.dotSize = parseInt(document.getElementById('dotSize').value);
                        params.seed = parseInt(document.getElementById('starfieldSeed').value);
                        params.brightness = highLevel;
                        params.background = lowLevel;
                        params.direction = document.getElementById('direction').value;
                        params.stepSize = parseInt(document.getElementById('stepSize').value);
                        params.numFrames = parseInt(document.getElementById('numFramesInput').value);
                        pattern = PatternGenerator.generateStarfield(params, arena);
                        filename = `starfield_${params.dotCount}dots_${params.numFrames}f.pat`;
                        break;

                    case 'edge':
                        params.edgePosition = parseFloat(document.getElementById('edgePosition').value);
                        params.polarity = document.getElementById('edgePolarity').value;
                        params.direction = document.getElementById('direction').value;
                        params.stepSize = parseInt(document.getElementById('stepSize').value);
                        params.numFrames = parseInt(document.getElementById('numFramesInput').value);
                        pattern = PatternGenerator.generateEdge(params, arena);
                        filename = `edge_${params.polarity}_${params.numFrames}f.pat`;
                        break;

                    case 'off-on':
                        pattern = PatternGenerator.generateOffOn(params, arena);
                        filename = `off_on_${highLevel}.pat`;
                        break;

                    default:
                        alert(`Pattern type "${patternType}" not implemented yet`);
                        return;
                }

                // Validate generated pattern
                const validation = PatternGenerator.validate(pattern);
                if (!validation.valid) {
                    console.error('Pattern validation errors:', validation.errors);
                    alert('Generated pattern has errors:\n' + validation.errors.join('\n'));
                    return;
                }
                if (validation.warnings.length > 0) {
                    console.warn('Pattern validation warnings:', validation.warnings);
                }

                // Convert to state.pattern format
                state.pattern = {
                    generation: pattern.generation,
                    gsMode: pattern.gs_val,
                    numFrames: pattern.numFrames,
                    pixelRows: pattern.pixelRows,
                    pixelCols: pattern.pixelCols,
                    frames: pattern.frames,
                    stretchValues: pattern.stretchValues
                };

                state.filename = filename;
                state.isDirty = true;
                state.editor.currentFrame = 0;

                // Lock arena config after generating pattern
                lockArenaConfig();

                updateStatus();
                renderCurrentViewer();
                updateFrameInfo();

                console.log('Generated pattern:', patternType, params, state.pattern);

            } catch (err) {
                console.error('Pattern generation error:', err);
                alert('Failed to generate pattern: ' + err.message);
            }
        }

        // ============================================
        // Frame Operations
        // ============================================
        function captureFrame() {
            if (!state.pattern) {
                alert('No pattern loaded');
                return;
            }

            const frameData = state.pattern.frames[state.editor.currentFrame];
            const frameCopy = new Uint8Array(frameData);

            // Generate thumbnail canvas
            const thumbnail = generateThumbnail(
                frameCopy,
                state.pattern.pixelRows,
                state.pattern.pixelCols,
                state.pattern.gsMode
            );

            const clipboardEntry = {
                id: Date.now(),
                frame: frameCopy,
                thumbnail: thumbnail,
                timestamp: new Date(),
                name: `Frame ${state.clipboard.length + 1}`,
                pixelRows: state.pattern.pixelRows,
                pixelCols: state.pattern.pixelCols,
                gsMode: state.pattern.gsMode,
                generation: state.pattern.generation
            };

            state.clipboard.push(clipboardEntry);
            updateClipboardUI();

            console.log('Captured frame to clipboard:', clipboardEntry.name);
        }

        function generateThumbnail(frameData, pixelRows, pixelCols, gsMode) {
            const canvas = document.createElement('canvas');
            const thumbSize = 40;
            canvas.width = thumbSize;
            canvas.height = thumbSize;
            const ctx = canvas.getContext('2d');

            // Calculate scaling
            const scaleX = thumbSize / pixelCols;
            const scaleY = thumbSize / pixelRows;
            const maxVal = gsMode === 2 ? 1 : 15;

            // Draw pixels
            for (let row = 0; row < pixelRows; row++) {
                for (let col = 0; col < pixelCols; col++) {
                    const value = frameData[row * pixelCols + col];
                    const brightness = value / maxVal;

                    const r = Math.round(brightness * 0.6 * 255);
                    const g = Math.round(brightness * 255);
                    const b = Math.round(brightness * 0.2 * 255);

                    ctx.fillStyle = brightness > 0 ? `rgb(${r},${g},${b})` : '#1e2329';

                    // Flip Y so row 0 is at bottom
                    const canvasY = (pixelRows - 1 - row) * scaleY;
                    ctx.fillRect(col * scaleX, canvasY, Math.ceil(scaleX), Math.ceil(scaleY));
                }
            }

            return canvas;
        }

        function updateClipboardUI() {
            const container = document.getElementById('clipboardThumbnails');
            const countEl = document.getElementById('clipboardCount');
            const prevBtn = document.getElementById('clipboardPrev');
            const nextBtn = document.getElementById('clipboardNext');

            countEl.textContent = `${state.clipboard.length} frame${state.clipboard.length !== 1 ? 's' : ''}`;

            if (state.clipboard.length === 0) {
                container.innerHTML = '<div class="clipboard-empty">Capture frames to build sequences</div>';
                prevBtn.disabled = true;
                nextBtn.disabled = true;
                state.selectedClipboardIds = [];
                return;
            }

            const maxVisible = 5;
            const startIdx = state.clipboardOffset;
            const endIdx = Math.min(startIdx + maxVisible, state.clipboard.length);

            prevBtn.disabled = startIdx === 0;
            nextBtn.disabled = endIdx >= state.clipboard.length;

            container.innerHTML = '';
            for (let i = startIdx; i < endIdx; i++) {
                const entry = state.clipboard[i];
                const thumb = document.createElement('div');
                thumb.className = 'clipboard-thumb';
                if (state.selectedClipboardIds && state.selectedClipboardIds.includes(entry.id)) {
                    thumb.classList.add('selected');
                }
                thumb.title = `${entry.name}\n${formatTimestamp(entry.timestamp)}\nClick to select, double-click to edit`;

                // Use actual thumbnail if available
                if (entry.thumbnail) {
                    thumb.appendChild(entry.thumbnail.cloneNode(true));
                    thumb.style.padding = '0';
                } else {
                    thumb.textContent = (i + 1).toString();
                }

                // Single click: toggle selection for sequence building
                thumb.addEventListener('click', (e) => {
                    e.stopPropagation();
                    toggleClipboardSelection(entry.id);
                });

                // Double click: send to editor
                thumb.addEventListener('dblclick', (e) => {
                    e.stopPropagation();
                    sendClipboardFrameToEditor(entry.id);
                });

                // Right-click context menu
                thumb.addEventListener('contextmenu', (e) => {
                    e.preventDefault();
                    showClipboardContextMenu(e, entry);
                });

                container.appendChild(thumb);
            }
        }

        function toggleClipboardSelection(id) {
            if (!state.selectedClipboardIds) {
                state.selectedClipboardIds = [];
            }

            const idx = state.selectedClipboardIds.indexOf(id);
            if (idx >= 0) {
                state.selectedClipboardIds.splice(idx, 1);
            } else {
                state.selectedClipboardIds.push(id);
            }

            updateClipboardUI();
            console.log('Selected clipboard frames:', state.selectedClipboardIds.length);
        }

        function sendClipboardFrameToEditor(id) {
            const entry = state.clipboard.find(e => e.id === id);
            if (!entry) return;

            // Create a single-frame pattern from this clipboard entry
            state.pattern = {
                generation: entry.generation || 'G6',
                gsMode: entry.gsMode,
                numFrames: 1,
                pixelRows: entry.pixelRows,
                pixelCols: entry.pixelCols,
                frames: [new Uint8Array(entry.frame)],
                stretchValues: [1]
            };

            state.editor.editingClipboardId = id;
            state.editor.currentFrame = 0;
            state.filename = `${entry.name}.pat`;
            state.isDirty = false;

            // Switch to edit view
            setActiveViewer('edit');

            updateStatus();
            updateFrameInfo();

            console.log('Loaded clipboard frame for editing:', entry.name);
        }

        function updateClipboardFromEditor() {
            if (!state.editor.editingClipboardId || !state.pattern) {
                alert('No clipboard frame is currently being edited');
                return;
            }

            const entry = state.clipboard.find(e => e.id === state.editor.editingClipboardId);
            if (!entry) {
                alert('Original clipboard entry not found');
                return;
            }

            // Update the clipboard entry with edited frame data
            entry.frame = new Uint8Array(state.pattern.frames[state.editor.currentFrame]);
            entry.thumbnail = generateThumbnail(
                entry.frame,
                entry.pixelRows,
                entry.pixelCols,
                entry.gsMode
            );
            entry.timestamp = new Date();

            updateClipboardUI();
            console.log('Updated clipboard frame:', entry.name);
        }

        function deleteClipboardEntry(id) {
            const idx = state.clipboard.findIndex(e => e.id === id);
            if (idx >= 0) {
                state.clipboard.splice(idx, 1);

                // Clear editing reference if we deleted the one being edited
                if (state.editor.editingClipboardId === id) {
                    state.editor.editingClipboardId = null;
                }

                // Remove from selection
                if (state.selectedClipboardIds) {
                    const selIdx = state.selectedClipboardIds.indexOf(id);
                    if (selIdx >= 0) {
                        state.selectedClipboardIds.splice(selIdx, 1);
                    }
                }

                // Adjust scroll offset if needed
                if (state.clipboardOffset > 0 && state.clipboardOffset >= state.clipboard.length) {
                    state.clipboardOffset = Math.max(0, state.clipboard.length - 5);
                }

                updateClipboardUI();
            }
        }

        function showClipboardContextMenu(e, entry) {
            // Remove existing context menu
            const existingMenu = document.getElementById('clipboardContextMenu');
            if (existingMenu) existingMenu.remove();

            const menu = document.createElement('div');
            menu.id = 'clipboardContextMenu';
            menu.style.cssText = `
                position: fixed;
                left: ${e.clientX}px;
                top: ${e.clientY}px;
                background: var(--surface);
                border: 1px solid var(--border);
                border-radius: 4px;
                padding: 0.25rem 0;
                z-index: 1000;
                min-width: 120px;
            `;

            const menuItems = [
                { label: 'Edit', action: () => sendClipboardFrameToEditor(entry.id) },
                { label: 'Rename...', action: () => renameClipboardEntry(entry) },
                { label: 'Delete', action: () => deleteClipboardEntry(entry.id) }
            ];

            menuItems.forEach(item => {
                const menuItem = document.createElement('div');
                menuItem.textContent = item.label;
                menuItem.style.cssText = `
                    padding: 0.4rem 0.75rem;
                    cursor: pointer;
                    font-size: 0.75rem;
                    color: var(--text);
                `;
                menuItem.addEventListener('mouseenter', () => {
                    menuItem.style.background = 'var(--accent)';
                    menuItem.style.color = 'var(--bg)';
                });
                menuItem.addEventListener('mouseleave', () => {
                    menuItem.style.background = 'transparent';
                    menuItem.style.color = 'var(--text)';
                });
                menuItem.addEventListener('click', () => {
                    menu.remove();
                    item.action();
                });
                menu.appendChild(menuItem);
            });

            document.body.appendChild(menu);

            // Close menu when clicking elsewhere
            const closeMenu = () => {
                menu.remove();
                document.removeEventListener('click', closeMenu);
            };
            setTimeout(() => document.addEventListener('click', closeMenu), 0);
        }

        function renameClipboardEntry(entry) {
            const newName = prompt('Enter new name:', entry.name);
            if (newName && newName.trim()) {
                entry.name = newName.trim();
                updateClipboardUI();
            }
        }

        function scrollClipboard(direction) {
            const maxVisible = 5;
            if (direction < 0) {
                state.clipboardOffset = Math.max(0, state.clipboardOffset - 1);
            } else {
                state.clipboardOffset = Math.min(
                    Math.max(0, state.clipboard.length - maxVisible),
                    state.clipboardOffset + 1
                );
            }
            updateClipboardUI();
        }

        function formatTimestamp(date) {
            const diff = Date.now() - date.getTime();
            const minutes = Math.floor(diff / 60000);
            if (minutes < 1) return 'just now';
            if (minutes < 60) return `${minutes}m ago`;
            const hours = Math.floor(minutes / 60);
            if (hours < 24) return `${hours}h ago`;
            return date.toLocaleDateString();
        }

        // ============================================
        // Playback
        // ============================================
        function togglePlayback() {
            if (state.playback.isPlaying) {
                stopPlayback();
            } else {
                startPlayback();
            }
        }

        function startPlayback() {
            if (!state.pattern || state.pattern.numFrames <= 1) return;

            state.playback.isPlaying = true;
            document.getElementById('playBtn').textContent = '‚è∏';

            // Use absolute value of fps for interval, direction from sign
            const fps = state.playback.fps;
            const interval = 1000 / Math.abs(fps);
            const direction = fps >= 0 ? 1 : -1;

            state.playback.intervalId = setInterval(() => {
                navigateFrame(direction);
            }, interval);
        }

        function stopPlayback() {
            state.playback.isPlaying = false;
            document.getElementById('playBtn').textContent = '‚ñ∂';

            if (state.playback.intervalId) {
                clearInterval(state.playback.intervalId);
                state.playback.intervalId = null;
            }
        }

        function navigateFrame(delta) {
            if (!state.pattern) return;

            let newFrame = state.editor.currentFrame + delta;
            if (newFrame >= state.pattern.numFrames) newFrame = 0;
            if (newFrame < 0) newFrame = state.pattern.numFrames - 1;

            goToFrame(newFrame);
        }

        function goToFrame(frameIndex) {
            if (!state.pattern) return;

            state.editor.currentFrame = frameIndex;
            updateFrameInfo();
            renderCurrentViewer();
        }

        function updateFrameInfo() {
            const frameInfo = document.getElementById('frameInfo');
            const stretchInput = document.getElementById('stretchValue');
            if (state.pattern) {
                frameInfo.textContent = `${state.editor.currentFrame + 1} / ${state.pattern.numFrames}`;
                // Update stretch value display
                const stretch = state.pattern.stretchValues?.[state.editor.currentFrame] || 1;
                stretchInput.value = stretch;
            } else {
                frameInfo.textContent = '‚Äî / ‚Äî';
                stretchInput.value = 1;
            }
        }

        function handleStretchChange(e) {
            if (!state.pattern) return;

            const newStretch = parseInt(e.target.value);
            if (isNaN(newStretch) || newStretch < 1) {
                e.target.value = 1;
                return;
            }

            // Initialize stretchValues if not present
            if (!state.pattern.stretchValues) {
                state.pattern.stretchValues = new Array(state.pattern.numFrames).fill(1);
            }

            state.pattern.stretchValues[state.editor.currentFrame] = newStretch;
            state.isDirty = true;
            updateStatus();
            console.log(`Set frame ${state.editor.currentFrame} stretch to ${newStretch}`);
        }

        // ============================================
        // Edit Mode Functions
        // ============================================
        function initEditPalette() {
            const palette = document.getElementById('editPalette');
            palette.innerHTML = '';

            // Default to GS16 (0-15)
            for (let i = 0; i <= 15; i++) {
                const swatch = document.createElement('div');
                swatch.className = 'palette-swatch';
                swatch.dataset.value = i;

                const brightness = i / 15;
                const r = Math.round(brightness * 0.6 * 255);
                const g = Math.round(brightness * 255);
                const b = Math.round(brightness * 0.2 * 255);
                swatch.style.background = brightness > 0 ? `rgb(${r},${g},${b})` : '#1e2329';
                swatch.style.color = i < 8 ? '#888' : '#000';
                swatch.textContent = i;

                if (i === 15) swatch.classList.add('selected');

                swatch.addEventListener('click', () => selectDrawColor(i));
                palette.appendChild(swatch);
            }
        }

        function updateEditPalette(gsMode) {
            const palette = document.getElementById('editPalette');
            const maxVal = gsMode === 2 ? 1 : 15;

            palette.innerHTML = '';

            for (let i = 0; i <= maxVal; i++) {
                const swatch = document.createElement('div');
                swatch.className = 'palette-swatch';
                swatch.dataset.value = i;

                const brightness = i / maxVal;
                const r = Math.round(brightness * 0.6 * 255);
                const g = Math.round(brightness * 255);
                const b = Math.round(brightness * 0.2 * 255);
                swatch.style.background = brightness > 0 ? `rgb(${r},${g},${b})` : '#1e2329';

                if (gsMode === 2) {
                    swatch.textContent = i === 0 ? 'Off' : 'On';
                    swatch.style.width = '40px';
                    swatch.style.fontSize = '0.6rem';
                } else {
                    swatch.textContent = i;
                    swatch.style.color = i < 8 ? '#888' : '#000';
                }

                if (i === maxVal) swatch.classList.add('selected');

                swatch.addEventListener('click', () => selectDrawColor(i));
                palette.appendChild(swatch);
            }

            // Adjust current color if needed
            if (state.editor.drawColor > maxVal) {
                state.editor.drawColor = maxVal;
            }
            document.getElementById('currentColorDisplay').textContent = state.editor.drawColor;
        }

        function selectDrawColor(value) {
            state.editor.drawColor = value;

            document.querySelectorAll('.edit-palette .palette-swatch').forEach(s => {
                s.classList.toggle('selected', parseInt(s.dataset.value) === value);
            });

            document.getElementById('currentColorDisplay').textContent = value;
        }

        function handleCanvasClick(e) {
            if (!state.editor.editMode || !state.pattern) return;

            const canvas = document.getElementById('gridCanvas');
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            const { pixelRows, pixelCols } = state.pattern;
            const pixelSize = canvas.width / pixelCols;

            const col = Math.floor(x / pixelSize);
            // Flip Y: canvas Y=0 is top, but row 0 is bottom
            const row = pixelRows - 1 - Math.floor(y / pixelSize);

            if (col >= 0 && col < pixelCols && row >= 0 && row < pixelRows) {
                setPixel(row, col, state.editor.drawColor);
            }
        }

        function handleCanvasMouseMove(e) {
            if (!state.editor.editMode || !state.pattern || e.buttons !== 1) return;
            handleCanvasClick(e);
        }

        function setPixel(row, col, value) {
            if (!state.pattern) return;

            const { pixelCols, frames } = state.pattern;
            const frame = frames[state.editor.currentFrame];
            const idx = row * pixelCols + col;

            frame[idx] = value;
            state.isDirty = true;
            updateStatus();
            renderCurrentViewer();
        }

        function fillRow(row) {
            if (!state.pattern || !state.editor.editMode) return;

            const { pixelCols, frames } = state.pattern;
            const frame = frames[state.editor.currentFrame];

            for (let col = 0; col < pixelCols; col++) {
                frame[row * pixelCols + col] = state.editor.drawColor;
            }

            state.isDirty = true;
            updateStatus();
            renderCurrentViewer();
        }

        function fillColumn(col) {
            if (!state.pattern || !state.editor.editMode) return;

            const { pixelRows, pixelCols, frames } = state.pattern;
            const frame = frames[state.editor.currentFrame];

            for (let row = 0; row < pixelRows; row++) {
                frame[row * pixelCols + col] = state.editor.drawColor;
            }

            state.isDirty = true;
            updateStatus();
            renderCurrentViewer();
        }

        function flipHorizontal() {
            if (!state.pattern) return;

            const { pixelRows, pixelCols, frames } = state.pattern;
            const frame = frames[state.editor.currentFrame];

            for (let row = 0; row < pixelRows; row++) {
                for (let col = 0; col < Math.floor(pixelCols / 2); col++) {
                    const leftIdx = row * pixelCols + col;
                    const rightIdx = row * pixelCols + (pixelCols - 1 - col);
                    const temp = frame[leftIdx];
                    frame[leftIdx] = frame[rightIdx];
                    frame[rightIdx] = temp;
                }
            }

            state.isDirty = true;
            updateStatus();
            renderCurrentViewer();
        }

        function flipVertical() {
            if (!state.pattern) return;

            const { pixelRows, pixelCols, frames } = state.pattern;
            const frame = frames[state.editor.currentFrame];

            for (let row = 0; row < Math.floor(pixelRows / 2); row++) {
                for (let col = 0; col < pixelCols; col++) {
                    const topIdx = row * pixelCols + col;
                    const bottomIdx = (pixelRows - 1 - row) * pixelCols + col;
                    const temp = frame[topIdx];
                    frame[topIdx] = frame[bottomIdx];
                    frame[bottomIdx] = temp;
                }
            }

            state.isDirty = true;
            updateStatus();
            renderCurrentViewer();
        }

        function invertBrightness() {
            if (!state.pattern) return;

            const { pixelRows, pixelCols, gsMode, frames } = state.pattern;
            const frame = frames[state.editor.currentFrame];
            const maxVal = gsMode === 2 ? 1 : 15;

            for (let i = 0; i < frame.length; i++) {
                frame[i] = maxVal - frame[i];
            }

            state.isDirty = true;
            updateStatus();
            renderCurrentViewer();
        }

        function applyFindReplace() {
            if (!state.pattern) return;

            const findVal = parseInt(document.getElementById('findValue').value);
            const replaceVal = parseInt(document.getElementById('replaceValue').value);
            const { frames } = state.pattern;
            const frame = frames[state.editor.currentFrame];

            let count = 0;
            for (let i = 0; i < frame.length; i++) {
                if (frame[i] === findVal) {
                    frame[i] = replaceVal;
                    count++;
                }
            }

            document.getElementById('findReplaceModal').classList.remove('visible');

            if (count > 0) {
                state.isDirty = true;
                updateStatus();
                renderCurrentViewer();
                console.log(`Replaced ${count} pixels: ${findVal} -> ${replaceVal}`);
            } else {
                console.log(`No pixels found with value ${findVal}`);
            }
        }

        // ============================================
        // Combine Operations
        // ============================================
        function handleSetPatternA() {
            if (!state.pattern) {
                alert('No current pattern to use');
                return;
            }
            // Deep copy the pattern to prevent changes from affecting the combine slot
            state.combinePatternA = {
                ...state.pattern,
                frames: state.pattern.frames.map(f => new Uint8Array(f)),
                filename: state.filename || 'Current pattern'
            };
            updateCombineInfo();
            console.log('Set Pattern A from current:', state.combinePatternA.filename);
        }

        async function handleLoadPatternA(e) {
            const file = e.target.files[0];
            if (!file) return;

            try {
                const buffer = await file.arrayBuffer();
                state.combinePatternA = normalizePattern(PatParser.parsePatFile(buffer));
                state.combinePatternA.filename = file.name;

                updateCombineInfo();
                console.log('Loaded pattern A:', state.combinePatternA);
            } catch (err) {
                console.error('Failed to load pattern A:', err);
                alert('Failed to load pattern file: ' + err.message);
            }

            e.target.value = '';
        }

        function handleClearPatternA() {
            state.combinePatternA = null;
            updateCombineInfo();
            console.log('Cleared Pattern A');
        }

        function handleSetPatternB() {
            if (!state.pattern) {
                alert('No current pattern to use');
                return;
            }
            // Deep copy the pattern to prevent changes from affecting the combine slot
            state.combinePatternB = {
                ...state.pattern,
                frames: state.pattern.frames.map(f => new Uint8Array(f)),
                filename: state.filename || 'Current pattern'
            };
            updateCombineInfo();
            console.log('Set Pattern B from current:', state.combinePatternB.filename);
        }

        function handleClearPatternB() {
            state.combinePatternB = null;
            updateCombineInfo();
            console.log('Cleared Pattern B');
        }

        function handleSwap() {
            const temp = state.combinePatternA;
            state.combinePatternA = state.combinePatternB;
            state.combinePatternB = temp;

            updateCombineInfo();
            console.log('Swapped Pattern A and B');
        }

        function updateCombineModeUI() {
            const mode = document.getElementById('combineMode').value;

            // Hide all mode-specific options
            document.getElementById('combineMaskOptions').style.display = 'none';
            document.getElementById('combineSplitOptions').style.display = 'none';

            // Show length options only for non-sequential modes AND when patterns have different lengths
            const lengthOptions = document.getElementById('combineLengthOptions');
            const showLengthOptions = mode !== 'sequential' &&
                state.combinePatternA && state.combinePatternB &&
                state.combinePatternA.numFrames !== state.combinePatternB.numFrames;
            lengthOptions.style.display = showLengthOptions ? 'block' : 'none';

            // Show mode-specific options
            if (mode === 'mask') {
                document.getElementById('combineMaskOptions').style.display = 'block';
            } else if (mode === 'split-h' || mode === 'split-v') {
                document.getElementById('combineSplitOptions').style.display = 'block';
                updateSplitPositionDisplay();
            }
        }

        function updateSplitPositionDisplay() {
            const percent = parseInt(document.getElementById('splitPosition').value);
            document.getElementById('splitPositionPercent').textContent = percent + '%';

            // Calculate pixel position based on pattern dimensions and split direction
            const mode = document.getElementById('combineMode').value;
            let pixelText = 'pixel ‚Äî';

            if (state.combinePatternA) {
                if (mode === 'split-h') {
                    const totalPixels = state.combinePatternA.pixelCols;
                    const pixelPos = Math.floor(totalPixels * percent / 100);
                    pixelText = `pixel ${pixelPos} / ${totalPixels}`;
                } else if (mode === 'split-v') {
                    const totalPixels = state.combinePatternA.pixelRows;
                    const pixelPos = Math.floor(totalPixels * percent / 100);
                    pixelText = `pixel ${pixelPos} / ${totalPixels}`;
                }
            }

            document.getElementById('splitPositionPixel').textContent = pixelText;
        }

        function handleCombine() {
            if (!state.combinePatternA) {
                alert('Set or load Pattern A first');
                return;
            }
            if (!state.combinePatternB) {
                alert('Set or load Pattern B first');
                return;
            }

            const mode = document.getElementById('combineMode').value;
            const lengthHandling = document.getElementById('lengthHandling').value;

            try {
                let options = {};
                let combineMode = mode;

                // Parse mode-specific options
                if (mode === 'mask') {
                    options.mode = 'threshold';
                    options.threshold = parseInt(document.getElementById('maskThreshold').value);
                    combineMode = 'mask';
                } else if (mode === 'blend') {
                    options.mode = 'blend';
                    combineMode = 'blend';
                } else if (mode === 'split-h') {
                    options.direction = 'horizontal';
                    options.splitPosition = parseInt(document.getElementById('splitPosition').value) / 100;
                    combineMode = 'split';
                } else if (mode === 'split-v') {
                    options.direction = 'vertical';
                    options.splitPosition = parseInt(document.getElementById('splitPosition').value) / 100;
                    combineMode = 'split';
                }

                // Handle different frame counts
                let patternA = state.combinePatternA;
                let patternB = state.combinePatternB;

                if (combineMode !== 'sequential' && patternA.numFrames !== patternB.numFrames) {
                    const maxFrames = Math.max(patternA.numFrames, patternB.numFrames);
                    const minFrames = Math.min(patternA.numFrames, patternB.numFrames);

                    if (lengthHandling === 'truncate') {
                        // Truncate both to shorter length
                        patternA = truncatePattern(patternA, minFrames);
                        patternB = truncatePattern(patternB, minFrames);
                    } else if (lengthHandling === 'extend') {
                        // Extend shorter pattern by repeating last frame
                        patternA = extendPattern(patternA, maxFrames);
                        patternB = extendPattern(patternB, maxFrames);
                    }
                    // 'loop' is the default behavior in combiner.js
                }

                const combined = combinePatterns(patternA, patternB, combineMode, options);

                state.pattern = combined;
                state.isDirty = true;

                // Generate suggested filename based on combine mode and input patterns
                const nameA = getBaseName(state.combinePatternA.filename || 'patternA');
                const nameB = getBaseName(state.combinePatternB.filename || 'patternB');
                let modeSuffix;
                switch (combineMode) {
                    case 'sequential': modeSuffix = 'seq'; break;
                    case 'blend': modeSuffix = 'blend'; break;
                    case 'mask': modeSuffix = 'mask'; break;
                    case 'split-h': modeSuffix = `splitH${options.splitPosition || 50}`; break;
                    case 'split-v': modeSuffix = `splitV${options.splitPosition || 50}`; break;
                    default: modeSuffix = 'combined';
                }
                state.filename = `${nameA}_${nameB}_${modeSuffix}.pat`;

                state.editor.currentFrame = 0;

                updateStatus();
                renderCurrentViewer();
                updateFrameInfo();
                updateCombineInfo();

                console.log('Combined pattern:', combined);
            } catch (err) {
                alert('Combine failed: ' + err.message);
                console.error('Combine error:', err);
            }
        }

        /**
         * Get base name without extension from a filename
         */
        function getBaseName(filename) {
            if (!filename) return 'pattern';
            // Remove .pat extension and path
            let name = filename.replace(/\.pat$/i, '');
            // Remove any path components
            const lastSlash = Math.max(name.lastIndexOf('/'), name.lastIndexOf('\\'));
            if (lastSlash >= 0) {
                name = name.substring(lastSlash + 1);
            }
            // Truncate to reasonable length for combined names
            if (name.length > 20) {
                name = name.substring(0, 20);
            }
            return name;
        }

        /**
         * Truncate a pattern to specified number of frames
         */
        function truncatePattern(pattern, numFrames) {
            if (pattern.numFrames <= numFrames) return pattern;
            return {
                ...pattern,
                frames: pattern.frames.slice(0, numFrames),
                numFrames: numFrames
            };
        }

        /**
         * Extend a pattern by repeating last frame
         */
        function extendPattern(pattern, numFrames) {
            if (pattern.numFrames >= numFrames) return pattern;
            const newFrames = [...pattern.frames];
            const lastFrame = pattern.frames[pattern.frames.length - 1];
            while (newFrames.length < numFrames) {
                newFrames.push(new Uint8Array(lastFrame)); // Copy last frame
            }
            return {
                ...pattern,
                frames: newFrames,
                numFrames: numFrames
            };
        }

        /**
         * Update the default total frames based on direction and arena config
         */
        function updateDefaultFrames() {
            const direction = document.getElementById('rotateDirection').value;
            const framesInput = document.getElementById('totalFrames');
            const framesHint = document.getElementById('framesHint');

            // Get pixel dimensions from arena config or clipboard entry
            let pixelCols = 200;  // Default
            let pixelRows = 60;   // Default

            if (state.arena.config) {
                const specs = PANEL_SPECS[state.arena.config.arena.generation];
                pixelCols = state.arena.config.arena.num_cols * specs.pixels_per_panel;
                pixelRows = state.arena.config.arena.num_rows * specs.pixels_per_panel;
            } else if (state.clipboard.length > 0) {
                // Fallback to clipboard entry dimensions
                pixelCols = state.clipboard[0].pixelCols;
                pixelRows = state.clipboard[0].pixelRows;
            }

            let defaultFrames;
            let hint;
            if (direction.startsWith('h-')) {
                // Horizontal motion: full 360¬∞ loop
                defaultFrames = pixelCols;
                hint = `(360¬∞ = ${pixelCols} px)`;
            } else {
                // Vertical motion: full vertical traverse
                defaultFrames = pixelRows;
                hint = `(full height = ${pixelRows} px)`;
            }

            framesInput.value = defaultFrames;
            framesHint.textContent = hint;
        }

        function handleBuildSequence() {
            if (state.clipboard.length === 0) {
                alert('Capture some frames first');
                return;
            }

            // Get selected frames, or use all if none selected
            let selectedEntries;
            if (state.selectedClipboardIds && state.selectedClipboardIds.length > 0) {
                selectedEntries = state.clipboard.filter(e =>
                    state.selectedClipboardIds.includes(e.id)
                );
            } else {
                // Use the first clipboard entry if none selected
                selectedEntries = [state.clipboard[0]];
            }

            if (selectedEntries.length === 0) {
                alert('No frames selected');
                return;
            }

            // Get motion parameters from UI
            const stepSize = parseInt(document.getElementById('rotateStep').value) || 1;
            const direction = document.getElementById('rotateDirection').value;
            const totalFrames = parseInt(document.getElementById('totalFrames').value) || 200;

            // Use the first selected frame as the base
            const baseEntry = selectedEntries[0];
            const { pixelRows, pixelCols, gsMode, generation } = baseEntry;

            // Build motion sequence based on direction
            const frames = [];
            const isHorizontal = direction.startsWith('h-');
            const isPositive = direction === 'h-cw' || direction === 'v-up';

            for (let f = 0; f < totalFrames; f++) {
                const offset = (isPositive ? f : -f) * stepSize;
                let shiftedFrame;
                if (isHorizontal) {
                    shiftedFrame = shiftFrameHorizontally(baseEntry.frame, pixelCols, pixelRows, offset);
                } else {
                    shiftedFrame = shiftFrameVertically(baseEntry.frame, pixelCols, pixelRows, offset);
                }
                frames.push(shiftedFrame);
            }

            // Create new pattern from sequence
            state.pattern = {
                generation: generation || 'G6',
                gsMode: gsMode,
                numFrames: totalFrames,
                pixelRows: pixelRows,
                pixelCols: pixelCols,
                frames: frames,
                stretchValues: new Array(totalFrames).fill(1)
            };

            // Generate filename based on motion type
            const dirLabel = direction.replace('-', '_');
            state.filename = `${baseEntry.name}_${dirLabel}_${totalFrames}f.pat`;
            state.isDirty = true;
            state.editor.currentFrame = 0;
            state.editor.editingClipboardId = null;

            // Clear selection
            state.selectedClipboardIds = [];
            updateClipboardUI();

            // Switch to 2D view (exit edit mode if active)
            setActiveViewer('grid');

            updateStatus();
            updateFrameInfo();

            console.log(`Generated motion sequence: ${totalFrames} frames, step=${stepSize}px, direction=${direction}`);
        }

        /**
         * Shift frame horizontally (wrap around)
         */
        function shiftFrameHorizontally(frameData, pixelCols, pixelRows, offset) {
            const shifted = new Uint8Array(frameData.length);

            // Normalize offset to be positive and within bounds
            offset = ((offset % pixelCols) + pixelCols) % pixelCols;

            for (let row = 0; row < pixelRows; row++) {
                for (let col = 0; col < pixelCols; col++) {
                    const srcCol = (col + offset) % pixelCols;
                    shifted[row * pixelCols + col] = frameData[row * pixelCols + srcCol];
                }
            }

            return shifted;
        }

        /**
         * Shift frame vertically (wrap around)
         * Positive offset = pattern shifts upward on screen
         */
        function shiftFrameVertically(frameData, pixelCols, pixelRows, offset) {
            const shifted = new Uint8Array(frameData.length);

            // Normalize offset to be positive and within bounds
            offset = ((offset % pixelRows) + pixelRows) % pixelRows;

            for (let row = 0; row < pixelRows; row++) {
                const srcRow = (row + offset) % pixelRows;
                for (let col = 0; col < pixelCols; col++) {
                    shifted[row * pixelCols + col] = frameData[srcRow * pixelCols + col];
                }
            }

            return shifted;
        }

        // Legacy alias for backwards compatibility
        function rotateFrameHorizontally(frameData, pixelCols, pixelRows, offset) {
            return shiftFrameHorizontally(frameData, pixelCols, pixelRows, offset);
        }

        // ============================================
        // Rendering
        // ============================================
        function renderCurrentViewer() {
            if (state.editor.activeViewer === 'grid') {
                renderGridViewer();
            } else if (state.editor.activeViewer === '3d') {
                render3DViewer();
            }
        }

        function render3DViewer() {
            if (!threeViewer) {
                init3DViewer();
                return;
            }

            if (state.pattern) {
                // Ensure arena config matches pattern dimensions
                const patternGen = state.pattern.generation;
                const patternSpecs = PANEL_SPECS[patternGen];
                const patternCols = state.pattern.pixelCols / patternSpecs.pixels_per_panel;
                const patternRows = state.pattern.pixelRows / patternSpecs.pixels_per_panel;

                // Check if current arena config matches pattern
                const currentConfig = state.arena.config;
                const needsReinit = !currentConfig ||
                    currentConfig.arena.generation !== patternGen ||
                    currentConfig.arena.num_cols !== patternCols ||
                    currentConfig.arena.num_rows !== patternRows;

                if (needsReinit) {
                    // Try to find matching config
                    const matchingConfig = findMatchingArenaConfig(patternGen, patternCols, patternRows);
                    if (matchingConfig) {
                        state.arena.configName = matchingConfig;
                        state.arena.config = getConfig(matchingConfig);
                        document.getElementById('arenaConfigStatus').value = matchingConfig;
                        threeViewer.reinit(state.arena.config, patternSpecs);
                    }
                }

                threeViewer.setPattern(state.pattern);
                threeViewer.setFrame(state.editor.currentFrame);
            }
        }

        // Find arena config that matches pattern dimensions
        function findMatchingArenaConfig(generation, numCols, numRows) {
            for (const [name, config] of Object.entries(ARENA_CONFIGS)) {
                if (config.arena.generation === generation &&
                    config.arena.num_cols === numCols &&
                    config.arena.num_rows === numRows) {
                    return name;
                }
            }
            return null;
        }

        function renderGridViewer() {
            const container = document.getElementById('gridViewer');

            if (!state.pattern) {
                container.innerHTML = `
                    <div class="placeholder">
                        <div class="placeholder-icon">‚¨ö</div>
                        <h2>No Pattern Loaded</h2>
                        <p>Load a .pat file or generate a new pattern to view it here.</p>
                    </div>
                `;
                return;
            }

            const { pixelRows, pixelCols, frames, gsMode } = state.pattern;
            const frame = frames[state.editor.currentFrame];

            // Calculate pixel size to fit in viewer
            const headerSize = state.editor.editMode ? 24 : 0;
            const maxWidth = container.clientWidth - 40 - headerSize;
            const maxHeight = container.clientHeight - 40 - headerSize;
            const pixelSize = Math.max(1, Math.min(
                Math.floor(maxWidth / pixelCols),
                Math.floor(maxHeight / pixelRows)
            ));

            // Create or update container structure based on edit mode
            if (state.editor.editMode) {
                container.innerHTML = `
                    <div class="grid-with-headers" style="width: ${pixelCols * pixelSize + headerSize}px;">
                        <div class="corner-spacer"></div>
                        <div class="col-headers" id="colHeaders" style="display: flex;"></div>
                        <div class="row-headers" id="rowHeaders" style="display: flex; flex-direction: column;"></div>
                        <div class="grid-canvas-container">
                            <canvas id="gridCanvas"></canvas>
                        </div>
                    </div>
                `;

                // Create column headers
                const colHeaders = document.getElementById('colHeaders');
                for (let col = 0; col < pixelCols; col++) {
                    const header = document.createElement('div');
                    header.className = 'col-header';
                    header.style.width = pixelSize + 'px';
                    header.style.height = '24px';
                    header.textContent = col % 10 === 0 ? col : '';
                    header.title = `Fill column ${col}`;
                    header.addEventListener('click', () => fillColumn(col));
                    colHeaders.appendChild(header);
                }

                // Create row headers (row 0 at bottom)
                const rowHeaders = document.getElementById('rowHeaders');
                for (let row = pixelRows - 1; row >= 0; row--) {
                    const header = document.createElement('div');
                    header.className = 'row-header';
                    header.style.width = '24px';
                    header.style.height = pixelSize + 'px';
                    header.textContent = row % 10 === 0 ? row : '';
                    header.title = `Fill row ${row}`;
                    header.addEventListener('click', () => fillRow(row));
                    rowHeaders.appendChild(header);
                }
            } else {
                // Non-edit mode: simple canvas container
                let canvasContainer = container.querySelector('.grid-canvas-container');
                if (!canvasContainer || container.querySelector('.grid-with-headers')) {
                    container.innerHTML = '<div class="grid-canvas-container"><canvas id="gridCanvas"></canvas></div>';
                }
            }

            const canvas = document.getElementById('gridCanvas');
            const ctx = canvas.getContext('2d');

            canvas.width = pixelCols * pixelSize;
            canvas.height = pixelRows * pixelSize;

            // Add mouse handlers for edit mode
            if (state.editor.editMode) {
                canvas.style.cursor = 'crosshair';
                canvas.onmousedown = handleCanvasClick;
                canvas.onmousemove = handleCanvasMouseMove;
            } else {
                canvas.style.cursor = 'default';
                canvas.onmousedown = null;
                canvas.onmousemove = null;
            }

            // Draw pixels (row 0 = bottom)
            const maxVal = gsMode === 2 ? 1 : 15;
            for (let row = 0; row < pixelRows; row++) {
                for (let col = 0; col < pixelCols; col++) {
                    const value = frame[row * pixelCols + col];
                    const brightness = value / maxVal;

                    // Green phosphor color
                    const r = Math.round(brightness * 0.6 * 255);
                    const g = Math.round(brightness * 255);
                    const b = Math.round(brightness * 0.2 * 255);

                    ctx.fillStyle = brightness > 0 ? `rgb(${r},${g},${b})` : '#1e2329';

                    // Flip Y so row 0 is at bottom
                    const canvasY = (pixelRows - 1 - row) * pixelSize;
                    ctx.fillRect(col * pixelSize, canvasY, pixelSize, pixelSize);
                }
            }

            // Draw grid lines in edit mode for better visibility
            if (state.editor.editMode && pixelSize >= 4) {
                ctx.strokeStyle = 'rgba(45, 54, 64, 0.5)';
                ctx.lineWidth = 1;
                for (let row = 0; row <= pixelRows; row++) {
                    ctx.beginPath();
                    ctx.moveTo(0, row * pixelSize);
                    ctx.lineTo(canvas.width, row * pixelSize);
                    ctx.stroke();
                }
                for (let col = 0; col <= pixelCols; col++) {
                    ctx.beginPath();
                    ctx.moveTo(col * pixelSize, 0);
                    ctx.lineTo(col * pixelSize, canvas.height);
                    ctx.stroke();
                }
            }

            // Draw panel boundaries
            if (state.editor.showPanelBoundaries && state.arena.config) {
                const pixelsPerPanel = PANEL_SPECS[state.arena.config.arena.generation].pixels_per_panel;

                ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.lineWidth = 1;

                // Vertical lines
                for (let col = pixelsPerPanel; col < pixelCols; col += pixelsPerPanel) {
                    ctx.beginPath();
                    ctx.moveTo(col * pixelSize, 0);
                    ctx.lineTo(col * pixelSize, canvas.height);
                    ctx.stroke();
                }

                // Horizontal lines
                for (let row = pixelsPerPanel; row < pixelRows; row += pixelsPerPanel) {
                    const canvasY = (pixelRows - row) * pixelSize;
                    ctx.beginPath();
                    ctx.moveTo(0, canvasY);
                    ctx.lineTo(canvas.width, canvasY);
                    ctx.stroke();
                }
            }

            // Draw panel numbers
            if (state.editor.showPanelNumbers && state.arena.config) {
                const pixelsPerPanel = PANEL_SPECS[state.arena.config.arena.generation].pixels_per_panel;
                const panelCols = state.arena.config.arena.num_cols;
                const panelRows = state.arena.config.arena.num_rows;

                // Calculate font size based on panel size in pixels
                const panelPixelWidth = pixelsPerPanel * pixelSize;
                const fontSize = Math.max(14, Math.floor(panelPixelWidth * 0.4)); // Larger font

                ctx.fillStyle = '#ff0000'; // Pure red for visibility
                ctx.font = `bold ${fontSize}px JetBrains Mono`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';

                let panelNum = 1;
                for (let pc = 0; pc < panelCols; pc++) {
                    for (let pr = 0; pr < panelRows; pr++) {
                        const centerX = (pc + 0.5) * pixelsPerPanel * pixelSize;
                        const centerY = (panelRows - pr - 0.5) * pixelsPerPanel * pixelSize;
                        ctx.fillText(panelNum.toString(), centerX, centerY);
                        panelNum++;
                    }
                }
            }
        }

        // ============================================
        // Status Updates
        // ============================================
        function updateStatus() {
            document.getElementById('statusFilename').textContent = state.filename || 'No pattern';

            if (state.pattern) {
                document.getElementById('statusDimensions').textContent =
                    `${state.pattern.pixelCols} √ó ${state.pattern.pixelRows} px`;
                document.getElementById('statusFrames').textContent =
                    `${state.pattern.numFrames} frame${state.pattern.numFrames !== 1 ? 's' : ''}`;
                document.getElementById('statusGsMode').textContent =
                    state.pattern.gsMode === 2 ? 'GS2' : 'GS16';
            } else {
                document.getElementById('statusDimensions').textContent = '‚Äî';
                document.getElementById('statusFrames').textContent = '‚Äî';
                document.getElementById('statusGsMode').textContent = '‚Äî';
            }

            document.getElementById('statusUnsaved').textContent = state.isDirty ? 'Unsaved*' : '';
        }

        function updateCombineInfo() {
            // Update Pattern A info
            if (state.combinePatternA) {
                const name = state.combinePatternA.filename || 'Unnamed pattern';
                document.getElementById('patternAInfo').textContent =
                    `${name} (${state.combinePatternA.pixelCols}√ó${state.combinePatternA.pixelRows}, ${state.combinePatternA.numFrames} frames)`;
            } else {
                document.getElementById('patternAInfo').textContent = 'No pattern set';
            }

            // Update Pattern B info
            if (state.combinePatternB) {
                const name = state.combinePatternB.filename || 'Unnamed pattern';
                document.getElementById('patternBInfo').textContent =
                    `${name} (${state.combinePatternB.pixelCols}√ó${state.combinePatternB.pixelRows}, ${state.combinePatternB.numFrames} frames)`;
            } else {
                document.getElementById('patternBInfo').textContent = 'No pattern set';
            }

            // Update length options visibility based on current mode and patterns
            updateCombineModeUI();
        }

        /**
         * Update Save/Load button states based on arena generation
         * G3 format is not supported for .pat files
         */
        function updateG3ButtonStates() {
            const loadBtn = document.getElementById('loadBtn');
            const saveBtn = document.getElementById('saveBtn');

            // Check if current arena or pattern is G3
            const isG3Arena = state.arena.config && state.arena.config.arena.generation === 'G3';
            const isG3Pattern = state.pattern && state.pattern.generation === 'G3';

            if (isG3Arena || isG3Pattern) {
                loadBtn.disabled = true;
                saveBtn.disabled = true;
                loadBtn.title = 'G3 .pat format not supported';
                saveBtn.title = 'G3 .pat format not supported';
                loadBtn.style.opacity = '0.5';
                saveBtn.style.opacity = '0.5';
            } else {
                loadBtn.disabled = false;
                saveBtn.disabled = false;
                loadBtn.title = 'Load .pat file';
                saveBtn.title = 'Save as .pat file';
                loadBtn.style.opacity = '1';
                saveBtn.style.opacity = '1';
            }
        }

        // ============================================
        // Arena Config Lock/Unlock
        // ============================================
        function lockArenaConfig() {
            state.arena.locked = true;
            const select = document.getElementById('arenaConfigStatus');
            const lockBtn = document.getElementById('arenaLockBtn');
            select.disabled = true;
            lockBtn.textContent = 'üîí';
            lockBtn.classList.add('locked');
            lockBtn.title = 'Arena config locked (click to unlock)';
        }

        function unlockArenaConfig() {
            state.arena.locked = false;
            const select = document.getElementById('arenaConfigStatus');
            const lockBtn = document.getElementById('arenaLockBtn');
            select.disabled = false;
            lockBtn.textContent = 'üîì';
            lockBtn.classList.remove('locked');
            lockBtn.title = 'Lock arena config';
        }

        function toggleArenaLock() {
            if (state.arena.locked) {
                // Warn if pattern exists
                if (state.pattern) {
                    const confirmed = confirm(
                        'Warning: Changing the arena config while a pattern is loaded may cause dimension mismatches.\n\n' +
                        'Are you sure you want to unlock the arena config?'
                    );
                    if (!confirmed) return;
                }
                unlockArenaConfig();
            } else {
                lockArenaConfig();
            }
        }

        // ============================================
        // Helper: Get configs grouped by generation
        // ============================================
        function getConfigsByGeneration() {
            const grouped = {};
            for (const name of Object.keys(STANDARD_CONFIGS)) {
                const config = STANDARD_CONFIGS[name];
                const gen = config.arena.generation;
                if (!grouped[gen]) grouped[gen] = [];
                grouped[gen].push(name);
            }
            return grouped;
        }

        function getConfig(name) {
            return STANDARD_CONFIGS[name] || null;
        }

        // ============================================
        // Initialize
        // ============================================
        document.addEventListener('DOMContentLoaded', () => {
            initUI();
            updateClipboardUI();
            updateDefaultFrames();  // Set initial frames based on default arena
            updatePatternTypeUI();  // Set initial pattern type UI visibility
            updateG3ButtonStates(); // Disable save/load for G3 arenas
        });
    </script>
</body>
</html>
