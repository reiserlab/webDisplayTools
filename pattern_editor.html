<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pattern Editor - PanelDisplayTools</title>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700&family=IBM+Plex+Mono:wght@400;600&display=swap" rel="stylesheet">
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.182.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.182.0/examples/jsm/"
            }
        }
    </script>
    <!-- arena-configs.js loaded as ES6 module to support dual-export pattern -->
    <script type="module">
        import { STANDARD_CONFIGS, PANEL_SPECS, getConfig, getConfigsByGeneration, getArenaId, getArenaName, getGenerationId, getGenerationName } from './js/arena-configs.js';
        // Make available globally for other scripts
        window.STANDARD_CONFIGS = STANDARD_CONFIGS;
        window.PANEL_SPECS = PANEL_SPECS;
        window.getConfig = getConfig;
        window.getConfigsByGeneration = getConfigsByGeneration;
        // Signal that arena configs are loaded
        window.dispatchEvent(new Event('arenaConfigsLoaded'));
    </script>
    <script src="js/pat-encoder.js"></script>
    <script src="js/arena-geometry.js"></script>
    <script src="js/pattern-editor/tools/generator.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        :root {
            --bg: #0f1419;
            --surface: #1a1f26;
            --border: #2d3640;
            --text: #e6edf3;
            --text-dim: #8b949e;
            --accent: #00e676;
            --hover: #00c853;
            --warning: #ff9800;
            --led-off: #1e2329;
        }

        body {
            font-family: 'IBM Plex Mono', monospace;
            background: var(--bg);
            color: var(--text);
            height: 100vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        /* Development Banner */
        .dev-banner {
            background: linear-gradient(90deg, var(--warning), #f57c00);
            color: var(--bg);
            text-align: center;
            padding: 0.5rem;
            font-size: 0.8rem;
            font-weight: 600;
            font-family: 'JetBrains Mono', monospace;
        }

        .dev-banner a {
            color: var(--bg);
            text-decoration: underline;
        }

        /* Main Layout */
        .app-container {
            display: flex;
            flex: 1;
            overflow: hidden;
        }

        /* Generate Button Column - between tools and viewer */
        .generate-column {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 4px 2px;
            background: var(--bg);
            border-right: 1px solid var(--border);
            width: 35px;  /* 25% wider: 28px * 1.25 = 35px */
            min-width: 35px;
        }

        .generate-btn-vertical {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 3px;
            padding: 10px 6px;
            font-size: 14px;  /* Increased from 11px */
            font-weight: 800;  /* Bolder */
            font-family: 'JetBrains Mono', monospace;
            background: var(--accent);
            color: var(--bg);
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.15s ease;
            line-height: 1.1;
        }

        .generate-btn-vertical:hover {
            background: var(--hover);
        }

        .generate-btn-vertical .arrow {
            font-size: 18px;  /* Increased from 12px - bigger arrows */
            font-weight: 900;
        }

        .generate-btn-vertical .letter {
            display: block;
        }

        /* Left Panel - Tools */
        .tools-panel {
            width: 320px;
            min-width: 320px;
            background: var(--surface);
            border-right: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .tools-header {
            padding: 1rem 1.25rem;
            border-bottom: 1px solid var(--border);
        }

        .tools-header h1 {
            font-family: 'JetBrains Mono', monospace;
            font-size: 1.1rem;
            color: var(--accent);
            margin-bottom: 0.25rem;
        }

        .tools-header .subtitle {
            font-size: 0.7rem;
            color: var(--text-dim);
        }

        /* Tool Tabs */
        .tool-tabs {
            display: flex;
            border-bottom: 1px solid var(--border);
            background: var(--bg);
        }

        .tool-tab {
            flex: 1;
            padding: 0.7rem 0.5rem;
            background: transparent;
            border: none;
            border-bottom: 2px solid transparent;
            color: var(--text-dim);
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.7rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .tool-tab:hover {
            color: var(--text);
            background: var(--surface);
        }

        .tool-tab.active {
            color: var(--accent);
            border-bottom-color: var(--accent);
            background: var(--surface);
        }

        /* Tool Content */
        .tool-content {
            flex: 1;
            overflow-y: auto;
            padding: 1rem 1.25rem;
        }

        .tool-pane {
            display: none;
        }

        .tool-pane.active {
            display: block;
        }

        /* Animate Tab Mode Toggle */
        .animate-mode-toggle {
            display: flex;
            gap: 4px;
            margin-bottom: 1rem;
            background: var(--bg);
            padding: 4px;
            border-radius: 6px;
        }

        .animate-mode-toggle .mode-btn {
            flex: 1;
            padding: 0.5rem 0.75rem;
            background: transparent;
            border: none;
            border-radius: 4px;
            color: var(--text-dim);
            font-size: 0.75rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.15s;
        }

        .animate-mode-toggle .mode-btn:hover {
            color: var(--text);
        }

        .animate-mode-toggle .mode-btn.active {
            background: var(--accent);
            color: var(--bg);
        }

        .animate-mode-content {
            display: none;
        }

        .animate-mode-content.active {
            display: block;
        }

        /* Frame Sequence Builder */
        .frame-sequence-builder {
            background: var(--bg);
            border: 1px dashed var(--border);
            border-radius: 6px;
            padding: 0.75rem;
            min-height: 80px;
        }

        .sequence-empty {
            color: var(--text-dim);
            font-size: 0.75rem;
            text-align: center;
            padding: 1rem;
        }

        .sequence-frames {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
        }

        .sequence-frame {
            width: 56px;
            height: 56px;
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: grab;
            position: relative;
            font-size: 0.7rem;
            color: var(--text-dim);
            transition: transform 0.15s ease, opacity 0.15s ease;
        }

        .sequence-frame:hover {
            border-color: var(--accent);
        }

        .sequence-frame.selected {
            border-color: var(--accent);
            box-shadow: 0 0 6px rgba(0, 230, 118, 0.4);
            background: rgba(0, 230, 118, 0.1);
        }

        .sequence-frame.dragging {
            opacity: 0.5;
            border-color: var(--accent);
            box-shadow: 0 0 10px rgba(0, 230, 118, 0.5);
            transform: scale(1.05);
            cursor: grabbing;
        }

        .sequence-frame.drag-over {
            border-color: var(--accent);
            border-style: dashed;
            background: rgba(0, 230, 118, 0.15);
        }

        .sequence-frame canvas,
        .sequence-frame img {
            width: 100%;
            height: 100%;
            border-radius: 3px;
            object-fit: contain;
        }

        .sequence-frame .remove-btn {
            position: absolute;
            top: -5px;
            right: -5px;
            width: 16px;
            height: 16px;
            background: #ff4444;
            color: white;
            border: none;
            border-radius: 50%;
            font-size: 10px;
            cursor: pointer;
            display: none;
            align-items: center;
            justify-content: center;
        }

        .sequence-frame:hover .remove-btn {
            display: flex;
        }

        /* Combine Tab Thumbnails */
        .combine-pattern-preview {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            padding: 0.5rem;
            background: var(--bg);
            border-radius: 4px;
            margin-bottom: 0.5rem;
        }

        .combine-pattern-thumbnail {
            width: 56px;
            height: 56px;
            flex-shrink: 0;
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
        }

        .combine-pattern-thumbnail img,
        .combine-pattern-thumbnail canvas {
            width: 100%;
            height: 100%;
            object-fit: contain;
        }

        .combine-pattern-thumbnail.empty {
            color: var(--text-dim);
            font-size: 1.5rem;
        }

        .combine-pattern-info {
            flex: 1;
            min-width: 0;
        }

        .combine-pattern-name {
            font-size: 0.8rem;
            color: var(--text);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            margin-bottom: 0.25rem;
        }

        .combine-pattern-dims {
            font-size: 0.7rem;
            color: var(--text-dim);
        }

        .section-title {
            font-size: 0.65rem;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            color: var(--text-dim);
            margin-bottom: 0.75rem;
            font-weight: 600;
        }

        .control-group {
            margin-bottom: 1rem;
        }

        .control-group label {
            display: block;
            font-size: 0.7rem;
            color: var(--text-dim);
            margin-bottom: 0.3rem;
        }

        .control-group select,
        .control-group input[type="number"] {
            width: 100%;
            padding: 0.5rem 0.6rem;
            background: var(--bg);
            border: 1px solid var(--border);
            border-radius: 4px;
            color: var(--text);
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.8rem;
        }

        .control-group select:focus,
        .control-group input:focus {
            outline: none;
            border-color: var(--accent);
        }

        /* Compact control layouts */
        .control-row {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 0.75rem;
        }

        .control-group.half {
            flex: 1;
            margin-bottom: 0;
        }

        .control-group.third {
            flex: 1;
            margin-bottom: 0;
        }

        .control-row .control-group label {
            font-size: 0.65rem;
        }

        .control-row .control-group input {
            padding: 0.4rem;
            font-size: 0.75rem;
        }

        /* Clipboard Bar - Tabbed design with Frames left, Patterns right */
        .clipboard-bar {
            display: flex;
            align-items: stretch;
            background: var(--bg);
            border-top: 1px solid var(--border);
            min-height: 60px;
        }

        .clipboard-tab {
            padding: 8px 16px;
            background: var(--surface);
            border: none;
            cursor: pointer;
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: var(--text-dim);
            display: flex;
            align-items: center;
            gap: 6px;
            transition: all 0.15s;
        }

        .clipboard-tab:hover {
            background: var(--hover-dim, #2a3540);
            color: var(--text);
        }

        .clipboard-tab.active {
            background: var(--accent);
            color: var(--bg);
        }

        .clipboard-tab .count {
            font-size: 10px;
            opacity: 0.8;
        }

        .clipboard-tab.active .count {
            opacity: 1;
        }

        .clipboard-content-area {
            flex: 1;
            display: flex;
            align-items: center;
            padding: 4px 12px;
            overflow: hidden;
            background: var(--surface);
        }

        .clipboard-content {
            display: none;
            flex: 1;
            gap: 6px;
            overflow-x: auto;
            padding: 4px 0;
            scrollbar-width: thin;
            scrollbar-color: var(--border) transparent;
            align-items: center;
        }

        .clipboard-content.active {
            display: flex;
        }

        .clipboard-content::-webkit-scrollbar {
            height: 4px;
        }

        .clipboard-content::-webkit-scrollbar-track {
            background: transparent;
        }

        .clipboard-content::-webkit-scrollbar-thumb {
            background: var(--border);
            border-radius: 2px;
        }

        .clipboard-content::-webkit-scrollbar-thumb:hover {
            background: var(--text-dim);
        }

        .clipboard-thumb {
            width: 52px;
            height: 52px;
            min-width: 52px;
            background: var(--bg);
            border: 2px solid var(--border);
            border-radius: 4px;
            cursor: pointer;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.6rem;
            color: var(--text-dim);
        }

        .clipboard-thumb:hover {
            border-color: var(--accent);
        }

        .clipboard-thumb.selected {
            border-color: var(--accent);
            box-shadow: 0 0 8px rgba(0, 230, 118, 0.3);
        }

        .clipboard-thumb.loaded {
            border-color: var(--accent);
        }

        .clipboard-thumb .loaded-badge {
            position: absolute;
            top: 2px;
            left: 2px;
            background: var(--accent);
            color: #000;
            font-size: 7px;
            font-weight: bold;
            padding: 1px 3px;
            border-radius: 2px;
            z-index: 5;
        }

        .clipboard-thumb img {
            width: 100%;
            height: 100%;
            border-radius: 2px;
            object-fit: cover;
        }

        .clipboard-thumb canvas {
            width: 100%;
            height: 100%;
            border-radius: 2px;
        }

        .clipboard-thumb .delete-btn {
            position: absolute;
            top: -6px;
            right: -6px;
            width: 16px;
            height: 16px;
            background: #ff4444;
            color: white;
            border: none;
            border-radius: 50%;
            font-size: 10px;
            font-weight: bold;
            cursor: pointer;
            display: none;
            align-items: center;
            justify-content: center;
            line-height: 1;
            padding: 0;
            z-index: 10;
        }

        .clipboard-thumb:hover .delete-btn {
            display: flex;
        }

        .clipboard-thumb .delete-btn:hover {
            background: #ff0000;
        }

        .clipboard-empty {
            color: var(--text-dim);
            font-size: 11px;
            font-style: italic;
            padding: 8px 0;
            white-space: nowrap;
        }

        /* Pattern item in clipboard (for patterns with names) */
        .clipboard-pattern-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 6px 10px;
            background: var(--bg);
            border: 1px solid var(--border);
            border-radius: 4px;
            cursor: pointer;
            min-width: 120px;
            max-width: 180px;
        }

        .clipboard-pattern-item:hover {
            border-color: var(--accent);
        }

        .clipboard-pattern-item.selected {
            border-color: var(--accent);
            box-shadow: 0 0 8px rgba(0, 230, 118, 0.3);
        }

        .clipboard-pattern-item .pattern-name {
            flex: 1;
            font-size: 11px;
            color: var(--text);
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .clipboard-pattern-item .pattern-name:focus {
            outline: none;
            background: var(--surface);
            padding: 2px 4px;
            margin: -2px -4px;
            border-radius: 2px;
        }

        .clipboard-pattern-item .pattern-frames {
            font-size: 10px;
            color: var(--text-dim);
            white-space: nowrap;
        }

        .clipboard-pattern-item .delete-btn {
            width: 14px;
            height: 14px;
            background: transparent;
            color: var(--text-dim);
            border: none;
            border-radius: 50%;
            font-size: 12px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0;
            opacity: 0;
            transition: opacity 0.15s;
        }

        .clipboard-pattern-item:hover .delete-btn {
            opacity: 1;
        }

        .clipboard-pattern-item .delete-btn:hover {
            color: #ff4444;
        }

        /* Animated thumbnail for pattern items */
        .clipboard-pattern-item .pattern-thumbnail {
            width: 36px;
            height: 36px;
            border-radius: 4px;
            overflow: hidden;
            flex-shrink: 0;
            position: relative;
            background: var(--bg);
        }

        .clipboard-pattern-item .pattern-thumbnail img {
            width: 100%;
            height: 100%;
            object-fit: contain;
            border-radius: 4px;
        }

        /* Frame count badge on thumbnail */
        .clipboard-pattern-item .pattern-thumbnail .frame-badge {
            position: absolute;
            bottom: 1px;
            right: 1px;
            background: rgba(0, 0, 0, 0.7);
            color: var(--accent);
            font-size: 8px;
            padding: 1px 3px;
            border-radius: 2px;
            font-family: 'JetBrains Mono', monospace;
        }

        /* File Operations */
        .file-operations {
            padding: 1rem 1.25rem;
            border-top: 1px solid var(--border);
            background: var(--surface);
        }

        .arena-select-row {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 0.75rem;
        }

        .arena-select-row label {
            font-size: 0.7rem;
            color: var(--text-dim);
            align-self: center;
            white-space: nowrap;
        }

        .arena-select-row select {
            flex: 1;
            padding: 0.4rem 0.5rem;
            background: var(--bg);
            border: 1px solid var(--border);
            border-radius: 4px;
            color: var(--text);
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.75rem;
        }

        .file-buttons {
            display: flex;
            gap: 0.5rem;
        }

        .btn {
            flex: 1;
            padding: 0.6rem;
            background: var(--accent);
            border: none;
            border-radius: 4px;
            color: var(--bg);
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.75rem;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.2s;
        }

        .btn:hover {
            background: var(--hover);
        }

        .btn.secondary {
            background: var(--bg);
            border: 1px solid var(--border);
            color: var(--text);
        }

        .btn.secondary:hover {
            border-color: var(--accent);
            color: var(--accent);
        }

        /* ========================================
           Preview Mode - Tool panels locked
           ======================================== */
        .tools-panel.preview-mode .tool-content {
            position: relative;
            pointer-events: none;
            opacity: 0.45;
        }
        .tools-panel.preview-mode .tool-tabs {
            pointer-events: auto;
            opacity: 1;
        }
        .tools-panel.preview-mode .file-operations {
            pointer-events: auto;
            opacity: 1;
        }
        .generate-column.preview-mode .generate-btn-vertical {
            pointer-events: none;
            opacity: 0.3;
            cursor: not-allowed;
        }
        .preview-mode-banner {
            display: none;
            padding: 0.5rem 0.75rem;
            margin-bottom: 0.75rem;
            background: rgba(255, 152, 0, 0.15);
            border: 1px solid rgba(255, 152, 0, 0.3);
            border-radius: 4px;
            color: var(--warning, #ff9800);
            font-size: 0.7rem;
            font-weight: 600;
            text-align: center;
            letter-spacing: 0.5px;
            pointer-events: auto;
        }
        .tools-panel.preview-mode .preview-mode-banner {
            display: block;
        }

        /* Right Panel - Viewer */
        .viewer-panel {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        /* Viewer Tabs */
        .viewer-tabs {
            display: flex;
            padding: 0.75rem 1rem;
            gap: 0.5rem;
            border-bottom: 1px solid var(--border);
            background: var(--surface);
        }

        .viewer-tab {
            padding: 0.5rem 1rem;
            background: var(--bg);
            border: 1px solid var(--border);
            border-radius: 4px;
            color: var(--text-dim);
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.75rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        .help-button {
            width: 32px;
            height: 32px;
            padding: 0;
            background: var(--bg);
            border: 1px solid var(--border);
            border-radius: 50%;
            color: var(--accent);
            font-family: 'JetBrains Mono', monospace;
            font-size: 1.1rem;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-left: auto;
        }

        .help-button:hover {
            background: var(--accent);
            color: var(--bg);
            border-color: var(--accent);
        }

        .quick-start-btn {
            padding: 2px 6px;
            background: var(--accent);
            border: none;
            border-radius: 3px;
            color: var(--bg);
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.6rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            margin-left: 0.25rem;
            line-height: 1.1;
            text-align: center;
        }

        .quick-start-btn:hover {
            background: var(--hover);
        }

        .viewer-tab:hover {
            border-color: var(--accent);
            color: var(--text);
        }

        .viewer-tab.active {
            background: rgba(0, 230, 118, 0.1);
            border-color: var(--accent);
            color: var(--accent);
        }

        .viewer-tab.disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }

        .viewer-options {
            margin-left: auto;
            display: flex;
            gap: 1rem;
            align-items: center;
        }

        .viewer-options label {
            display: flex;
            align-items: center;
            gap: 0.4rem;
            font-size: 0.7rem;
            color: var(--text-dim);
            cursor: pointer;
        }

        .viewer-options input[type="checkbox"] {
            accent-color: var(--accent);
        }

        /* Viewer Content */
        .viewer-content {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            background: var(--bg);
            position: relative;
            overflow: hidden;
        }

        .viewer-pane {
            display: none;
            width: 100%;
            height: 100%;
        }

        .viewer-pane.active {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        /* Grid Viewer */
        #gridViewer {
            position: relative;
        }

        .grid-canvas-container {
            position: relative;
        }

        #gridCanvas {
            border: 1px solid var(--border);
            cursor: crosshair;
        }

        /* Edit Mode Toggle */
        .edit-mode-toggle {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .edit-toggle-btn {
            padding: 0.4rem 0.8rem;
            background: var(--bg);
            border: 1px solid var(--border);
            border-radius: 4px;
            color: var(--text-dim);
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.7rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        .edit-toggle-btn:hover {
            border-color: var(--accent);
            color: var(--text);
        }

        .edit-toggle-btn.active {
            background: rgba(0, 230, 118, 0.15);
            border-color: var(--accent);
            color: var(--accent);
        }

        /* Edit Toolbar */
        .edit-toolbar {
            display: none;
            padding: 0.5rem 1rem;
            background: var(--surface);
            border-bottom: 1px solid var(--border);
            gap: 1rem;
            align-items: center;
            flex-wrap: wrap;
        }

        .edit-toolbar.visible {
            display: flex;
        }

        .toolbar-section {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .toolbar-label {
            font-size: 0.65rem;
            color: var(--text-dim);
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        /* Palette in Edit Mode */
        .edit-palette {
            display: flex;
            gap: 2px;
        }

        .palette-swatch {
            width: 20px;
            height: 20px;
            border: 2px solid var(--border);
            border-radius: 2px;
            cursor: pointer;
            transition: all 0.15s;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.55rem;
            font-weight: 700;
            font-family: 'JetBrains Mono', monospace;
        }

        .palette-swatch:hover {
            transform: scale(1.15);
            border-color: var(--accent);
        }

        .palette-swatch.selected {
            border: 2px solid var(--accent);
            box-shadow: 0 0 8px var(--accent);
        }

        .current-color-display {
            font-size: 0.75rem;
            color: var(--accent);
            font-weight: 600;
            min-width: 30px;
        }

        /* Edit Operations */
        .edit-ops-btn {
            padding: 0.35rem 0.6rem;
            background: var(--bg);
            border: 1px solid var(--border);
            border-radius: 3px;
            color: var(--text-dim);
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.65rem;
            cursor: pointer;
            transition: all 0.15s;
        }

        .edit-ops-btn:hover {
            border-color: var(--accent);
            color: var(--accent);
        }

        /* Find/Replace Modal */
        .modal-overlay {
            display: none;
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.7);
            z-index: 100;
            align-items: center;
            justify-content: center;
        }

        .modal-overlay.visible {
            display: flex;
        }

        .modal-content {
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 1.5rem;
            min-width: 300px;
        }

        .modal-title {
            font-family: 'JetBrains Mono', monospace;
            font-size: 1rem;
            color: var(--accent);
            margin-bottom: 1rem;
        }

        .modal-row {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            margin-bottom: 0.75rem;
        }

        .modal-row label {
            font-size: 0.75rem;
            color: var(--text-dim);
            min-width: 60px;
        }

        .modal-row input {
            flex: 1;
            padding: 0.4rem 0.6rem;
            background: var(--bg);
            border: 1px solid var(--border);
            border-radius: 4px;
            color: var(--text);
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.8rem;
        }

        .modal-row input:focus {
            outline: none;
            border-color: var(--accent);
        }

        .modal-buttons {
            display: flex;
            gap: 0.5rem;
            margin-top: 1rem;
            justify-content: flex-end;
        }

        .modal-btn {
            padding: 0.5rem 1rem;
            border-radius: 4px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.75rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        .modal-btn.primary {
            background: var(--accent);
            border: none;
            color: var(--bg);
        }

        .modal-btn.primary:hover {
            background: var(--hover);
        }

        .modal-btn.secondary {
            background: transparent;
            border: 1px solid var(--border);
            color: var(--text);
        }

        .modal-btn.secondary:hover {
            border-color: var(--accent);
            color: var(--accent);
        }

        /* Row/Column Headers for Edit Mode */
        .grid-with-headers {
            display: grid;
            grid-template-columns: 24px 1fr;
            grid-template-rows: 24px 1fr;
            gap: 2px;
        }

        .row-header, .col-header {
            display: flex;
            align-items: center;
            justify-content: center;
            background: var(--surface);
            cursor: pointer;
            font-size: 0.5rem;
            color: var(--text-dim);
            transition: all 0.15s;
        }

        .row-header:hover, .col-header:hover {
            background: var(--accent);
            color: var(--bg);
        }

        .corner-spacer {
            background: var(--surface);
        }

        /* Placeholder content */
        .placeholder {
            text-align: center;
            color: var(--text-dim);
        }

        .placeholder-icon {
            font-size: 4rem;
            margin-bottom: 1rem;
            opacity: 0.3;
        }

        .placeholder h2 {
            font-family: 'JetBrains Mono', monospace;
            font-size: 1.2rem;
            color: var(--text);
            margin-bottom: 0.5rem;
        }

        .placeholder p {
            font-size: 0.85rem;
            max-width: 400px;
            line-height: 1.5;
        }

        /* Playback Controls */
        .playback-controls {
            display: flex;
            align-items: center;
            gap: 1rem;
            padding: 0.75rem 1rem;
            border-top: 1px solid var(--border);
            background: var(--surface);
        }

        .frame-nav {
            display: flex;
            align-items: center;
            gap: 0.3rem;
        }

        .frame-btn {
            width: 28px;
            height: 28px;
            background: var(--bg);
            border: 1px solid var(--border);
            border-radius: 4px;
            color: var(--text-dim);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.8rem;
        }

        .frame-btn:hover {
            border-color: var(--accent);
            color: var(--accent);
        }

        .frame-info {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.8rem;
            color: var(--text);
            min-width: 80px;
            text-align: center;
        }

        .play-btn {
            width: 36px;
            height: 36px;
            background: var(--accent);
            border: none;
            border-radius: 50%;
            color: var(--bg);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1rem;
        }

        .play-btn:hover {
            background: var(--hover);
        }

        .fps-select {
            padding: 0.4rem 0.6rem;
            background: var(--bg);
            border: 1px solid var(--border);
            border-radius: 4px;
            color: var(--text);
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.75rem;
        }

        .capture-buttons {
            display: flex;
            gap: 6px;
            margin-left: auto;
        }

        .capture-btn {
            padding: 0.5rem 0.75rem;
            background: var(--bg);
            border: 1px solid var(--accent);
            border-radius: 4px;
            color: var(--accent);
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.75rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        .capture-btn:hover {
            background: var(--accent);
            color: var(--bg);
        }

        .capture-btn.capture-pat {
            border-color: #64b5f6;
            color: #64b5f6;
        }

        .capture-btn.capture-pat:hover {
            background: #64b5f6;
            color: var(--bg);
        }

        /* Status Bar */
        .status-bar {
            display: flex;
            justify-content: space-between;
            padding: 0.5rem 1rem;
            background: var(--surface);
            border-top: 1px solid var(--border);
            font-size: 0.7rem;
            color: var(--text-dim);
        }

        .status-bar .pattern-info {
            display: flex;
            gap: 1.5rem;
        }

        .status-bar .unsaved {
            color: var(--warning);
            font-weight: 600;
        }

        .status-bar .small-btn {
            background: transparent;
            border: 1px solid var(--border);
            color: var(--text-dim);
            padding: 0.1rem 0.3rem;
            font-size: 0.65rem;
            cursor: pointer;
            border-radius: 3px;
            margin-left: 0.3rem;
        }

        .status-bar .small-btn:hover {
            background: var(--border);
            color: var(--text);
        }

        .status-bar .arena-config {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .status-bar .arena-config select {
            background: var(--bg);
            border: 1px solid var(--border);
            color: var(--text);
            padding: 0.15rem 0.3rem;
            font-size: 0.65rem;
            border-radius: 3px;
            cursor: pointer;
        }

        .status-bar .arena-config select:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            background: var(--surface);
        }

        .status-bar .arena-config .lock-btn {
            background: transparent;
            border: none;
            color: var(--text-dim);
            padding: 0.1rem 0.25rem;
            font-size: 0.75rem;
            cursor: pointer;
            border-radius: 3px;
        }

        .status-bar .arena-config .lock-btn:hover {
            background: var(--border);
            color: var(--text);
        }

        .status-bar .arena-config .lock-btn.locked {
            color: var(--accent);
        }

        /* Coming Soon overlay for disabled features */
        .coming-soon-overlay {
            position: absolute;
            inset: 0;
            background: rgba(15, 20, 25, 0.9);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10;
        }

        .coming-soon-badge {
            background: var(--surface);
            border: 1px solid var(--border);
            padding: 1rem 2rem;
            border-radius: 8px;
            text-align: center;
        }

        .coming-soon-badge h3 {
            font-family: 'JetBrains Mono', monospace;
            color: var(--accent);
            margin-bottom: 0.5rem;
        }

        .coming-soon-badge p {
            font-size: 0.8rem;
            color: var(--text-dim);
        }
    </style>
</head>
<body>
    <!-- Development Banner -->
    <div class="dev-banner">
        üöß Pattern Editor v0.9.23 | 2026-02-10 ET ‚Äî <a href="https://github.com/reiserlab/webDisplayTools/issues/6" target="_blank">View progress on GitHub</a>
    </div>

    <div class="app-container">
        <!-- Left Panel: Tools -->
        <div class="tools-panel">
            <div class="tools-header">
                <div style="display: flex; align-items: baseline; gap: 0.5rem;">
                    <a href="index.html" title="Back to Tools" style="color: var(--text-dim); text-decoration: none; font-size: 0.85rem;">‚Üê Tools</a>
                    <h1 style="margin: 0;">Pattern Editor</h1>
                    <button class="quick-start-btn" id="quickStartBtn" title="Open Quick Start Guide">quick<br>start</button>
                </div>
                <div class="subtitle">Create and edit arena patterns</div>
            </div>

            <!-- Tool Tabs -->
            <div class="tool-tabs">
                <button class="tool-tab active" data-tab="generate">Generate</button>
                <button class="tool-tab" data-tab="frame">Animate</button>
                <button class="tool-tab" data-tab="combine">Combine</button>
                <button class="tool-tab" data-tab="image">Image</button>
            </div>

            <!-- Tool Content -->
            <div class="tool-content">
                <div class="preview-mode-banner" id="previewModeBanner">
                    PREVIEW MODE &mdash; Click "New" to create a pattern
                </div>
                <!-- Generate Tab -->
                <div class="tool-pane active" id="generatePane">
                    <div class="section-title">Pattern Type</div>
                    <div class="control-group">
                        <select id="patternType">
                            <option value="grating">Square Grating</option>
                            <option value="sine">Sine Grating</option>
                            <option value="starfield">Starfield</option>
                            <option value="edge">Edge</option>
                            <option value="off-on">Off/On</option>
                            <option value="looming" disabled>Looming (coming soon)</option>
                        </select>
                    </div>

                    <!-- Spherical grating controls (for grating/sine patterns) -->
                    <div id="sphericalParams" style="display: none;">
                        <div class="control-group">
                            <label>Motion Type</label>
                            <select id="motionType">
                                <option value="rotation">Rotation (horizontal stripes)</option>
                                <option value="expansion">Expansion (concentric rings)</option>
                                <option value="translation">Translation (linear motion)</option>
                            </select>
                        </div>

                        <!-- Pole coordinates (shown for all motion types - determines direction) -->
                        <div id="poleCoordGroup">
                            <div class="control-row">
                                <div class="control-group half">
                                    <label>Pole Az (¬∞)</label>
                                    <input type="number" id="poleAzimuth" value="0" min="-180" max="180" step="1" title="Azimuth angle: -180 to +180 degrees">
                                </div>
                                <div class="control-group half">
                                    <label>Pole El (¬∞)</label>
                                    <input type="number" id="poleElevation" value="-90" min="-90" max="90" step="1" title="Elevation: -90 (down) to +90 (up)">
                                </div>
                            </div>
                        </div>

                        <div class="control-row">
                            <div class="control-group half">
                                <label>Arena Model</label>
                                <select id="arenaModel" title="Smooth: perfect cylinder. Poly: polygonal facets">
                                    <option value="smooth">Smooth</option>
                                    <option value="poly">Polygonal</option>
                                </select>
                            </div>
                            <div class="control-group half">
                                <label>Anti-alias</label>
                                <select id="aaSamples" title="More samples = smoother edges but slower">
                                    <option value="1">None</option>
                                    <option value="5">Low (5)</option>
                                    <option value="15" selected>Std (15)</option>
                                </select>
                            </div>
                        </div>
                    </div>

                    <div class="section-title">Parameters</div>

                    <!-- Common grating/sine params -->
                    <div id="gratingParams">
                        <div class="control-group">
                            <label id="spatialFreqLabel">Spatial Frequency</label>
                            <div style="display: flex; gap: 0.5rem; align-items: center;">
                                <input type="number" id="spatialFreq" value="20" min="1" max="1000" step="0.1" style="flex: 1;">
                                <select id="spatialFreqUnit" style="width: 80px;">
                                    <option value="px" selected>pixels</option>
                                    <option value="deg">degrees</option>
                                </select>
                            </div>
                            <span id="spatialFreqConversion" style="color: var(--text-dim); font-size: 0.75rem;">= 36.00¬∞</span>
                        </div>
                        <div class="control-row" id="dutyCyclePhaseRow">
                            <div class="control-group half" id="dutyCycleGroup">
                                <label>Duty (%)</label>
                                <input type="number" id="dutyCycle" value="50" min="1" max="99" title="Duty cycle percentage (1-99%)">
                            </div>
                            <div class="control-group half" id="phaseShiftGroup">
                                <label>Phase (%)</label>
                                <input type="number" id="phaseShift" value="0" min="0" max="100" step="1" title="Phase offset as percentage of wavelength (0-100%)">
                            </div>
                        </div>
                    </div>

                    <!-- Starfield params -->
                    <div id="starfieldParams" style="display: none;">
                        <div class="control-row">
                            <div class="control-group third">
                                <label>Dots</label>
                                <input type="number" id="dotCount" value="100" min="1" max="1000" title="Number of dots">
                            </div>
                            <div class="control-group third">
                                <label>Size</label>
                                <input type="number" id="dotSize" value="1" min="1" max="10" title="Dot size in pixels">
                            </div>
                            <div class="control-group third">
                                <label>Seed</label>
                                <input type="number" id="randomSeed" value="12345" title="Random seed for reproducibility">
                            </div>
                        </div>
                        <div class="control-row">
                            <div class="control-group half">
                                <label>Brightness</label>
                                <select id="dotBrightnessMode" title="Fixed: all same. Random-spread: 0 to max. Random-binary: 0 or max">
                                    <option value="fixed" selected>Fixed</option>
                                    <option value="random-spread">Random</option>
                                    <option value="random-binary">Binary</option>
                                </select>
                            </div>
                            <div class="control-group half">
                                <label>Size Mode</label>
                                <select id="dotSizeMode" title="Static: all same. Distance: closer dots appear larger">
                                    <option value="static" selected>Static</option>
                                    <option value="distance">Distance</option>
                                </select>
                            </div>
                        </div>
                        <div class="control-group">
                            <label>Overlap</label>
                            <select id="dotOcclusion" title="How to handle overlapping dots">
                                <option value="closest" selected>Closest wins</option>
                                <option value="sum">Sum</option>
                                <option value="mean">Average</option>
                            </select>
                        </div>
                        <div class="control-group" style="display: flex; align-items: center; gap: 0.5rem;">
                            <input type="checkbox" id="snapDots" checked>
                            <label for="snapDots" style="margin: 0;">Snap dots to pixel grid</label>
                        </div>
                    </div>

                    <!-- Edge params - uses same spherical controls as grating -->
                    <div id="edgeParams" style="display: none;">
                        <div style="color: var(--text-dim); font-size: 0.75rem; padding: 0.5rem; background: rgba(0,230,118,0.1); border-radius: 4px; margin-bottom: 0.5rem;">
                            Edge patterns use duty-cycle sweep (0%‚Üí100%) with spherical coordinates.
                            Configure motion type and pole above.
                        </div>
                    </div>

                    <!-- Motion params (hidden for off/on) -->
                    <div id="motionParams">
                        <div class="control-group">
                            <label>Step Size (per frame)</label>
                            <div style="display: flex; gap: 0.5rem; align-items: center;">
                                <input type="number" id="stepSize" value="1" min="0.1" max="100" step="0.1" style="flex: 1;">
                                <select id="stepSizeUnit" style="width: 80px;">
                                    <option value="px" selected>pixels</option>
                                    <option value="deg">degrees</option>
                                </select>
                            </div>
                            <span id="stepSizeConversion" style="color: var(--text-dim); font-size: 0.75rem;">= 1.80¬∞</span>
                            <span id="frameCountPreview" style="color: var(--accent); font-size: 0.75rem; margin-left: 0.5rem;">(200 frames)</span>
                        </div>
                        <div class="control-group" id="numFramesGroup">
                            <label>Number of Frames <span id="numFramesHint" style="color: var(--text-dim); font-size: 0.7rem;"></span></label>
                            <input type="number" id="numFramesInput" value="200" min="1" max="10000">
                        </div>
                    </div>

                    <div class="section-title">Output</div>
                    <div class="control-row">
                        <div class="control-group half">
                            <label>Mode</label>
                            <select id="gsMode" title="GS16: 4-bit grayscale (0-15). GS2: binary (0-1)">
                                <option value="16">GS16</option>
                                <option value="2">GS2</option>
                            </select>
                        </div>
                        <div class="control-group half">
                            <label>High / Low</label>
                            <div style="display: flex; gap: 4px;">
                                <input type="number" id="highLevel" value="15" min="0" max="15" title="High brightness level" style="flex: 1;">
                                <input type="number" id="lowLevel" value="0" min="0" max="15" title="Low brightness level" style="flex: 1;">
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Animate Tab -->
                <div class="tool-pane" id="framePane">
                    <!-- Mode Toggle -->
                    <div class="animate-mode-toggle">
                        <button class="mode-btn active" data-mode="shifting" id="shiftingModeBtn">Frame Shifting</button>
                        <button class="mode-btn" data-mode="animation" id="animationModeBtn">Frame Animation</button>
                    </div>

                    <!-- Frame Shifting Mode -->
                    <div class="animate-mode-content active" id="shiftingMode">
                        <div class="section-title">Source Frame</div>
                        <div id="shiftingFrameStatus" style="padding: 0.5rem; background: var(--bg); border-radius: 4px; font-size: 0.75rem; color: var(--text-dim); margin-bottom: 0.75rem;">
                            <div style="display: flex; align-items: center; gap: 0.75rem;">
                                <div id="shiftingFramePreview" style="display: none; width: 64px; height: 64px; flex-shrink: 0; border-radius: 4px; overflow: hidden; background: var(--surface); border: 1px solid var(--border);">
                                    <img id="shiftingFrameIcon" style="width: 100%; height: 100%; object-fit: contain;" />
                                </div>
                                <span id="shiftingFrameInfo">No frame loaded - double-click a frame in clipboard</span>
                            </div>
                        </div>
                        <div class="section-title">Sequence Settings</div>
                        <div class="control-row">
                            <div class="control-group half">
                                <label>Direction</label>
                                <select id="rotateDirection" title="Motion direction for the sequence">
                                    <option value="h-cw">H CW</option>
                                    <option value="h-ccw">H CCW</option>
                                    <option value="v-up">V Up</option>
                                    <option value="v-down">V Down</option>
                                </select>
                            </div>
                            <div class="control-group half">
                                <label>Step (px)</label>
                                <input type="number" id="rotateStep" value="1" min="1" max="20" title="Pixels per frame">
                            </div>
                        </div>
                        <div class="control-group">
                            <label>Frames <span id="framesHint" style="color: var(--text-dim); font-size: 0.65rem;"></span></label>
                            <input type="number" id="totalFrames" value="200" min="1" max="10000" title="Total number of frames">
                        </div>
                        <button class="btn secondary" id="clearShiftingFrameBtn" style="margin-top: 0.5rem; display: none;">Clear Source Frame</button>
                    </div>

                    <!-- Frame Animation Mode -->
                    <div class="animate-mode-content" id="animationMode">
                        <div class="section-title">Build from Clipboard Frames</div>
                        <div class="frame-sequence-builder" id="frameSequenceBuilder">
                            <div class="sequence-empty" id="sequenceEmpty">
                                Add frames from the Frames clipboard below
                            </div>
                            <div class="sequence-frames" id="sequenceFrames"></div>
                        </div>
                        <div id="sequenceSelectionFeedback" style="display: none; color: var(--accent); font-size: 0.8rem; text-align: center; margin-top: 0.5rem;"></div>
                        <div class="control-group" style="margin-top: 0.5rem;">
                            <div style="display: flex; gap: 0.5rem;">
                                <button class="btn secondary" id="addAllFramesBtn" style="flex: 1;">+ Add All Frames</button>
                                <button class="btn secondary" id="clearSequenceBtn" style="flex: 1;">Clear Sequence</button>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Combine Tab -->
                <div class="tool-pane" id="combinePane">
                    <div class="section-title">Pattern A</div>
                    <div class="control-group">
                        <div class="combine-pattern-preview">
                            <div class="combine-pattern-thumbnail empty" id="patternAThumbnail">?</div>
                            <div class="combine-pattern-info">
                                <div class="combine-pattern-name" id="patternAName">No pattern set</div>
                                <div class="combine-pattern-dims" id="patternADims"></div>
                            </div>
                        </div>
                        <div style="display: flex; gap: 0.5rem;">
                            <button class="btn secondary" id="setPatternA" style="flex: 1;">Use Current as A</button>
                            <button class="btn secondary" id="loadPatternA" style="flex: 1;">Load A...</button>
                            <button class="btn secondary" id="clearPatternA" style="width: auto; padding: 0.4rem 0.8rem;" title="Clear Pattern A">‚úï</button>
                        </div>
                    </div>

                    <div class="section-title">Pattern B</div>
                    <div class="control-group">
                        <div class="combine-pattern-preview">
                            <div class="combine-pattern-thumbnail empty" id="patternBThumbnail">?</div>
                            <div class="combine-pattern-info">
                                <div class="combine-pattern-name" id="patternBName">No pattern set</div>
                                <div class="combine-pattern-dims" id="patternBDims"></div>
                            </div>
                        </div>
                        <div style="display: flex; gap: 0.5rem;">
                            <button class="btn secondary" id="setPatternB" style="flex: 1;">Use Current as B</button>
                            <button class="btn secondary" id="loadPatternB" style="flex: 1;">Load B...</button>
                            <button class="btn secondary" id="clearPatternB" style="width: auto; padding: 0.4rem 0.8rem;" title="Clear Pattern B">‚úï</button>
                        </div>
                    </div>

                    <div style="text-align: center; margin: 1rem 0;">
                        <button class="btn secondary" id="swapBtn" style="width: auto; padding: 0.4rem 1rem;">
                            ‚Üï Swap A ‚Üî B
                        </button>
                    </div>

                    <div class="section-title">Combination Mode</div>
                    <div class="control-group">
                        <select id="combineMode">
                            <option value="sequential">Sequential (concatenate)</option>
                            <option value="mask">Mask (threshold)</option>
                            <option value="blend">Blend (50%)</option>
                            <option value="split-h">Horizontal Split (left/right)</option>
                            <option value="split-v">Vertical Split (top/bottom)</option>
                        </select>
                    </div>

                    <!-- Mode-specific options -->
                    <div id="combineMaskOptions" class="control-group" style="display: none;">
                        <label>Threshold (0-15):</label>
                        <input type="number" id="maskThreshold" value="7" min="0" max="15" step="1">
                        <span style="font-size: 0.7rem; color: var(--text-dim);">Pixels above threshold show B</span>
                    </div>

                    <div id="combineSplitOptions" class="control-group" style="display: none;">
                        <label>Split Position:</label>
                        <input type="range" id="splitPosition" value="50" min="0" max="100" step="1" style="width: 100%;">
                        <div style="display: flex; justify-content: space-between; font-size: 0.7rem; color: var(--text-dim);">
                            <span id="splitPositionPercent">50%</span>
                            <span id="splitPositionPixel">pixel ‚Äî</span>
                        </div>
                    </div>

                    <div id="combineLengthOptions" class="control-group" style="display: none; margin-top: 0.5rem; padding: 0.5rem; background: var(--bg); border-radius: 4px;">
                        <label style="font-size: 0.75rem; color: var(--text-dim);">Different frame counts:</label>
                        <select id="lengthHandling" style="margin-top: 0.25rem;">
                            <option value="loop">Loop shorter pattern</option>
                            <option value="truncate">Truncate to shorter</option>
                            <option value="extend">Extend shorter (hold last frame)</option>
                        </select>
                    </div>

                </div>

                <!-- Image Tab (placeholder) -->
                <div class="tool-pane" id="imagePane">
                    <div class="section-title">Load Image</div>
                    <div class="control-group">
                        <button class="btn secondary" id="loadImageBtn" style="width: 100%;" title="Load PNG or JPEG image">
                            Load Image...
                        </button>
                        <div id="imageInfo" style="margin-top: 0.5rem; padding: 0.5rem; background: var(--bg); border-radius: 4px; font-size: 0.75rem; color: var(--text-dim);">
                            No image loaded
                        </div>
                    </div>

                    <div class="section-title">Preview</div>
                    <div class="control-group" style="position: relative;">
                        <div id="imagePreviewContainer" style="width: 100%; aspect-ratio: 4/3; background: var(--bg); border: 1px solid var(--border); border-radius: 4px; overflow: hidden; position: relative; cursor: move;">
                            <canvas id="imagePreviewCanvas" style="width: 100%; height: 100%;"></canvas>
                        </div>
                        <div style="font-size: 0.65rem; color: var(--text-dim); margin-top: 0.25rem;">
                            Drag to pan the arena region
                        </div>
                    </div>

                    <div class="section-title">Transform</div>
                    <div class="control-group">
                        <label>Scale</label>
                        <div style="display: flex; align-items: center; gap: 0.5rem;">
                            <input type="range" id="imageScale" min="10" max="500" value="100" style="flex: 1;" title="Scale the arena region (10-500%)">
                            <span id="imageScaleValue" style="min-width: 40px; text-align: right; font-size: 0.8rem;">100%</span>
                        </div>
                    </div>
                    <div class="control-row">
                        <div class="control-group half">
                            <label>Rotation</label>
                            <div style="display: flex; gap: 0.25rem; align-items: center;">
                                <input type="number" id="imageRotation" value="0" min="-180" max="180" step="1" title="Rotation in degrees (-180 to 180)">
                                <span style="color: var(--text-dim); font-size: 0.8rem;">deg</span>
                            </div>
                        </div>
                        <div class="control-group half">
                            <label>&nbsp;</label>
                            <button class="btn secondary" id="fitImageBtn" style="width: 100%;" title="Fit arena to image bounds">
                                Fit
                            </button>
                        </div>
                    </div>

                    <div class="section-title">Output</div>
                    <div class="control-row">
                        <div class="control-group half">
                            <label>Mode</label>
                            <select id="imageGsMode" title="GS16: 4-bit grayscale (0-15). GS2: binary (0-1)">
                                <option value="16">GS16</option>
                                <option value="2">GS2</option>
                            </select>
                        </div>
                        <div class="control-group half">
                            <label>Invert</label>
                            <div style="display: flex; align-items: center; height: 34px;">
                                <input type="checkbox" id="imageInvert" title="Invert grayscale values" style="margin: 0;">
                                <label for="imageInvert" style="margin: 0 0 0 0.5rem; font-size: 0.75rem; cursor: pointer;">Invert</label>
                            </div>
                        </div>
                    </div>
                    <div id="imageQuantizationInfo" style="padding: 0.5rem; background: var(--bg); border-radius: 4px; font-size: 0.65rem; color: var(--text-dim);">
                        GS16: Maps 0-255 to 0-15<br>
                        GS2: Threshold at 128 (0=dark, 1=bright)
                    </div>
                </div>
            </div>

            <!-- File Operations -->
            <div class="file-operations">
                <div class="file-buttons">
                    <button class="btn secondary" id="loadBtn">Load</button>
                    <button class="btn secondary" id="saveBtn">Save</button>
                    <button class="btn secondary" id="newBtn">New</button>
                </div>
            </div>
        </div>

        <!-- Generate Column - between tools and viewer -->
        <div class="generate-column">
            <button id="generateBtn" class="generate-btn-vertical" title="Generate pattern from settings">
                <span class="arrow">‚Üí</span>
                <span class="letter">G</span>
                <span class="letter">E</span>
                <span class="letter">N</span>
                <span class="letter">E</span>
                <span class="letter">R</span>
                <span class="letter">A</span>
                <span class="letter">T</span>
                <span class="letter">E</span>
                <span class="arrow">‚Üí</span>
            </button>
        </div>

        <!-- Right Panel: Viewer -->
        <div class="viewer-panel">
            <!-- Viewer Tabs -->
            <div class="viewer-tabs">
                <button class="viewer-tab active" data-viewer="grid">2D</button>
                <button class="viewer-tab" data-viewer="edit">Edit</button>
                <button class="viewer-tab" data-viewer="3d">3D</button>
                <button class="viewer-tab disabled" data-viewer="mercator">Mercator</button>
                <button class="viewer-tab disabled" data-viewer="mollweide">Mollweide</button>

                <div class="viewer-options">
                    <label>
                        <input type="checkbox" id="showBoundaries" checked>
                        Panel boundaries
                    </label>
                    <label>
                        <input type="checkbox" id="showNumbers">
                        Panel numbers
                    </label>
                    <label>
                        <input type="checkbox" id="showPoleGeometry">
                        Pole geometry
                    </label>
                </div>
            </div>

            <!-- Edit Toolbar (visible in edit mode) -->
            <div class="edit-toolbar" id="editToolbar">
                <div class="toolbar-section">
                    <span class="toolbar-label">Color:</span>
                    <div class="edit-palette" id="editPalette"></div>
                    <span class="current-color-display" id="currentColorDisplay">15</span>
                </div>
                <div class="toolbar-section">
                    <span class="toolbar-label">Transform:</span>
                    <button class="edit-ops-btn" id="flipHBtn" title="Flip Horizontal">Flip H</button>
                    <button class="edit-ops-btn" id="flipVBtn" title="Flip Vertical">Flip V</button>
                    <button class="edit-ops-btn" id="invertBtn" title="Invert Brightness">Invert</button>
                    <button class="edit-ops-btn" id="findReplaceBtn" title="Find and Replace">Find/Replace</button>
                </div>
            </div>

            <!-- Viewer Content -->
            <div class="viewer-content">
                <!-- Grid Viewer -->
                <div class="viewer-pane active" id="gridViewer">
                    <div class="placeholder">
                        <div class="placeholder-icon">‚¨ö</div>
                        <h2>No Pattern Loaded</h2>
                        <p>Load a .pat file or generate a new pattern to view it here.</p>
                    </div>
                </div>

                <!-- 3D Viewer -->
                <div class="viewer-pane" id="3dViewer">
                    <div id="threeContainer" style="width: 100%; height: 100%;"></div>
                </div>

                <!-- Mercator Viewer -->
                <div class="viewer-pane" id="mercatorViewer">
                    <div class="coming-soon-overlay">
                        <div class="coming-soon-badge">
                            <h3>Mercator Projection</h3>
                            <p>Optional enhancement</p>
                        </div>
                    </div>
                </div>

                <!-- Mollweide Viewer -->
                <div class="viewer-pane" id="mollweideViewer">
                    <div class="coming-soon-overlay">
                        <div class="coming-soon-badge">
                            <h3>Mollweide Projection</h3>
                            <p>Optional enhancement</p>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Playback Controls -->
            <div class="playback-controls">
                <div class="frame-nav">
                    <button class="frame-btn" id="firstFrameBtn" title="First frame">‚èÆ</button>
                    <button class="frame-btn" id="prevFrameBtn" title="Previous frame">‚óÄ</button>
                    <span class="frame-info" id="frameInfo">1 / 1</span>
                    <button class="frame-btn" id="nextFrameBtn" title="Next frame">‚ñ∂</button>
                    <button class="frame-btn" id="lastFrameBtn" title="Last frame">‚è≠</button>
                </div>

                <div class="stretch-control" style="display: flex; align-items: center; gap: 0.25rem; padding: 0 0.5rem; border-left: 1px solid var(--border);">
                    <label style="font-size: 0.75rem; color: var(--text-dim);">Stretch:</label>
                    <input type="number" id="stretchValue" value="1" min="1" max="255" step="1" style="width: 50px; padding: 0.2rem 0.4rem; font-size: 0.75rem; background: var(--surface); border: 1px solid var(--border); color: var(--text); border-radius: 4px;">
                </div>

                <button class="play-btn" id="playBtn" title="Play/Pause">‚ñ∂</button>

                <select class="fps-select" id="fpsSelect">
                    <option value="-30">-30 FPS</option>
                    <option value="-20">-20 FPS</option>
                    <option value="-10">-10 FPS</option>
                    <option value="-5">-5 FPS</option>
                    <option value="-1">-1 FPS</option>
                    <option value="1">1 FPS</option>
                    <option value="5">5 FPS</option>
                    <option value="10" selected>10 FPS</option>
                    <option value="20">20 FPS</option>
                    <option value="30">30 FPS</option>
                </select>

                <div class="capture-buttons">
                    <button class="capture-btn" id="captureFrameBtn" title="Capture current frame to clipboard">‚Üì Frame</button>
                    <button class="capture-btn capture-pat" id="capturePatBtn" title="Capture full pattern to clipboard">‚Üì Pat</button>
                </div>
            </div>

            <!-- Clipboard Bar - Tabbed design with Frames left, Patterns right -->
            <div class="clipboard-bar">
                <button class="clipboard-tab active" data-clipboard="frames" id="framesTab" title="View captured frames (single frames for editing or animation)">
                    Frames <span class="count" id="framesCount">(0)</span>
                </button>
                <div class="clipboard-content-area">
                    <div class="clipboard-content active" id="clipboardFrames">
                        <span class="clipboard-empty">Capture frames from viewer</span>
                    </div>
                    <div class="clipboard-content" id="clipboardPatterns">
                        <span class="clipboard-empty">Capture patterns from viewer</span>
                    </div>
                </div>
                <button class="clipboard-tab" data-clipboard="patterns" id="patternsTab" title="View captured patterns (full multi-frame patterns for combining)">
                    Patterns <span class="count" id="patternsCount">(0)</span>
                </button>
            </div>
        </div>
    </div>

    <!-- Status Bar -->
    <div class="status-bar">
        <div class="pattern-info">
            <span id="statusFilename">No pattern</span>
            <button id="renameBtn" class="small-btn" title="Rename pattern">‚úé</button>
            <span id="statusDimensions">‚Äî</span>
            <span id="statusFrames">‚Äî</span>
            <span id="statusGsMode">‚Äî</span>
            <span id="statusHeaderMeta" style="color: var(--text-dim);"></span>
            <span id="statusUnsaved" style="color: #ff4444; font-weight: bold;"></span>
        </div>
        <div class="arena-config">
            <span style="color: var(--text-dim);">Arena:</span>
            <select id="arenaConfigStatus"></select>
            <button id="arenaLockBtn" class="lock-btn" title="Lock arena config">üîì</button>
        </div>
    </div>

    <!-- Hidden file input -->
    <input type="file" id="fileInput" accept=".pat" style="display: none;">
    <input type="file" id="fileInputA" accept=".pat" style="display: none;">
    <input type="file" id="fileInputB" accept=".pat" style="display: none;">

    <!-- Find/Replace Modal -->
    <div class="modal-overlay" id="findReplaceModal">
        <div class="modal-content">
            <h3 class="modal-title">Find and Replace</h3>
            <div class="modal-row">
                <label>Find:</label>
                <input type="number" id="findValue" min="0" max="15" value="0">
            </div>
            <div class="modal-row">
                <label>Replace:</label>
                <input type="number" id="replaceValue" min="0" max="15" value="15">
            </div>
            <div class="modal-buttons">
                <button class="modal-btn secondary" id="cancelFindReplace">Cancel</button>
                <button class="modal-btn primary" id="applyFindReplace">Replace All</button>
            </div>
        </div>
    </div>

    <script type="module">
        import PatParser from './js/pat-parser.js';
        import ThreeViewer from './js/pattern-editor/viewers/three-viewer.js';
        import { combinePatterns } from './js/pattern-editor/tools/combiner.js';
        import { generatePatternIcon } from './js/icon-generator.js';
        import ImageConverter from './js/pattern-editor/tools/image-converter.js';

        // ============================================
        // State Management
        // ============================================
        const state = {
            pattern: null,          // Current loaded/generated pattern
            combinePatternA: null,  // Pattern A for combining (saved separately)
            combinePatternB: null,  // Pattern B for combining (saved separately)
            clipboardFrames: [],    // Array of captured single frames (max ~10)
            clipboardPatterns: [],  // Array of stored patterns for combine/preview
            selectedFrameId: null,  // Single selected frame ID (only one at a time)
            selectedPatternId: null, // Single selected pattern ID
            loadedClipboardFrameId: null,   // ID of clipboard frame currently loaded in viewer
            loadedClipboardPatternId: null, // ID of clipboard pattern currently loaded in viewer
            editor: {
                activeTool: 'generate',
                activeViewer: 'grid',
                editMode: false,
                editingClipboardId: null,
                showPanelBoundaries: true,
                showPanelNumbers: false,
                currentFrame: 0,
                drawColor: 15
            },
            playback: {
                isPlaying: false,
                fps: 10,
                intervalId: null
            },
            arena: {
                configName: 'G6_2x10',
                config: null,
                locked: false
            },
            frameAnimation: {
                mode: 'shifting',  // 'shifting' or 'animation'
                sequence: [],      // Array of frame entries for animation mode
                selectedIndex: -1  // Currently selected frame in sequence (-1 = none)
            },
            previewMode: false,
            isDirty: false,
            filename: null,
            listeners: new Map()
        };

        // 3D Viewer instance
        let threeViewer = null;

        // Event emitter
        function emit(event, data) {
            const callbacks = state.listeners.get(event) || [];
            callbacks.forEach(cb => cb(data));
        }

        function on(event, callback) {
            if (!state.listeners.has(event)) {
                state.listeners.set(event, []);
            }
            state.listeners.get(event).push(callback);
        }

        // ============================================
        // UI Initialization
        // ============================================
        function initUI() {
            // Populate arena config dropdown (in status bar)
            const arenaSelect = document.getElementById('arenaConfigStatus');
            const configsByGen = getConfigsByGeneration();

            for (const [gen, configs] of Object.entries(configsByGen)) {
                const optgroup = document.createElement('optgroup');
                optgroup.label = gen;
                // configs is array of { name, label, description, arena } objects
                configs.forEach(config => {
                    const option = document.createElement('option');
                    option.value = config.name;
                    option.textContent = config.label || config.name;
                    if (config.name === state.arena.configName) {
                        option.selected = true;
                    }
                    optgroup.appendChild(option);
                });
                arenaSelect.appendChild(optgroup);
            }

            // Load initial config
            state.arena.config = getConfig(state.arena.configName);

            // Tool tabs
            document.querySelectorAll('.tool-tab').forEach(tab => {
                tab.addEventListener('click', () => {
                    const tabName = tab.dataset.tab;
                    setActiveTool(tabName);
                });
            });

            // Viewer tabs
            document.querySelectorAll('.viewer-tab:not(.disabled)').forEach(tab => {
                tab.addEventListener('click', () => {
                    const viewerName = tab.dataset.viewer;
                    setActiveViewer(viewerName);
                });
            });

            // Clipboard tabs
            document.querySelectorAll('.clipboard-tab').forEach(tab => {
                tab.addEventListener('click', () => {
                    const tabType = tab.dataset.clipboard;
                    switchClipboardTab(tabType);
                });
            });

            // View options
            document.getElementById('showBoundaries').addEventListener('change', (e) => {
                state.editor.showPanelBoundaries = e.target.checked;
                renderCurrentViewer();
            });

            document.getElementById('showNumbers').addEventListener('change', (e) => {
                state.editor.showPanelNumbers = e.target.checked;
                // Update 3D viewer if it exists
                if (threeViewer) {
                    threeViewer.setOptions({ showPanelNumbers: e.target.checked });
                }
                renderCurrentViewer();
            });

            document.getElementById('showPoleGeometry').addEventListener('change', (e) => {
                state.editor.showPoleGeometry = e.target.checked;
                // Update 3D viewer if it exists
                if (threeViewer) {
                    // Get current pole coordinates from generator inputs
                    const poleAzimuth = parseFloatWithDefault(document.getElementById('poleAzimuth')?.value, 0) * Math.PI / 180;
                    const poleElevation = parseFloatWithDefault(document.getElementById('poleElevation')?.value, -90) * Math.PI / 180;
                    // Convert elevation to polar angle (theta from north pole)
                    const theta = Math.PI / 2 - poleElevation;
                    threeViewer.setOptions({
                        showPoleGeometry: e.target.checked,
                        poleCoord: [poleAzimuth, theta]
                    });
                }
            });

            // Quick Start button - opens Quick Start Guide
            document.getElementById('quickStartBtn').addEventListener('click', () => {
                window.open('https://github.com/reiserlab/webDisplayTools/blob/main/PATTERN_EDITOR_QUICKSTART.md', '_blank');
            });

            // Edit operations
            document.getElementById('flipHBtn').addEventListener('click', flipHorizontal);
            document.getElementById('flipVBtn').addEventListener('click', flipVertical);
            document.getElementById('invertBtn').addEventListener('click', invertBrightness);
            document.getElementById('findReplaceBtn').addEventListener('click', () => {
                document.getElementById('findReplaceModal').classList.add('visible');
            });
            document.getElementById('cancelFindReplace').addEventListener('click', () => {
                document.getElementById('findReplaceModal').classList.remove('visible');
            });
            document.getElementById('applyFindReplace').addEventListener('click', applyFindReplace);

            // Initialize edit palette
            initEditPalette();

            // File operations
            document.getElementById('loadBtn').addEventListener('click', () => {
                document.getElementById('fileInput').click();
            });

            document.getElementById('fileInput').addEventListener('change', handleFileLoad);

            document.getElementById('saveBtn').addEventListener('click', handleSave);
            document.getElementById('newBtn').addEventListener('click', handleNew);

            document.getElementById('renameBtn').addEventListener('click', () => {
                if (!state.pattern) {
                    alert('No pattern loaded');
                    return;
                }
                const currentName = state.filename || 'pattern.pat';
                const newName = prompt('Enter new filename:', currentName);
                if (newName && newName.trim()) {
                    // Ensure .pat extension
                    let finalName = newName.trim().endsWith('.pat') ? newName.trim() : newName.trim() + '.pat';

                    // Check if user removed the arena config prefix
                    const configPrefix = state.arena.configName + '_';
                    const hadPrefix = currentName.startsWith(configPrefix);
                    const hasPrefix = finalName.startsWith(configPrefix);

                    if (hadPrefix && !hasPrefix) {
                        // User removed the prefix - warn them
                        const keepPrefix = confirm(
                            '‚ö†Ô∏è Warning: You removed the arena config prefix.\n\n' +
                            'MATLAB requires patterns to be in a folder matching the arena config, ' +
                            'OR have the config name as a filename prefix (e.g., "' + configPrefix + '...").\n\n' +
                            'Without this prefix, MATLAB cannot auto-detect the arena configuration.\n\n' +
                            'Click OK to restore the prefix, or Cancel to keep your filename.'
                        );
                        if (keepPrefix) {
                            finalName = addArenaPrefix(finalName);
                        }
                    }

                    state.filename = finalName;
                    state.isDirty = true;
                    updateStatus();
                }
            });

            document.getElementById('arenaConfigStatus').addEventListener('change', (e) => {
                const oldConfig = state.arena.configName;
                state.arena.configName = e.target.value;
                state.arena.config = getConfig(e.target.value);

                // Clear clipboards if arena changed (dimensions may differ)
                if (oldConfig !== e.target.value) {
                    clearClipboards();

                    // Force 3D viewer to reinit with new arena if it exists and is active
                    if (threeViewer && state.editor.activeViewer === '3d') {
                        const specs = PANEL_SPECS[state.arena.config.arena.generation];
                        threeViewer.reinit(state.arena.config, specs);
                    }
                }

                updateStatus();
                updateG3ButtonStates();  // Disable save/load for G3
                renderCurrentViewer();
            });

            // Arena lock/unlock button
            document.getElementById('arenaLockBtn').addEventListener('click', toggleArenaLock);

            // Playback controls
            document.getElementById('playBtn').addEventListener('click', togglePlayback);
            document.getElementById('prevFrameBtn').addEventListener('click', () => navigateFrame(-1));
            document.getElementById('nextFrameBtn').addEventListener('click', () => navigateFrame(1));
            document.getElementById('firstFrameBtn').addEventListener('click', () => goToFrame(0));
            document.getElementById('lastFrameBtn').addEventListener('click', () => {
                if (state.pattern) goToFrame(state.pattern.numFrames - 1);
            });

            document.getElementById('fpsSelect').addEventListener('change', (e) => {
                state.playback.fps = parseInt(e.target.value);
                if (state.playback.isPlaying) {
                    stopPlayback();
                    startPlayback();
                }
            });

            // Capture buttons
            document.getElementById('captureFrameBtn').addEventListener('click', captureFrame);
            document.getElementById('capturePatBtn').addEventListener('click', storePatternToClipboard);

            // Generate button and pattern type change
            document.getElementById('generateBtn').addEventListener('click', handleGenerate);
            document.getElementById('patternType').addEventListener('change', updatePatternTypeUI);

            // Spherical grating controls
            document.getElementById('motionType').addEventListener('change', updateMotionTypeUI);
            document.getElementById('spatialFreqUnit').addEventListener('change', updateConversionDisplays);
            document.getElementById('spatialFreq').addEventListener('input', updateConversionDisplays);
            document.getElementById('stepSizeUnit').addEventListener('change', updateConversionDisplays);
            document.getElementById('stepSize').addEventListener('input', updateConversionDisplays);

            // Pole coordinate inputs - update 3D visualization
            const updatePoleVisualization = () => {
                if (threeViewer && state.editor.showPoleGeometry) {
                    const poleAzimuth = parseFloatWithDefault(document.getElementById('poleAzimuth')?.value, 0) * Math.PI / 180;
                    const poleElevation = parseFloatWithDefault(document.getElementById('poleElevation')?.value, -90) * Math.PI / 180;
                    const theta = Math.PI / 2 - poleElevation;
                    threeViewer.setPoleCoord([poleAzimuth, theta]);
                }
            };
            document.getElementById('poleAzimuth').addEventListener('input', updatePoleVisualization);
            document.getElementById('poleElevation').addEventListener('input', updatePoleVisualization);

            // Combine operations - Pattern A
            document.getElementById('setPatternA').addEventListener('click', handleSetPatternA);
            document.getElementById('loadPatternA').addEventListener('click', () => {
                document.getElementById('fileInputA').click();
            });
            document.getElementById('fileInputA').addEventListener('change', handleLoadPatternA);
            document.getElementById('clearPatternA').addEventListener('click', handleClearPatternA);

            // Combine operations - Pattern B
            document.getElementById('setPatternB').addEventListener('click', handleSetPatternB);
            document.getElementById('loadPatternB').addEventListener('click', () => {
                document.getElementById('fileInputB').click();
            });
            document.getElementById('fileInputB').addEventListener('change', handleLoadPatternB);
            document.getElementById('clearPatternB').addEventListener('click', handleClearPatternB);

            // Combine operations - other
            document.getElementById('swapBtn').addEventListener('click', handleSwap);
            document.getElementById('combineMode').addEventListener('change', updateCombineModeUI);
            document.getElementById('splitPosition').addEventListener('input', updateSplitPositionDisplay);

            // Animate tab mode toggle
            document.getElementById('shiftingModeBtn').addEventListener('click', () => setAnimateMode('shifting'));
            document.getElementById('animationModeBtn').addEventListener('click', () => setAnimateMode('animation'));

            // Frame animation buttons
            document.getElementById('addAllFramesBtn').addEventListener('click', addAllClipboardFramesToSequence);
            document.getElementById('clearSequenceBtn').addEventListener('click', clearFrameAnimationSequence);

            // Frame shifting buttons
            document.getElementById('clearShiftingFrameBtn').addEventListener('click', clearShiftingFrame);

            // Direction change updates default frames
            document.getElementById('rotateDirection').addEventListener('change', updateDefaultFrames);

            // Stretch value input
            document.getElementById('stretchValue').addEventListener('change', handleStretchChange);

            // Image converter initialization
            initImageConverter();

            // Initial status
            updateStatus();
        }

        function setActiveTool(tabName) {
            state.editor.activeTool = tabName;

            document.querySelectorAll('.tool-tab').forEach(t => {
                t.classList.toggle('active', t.dataset.tab === tabName);
            });

            document.querySelectorAll('.tool-pane').forEach(p => {
                p.classList.toggle('active', p.id === tabName + 'Pane');
            });

            // Update combine info when switching to combine tab
            if (tabName === 'combine') {
                updateCombineInfo();
            }

            // Refresh image preview when switching to image tab
            if (tabName === 'image' && typeof window.updateImagePreview === 'function') {
                window.updateImagePreview();
            }
        }

        function setActiveViewer(viewerName) {
            // Map 'edit' to 'grid' for the viewer pane, but track edit mode
            const isEditMode = viewerName === 'edit';
            const actualViewer = isEditMode ? 'grid' : viewerName;

            state.editor.activeViewer = actualViewer;
            state.editor.editMode = isEditMode;

            // Update tab highlighting
            document.querySelectorAll('.viewer-tab').forEach(t => {
                t.classList.toggle('active', t.dataset.viewer === viewerName);
            });

            // Show correct viewer pane (edit uses grid pane)
            document.querySelectorAll('.viewer-pane').forEach(p => {
                p.classList.toggle('active', p.id === actualViewer + 'Viewer');
            });

            // Show/hide edit toolbar
            const toolbar = document.getElementById('editToolbar');
            toolbar.classList.toggle('visible', isEditMode);

            // Disable playback controls in edit mode (editing operates on single frame)
            document.querySelectorAll('.frame-btn, .play-btn, #fpsSelect').forEach(el => {
                el.disabled = isEditMode;
                el.style.opacity = isEditMode ? '0.4' : '1';
            });
            // Also disable frame slider
            const frameSlider = document.getElementById('frameSlider');
            if (frameSlider) {
                frameSlider.disabled = isEditMode;
                frameSlider.style.opacity = isEditMode ? '0.4' : '1';
            }

            // Update edit palette when entering edit mode
            if (isEditMode && state.pattern) {
                updateEditPalette(state.pattern.gsMode);
            }

            // Initialize or update 3D viewer when switching to it
            if (actualViewer === '3d') {
                init3DViewer();
            }

            renderCurrentViewer();
        }

        function init3DViewer() {
            const container = document.getElementById('threeContainer');
            if (!container) {
                console.error('3D Viewer: Container not found');
                return;
            }

            // Log container dimensions for debugging
            console.log('3D Viewer: Container size', container.clientWidth + 'x' + container.clientHeight);

            // Create viewer if it doesn't exist
            if (!threeViewer) {
                threeViewer = new ThreeViewer(container);

                const config = state.arena.config;
                if (config) {
                    const specs = PANEL_SPECS[config.arena.generation];
                    if (!specs) {
                        console.error('3D Viewer: No specs for generation', config.arena.generation);
                        return;
                    }
                    try {
                        threeViewer.init(config, specs);
                        console.log('3D Viewer: Initialized with', config.arena.generation,
                            config.arena.num_cols + 'x' + config.arena.num_rows);
                    } catch (err) {
                        console.error('3D Viewer: Init failed:', err.message);
                        return;
                    }

                    // Set up frame change callback to sync with playback controls
                    threeViewer.onFrameChange((frameIndex) => {
                        state.editor.currentFrame = frameIndex;
                        updateFrameInfo();
                    });
                } else {
                    console.error('3D Viewer: No arena config available');
                }
            }

            // Update pattern if one is loaded
            if (state.pattern && threeViewer) {
                threeViewer.setPattern(state.pattern);
                threeViewer.setFrame(state.editor.currentFrame);
            }
        }

        // ============================================
        // Pattern Loading/Saving
        // ============================================

        /**
         * Normalize pattern properties to use consistent naming
         * Parser returns gs_val, internal code uses gsMode
         */
        function normalizePattern(pattern) {
            return {
                ...pattern,
                gsMode: pattern.gs_val || pattern.gsMode || 16,
                // Keep gs_val for compatibility with encoder
                gs_val: pattern.gs_val || pattern.gsMode || 16
            };
        }

        async function handleFileLoad(e) {
            const file = e.target.files[0];
            if (!file) return;

            try {
                const buffer = await file.arrayBuffer();
                const pattern = normalizePattern(PatParser.parsePatFile(buffer));

                state.pattern = pattern;
                state.filename = file.name;
                state.isDirty = false;
                state.editor.currentFrame = 0;

                // Resolve arena config: V2 header is authoritative, dimension-match is fallback
                let matchingConfig = null;

                if (pattern.headerVersion >= 2 && pattern.arena_id > 0) {
                    const registryName = getArenaName(pattern.generation, pattern.arena_id);
                    if (registryName && getConfig(registryName)) {
                        matchingConfig = registryName;
                        console.log(`Arena config from V2 header: ${registryName} (arena_id=${pattern.arena_id})`);
                    } else {
                        console.warn(`V2 arena_id=${pattern.arena_id} for ${pattern.generation} not in registry, falling back to dimension match`);
                    }
                }

                if (!matchingConfig) {
                    matchingConfig = PatParser.findMatchingConfig(pattern, STANDARD_CONFIGS);
                }

                if (matchingConfig) {
                    state.arena.configName = matchingConfig;
                    state.arena.config = getConfig(matchingConfig);
                    document.getElementById('arenaConfigStatus').value = matchingConfig;
                }

                // Lock arena config and enter preview mode
                lockArenaConfig();
                enterPreviewMode();

                updateStatus();
                renderCurrentViewer();
                updateFrameInfo();

                console.log('Loaded pattern:', pattern);
            } catch (err) {
                console.error('Failed to load pattern:', err);
                alert('Failed to load pattern file: ' + err.message);
            }

            e.target.value = ''; // Reset input
        }

        async function handleLoadPatternB(e) {
            const file = e.target.files[0];
            if (!file) return;

            try {
                const buffer = await file.arrayBuffer();
                state.combinePatternB = normalizePattern(PatParser.parsePatFile(buffer));
                state.combinePatternB.filename = file.name;

                updateCombineInfo();
                console.log('Loaded pattern B:', state.combinePatternB);
            } catch (err) {
                console.error('Failed to load pattern B:', err);
                alert('Failed to load pattern file: ' + err.message);
            }

            e.target.value = '';
        }

        function handleSave() {
            if (!state.pattern) {
                alert('No pattern to save');
                return;
            }

            // Convert state.pattern to format expected by PatEncoder (V2 headers)
            const gen = state.pattern.generation;
            const configName = document.getElementById('arenaConfigStatus').value;
            const patternData = {
                generation: gen,
                gs_val: state.pattern.gsMode,
                numFrames: state.pattern.numFrames,
                rowCount: Math.floor(state.pattern.pixelRows / PANEL_SPECS[gen].pixels_per_panel),
                colCount: Math.floor(state.pattern.pixelCols / PANEL_SPECS[gen].pixels_per_panel),
                pixelRows: state.pattern.pixelRows,
                pixelCols: state.pattern.pixelCols,
                frames: state.pattern.frames,
                stretchValues: state.pattern.stretchValues || new Array(state.pattern.numFrames).fill(1),
                // V2 header metadata
                generation_id: getGenerationId(gen),
                arena_id: configName ? getArenaId(gen, configName) : 0,
                observer_id: 0
            };

            // Build filename with arena config prefix
            const baseFilename = state.filename || 'pattern.pat';
            const filename = addArenaPrefix(baseFilename);
            PatEncoder.downloadPattern(patternData, filename);

            state.isDirty = false;
            state.filename = filename;  // Update to include prefix
            updateStatus();

            console.log('Saved pattern:', filename);
        }

        /**
         * Add arena config prefix to filename if not already present
         * Format: {configName}_{patternName}.pat
         * Example: G6_2x10_grating_20px.pat
         */
        function addArenaPrefix(filename) {
            const configName = state.arena.configName;
            if (!configName) return filename;

            // Remove .pat extension for processing
            const baseName = filename.replace(/\.pat$/i, '');

            // Check if filename already starts with a config prefix (e.g., G6_2x10_)
            // Config names look like: G6_2x10, G4_3x12, G41_2x12_cw, etc.
            const configPattern = /^(G\d+_?\d*_\d+x\d+[a-z]*_?[a-z]*)_/i;
            if (configPattern.test(baseName)) {
                // Already has a prefix, replace it with current config
                const newBase = baseName.replace(configPattern, configName + '_');
                return newBase + '.pat';
            }

            // No prefix, add one
            return configName + '_' + baseName + '.pat';
        }

        /**
         * Remove arena config prefix from filename (for display or editing)
         */
        function removeArenaPrefix(filename) {
            const baseName = filename.replace(/\.pat$/i, '');
            const configPattern = /^(G\d+_?\d*_\d+x\d+[a-z]*_?[a-z]*)_/i;
            const stripped = baseName.replace(configPattern, '');
            return stripped + '.pat';
        }

        function handleNew() {
            if (state.isDirty) {
                if (!confirm('Discard unsaved changes?')) return;
            }

            // Exit preview mode if viewing a loaded pattern
            exitPreviewMode();

            // Unlock arena config so user can choose different arena for new pattern
            unlockArenaConfig();

            const config = state.arena.config;
            if (!config) {
                alert('Please select an arena configuration first');
                return;
            }

            // Create empty single-frame pattern
            // Use columns_installed for partial arenas, fallback to num_cols for full arenas
            const installedCols = config.arena.columns_installed?.length || config.arena.num_cols;
            const pixelRows = config.arena.num_rows * PANEL_SPECS[config.arena.generation].pixels_per_panel;
            const pixelCols = installedCols * PANEL_SPECS[config.arena.generation].pixels_per_panel;

            state.pattern = {
                generation: config.arena.generation,
                gsMode: 16,
                numFrames: 1,
                pixelRows: pixelRows,
                pixelCols: pixelCols,
                frames: [new Uint8Array(pixelRows * pixelCols)],
                stretchValues: [1]
            };

            state.filename = 'untitled.pat';
            state.isDirty = true;
            state.editor.currentFrame = 0;

            // Lock again after creating the new pattern
            lockArenaConfig();

            updateStatus();
            renderCurrentViewer();
            updateFrameInfo();
        }

        // ============================================
        // Pattern Generation
        // ============================================

        /**
         * Update UI visibility based on pattern type
         */
        function updatePatternTypeUI() {
            const patternType = document.getElementById('patternType').value;

            // Show/hide parameter sections
            const gratingParams = document.getElementById('gratingParams');
            const starfieldParams = document.getElementById('starfieldParams');
            const edgeParams = document.getElementById('edgeParams');
            const motionParams = document.getElementById('motionParams');
            const dutyCycleGroup = document.getElementById('dutyCycleGroup');
            const phaseShiftGroup = document.getElementById('phaseShiftGroup');
            const numFramesGroup = document.getElementById('numFramesGroup');
            const sphericalParams = document.getElementById('sphericalParams');

            // Reset visibility
            gratingParams.style.display = 'none';
            starfieldParams.style.display = 'none';
            edgeParams.style.display = 'none';
            motionParams.style.display = 'block';

            // Spherical params are shown for grating/sine/edge/starfield patterns (always, no checkbox)
            const supportsSpherical = ['grating', 'sine', 'edge', 'starfield'].includes(patternType);
            sphericalParams.style.display = supportsSpherical ? 'block' : 'none';

            // Update conversion displays
            updateConversionDisplays();

            // Update motion type UI (pole coords visibility)
            updateMotionTypeUI();

            switch (patternType) {
                case 'grating':
                    gratingParams.style.display = 'block';
                    dutyCycleGroup.style.display = 'block';
                    phaseShiftGroup.style.display = 'block';
                    numFramesGroup.style.display = 'none';  // Auto-calculated from wavelength
                    break;
                case 'sine':
                    gratingParams.style.display = 'block';
                    dutyCycleGroup.style.display = 'none';  // No duty cycle for sine
                    phaseShiftGroup.style.display = 'block';
                    numFramesGroup.style.display = 'none';  // Auto-calculated from wavelength
                    break;
                case 'starfield':
                    starfieldParams.style.display = 'block';
                    phaseShiftGroup.style.display = 'none';  // No phase shift for starfield
                    numFramesGroup.style.display = 'block';
                    updateNumFramesDefault();
                    break;
                case 'edge':
                    edgeParams.style.display = 'block';
                    gratingParams.style.display = 'block';  // Show spatial freq for edge
                    dutyCycleGroup.style.display = 'none';  // No duty cycle (edge sweeps 0-100%)
                    phaseShiftGroup.style.display = 'block';
                    numFramesGroup.style.display = 'none';  // Auto-calculated from wavelength (MATLAB parity)
                    break;
                case 'off-on':
                    motionParams.style.display = 'none';  // No motion for off/on
                    phaseShiftGroup.style.display = 'none';  // No phase shift for off/on
                    break;
            }
        }

        /**
         * Update motion type UI
         * Note: Pole coordinates are always shown (they determine direction for all motion types)
         */
        function updateMotionTypeUI() {
            // Pole coordinates are always visible now since they determine direction
            // (matching MATLAB behavior - no CW/CCW, direction from pole + right-hand rule)
        }

        /**
         * Get degrees per pixel based on current arena configuration
         */
        function getDegreesPerPixel() {
            if (!state.arena.config) return 1.8;  // Default for G6 2x10
            const config = state.arena.config.arena;
            const specs = PANEL_SPECS[config.generation];
            // Use columns_installed for partial arenas, fallback to num_cols for full arenas
            const installedCols = config.columns_installed?.length || config.num_cols;
            const pixelCols = installedCols * specs.pixels_per_panel;
            return 360 / pixelCols;
        }

        /**
         * Update conversion displays for spatial frequency and step size
         */
        function updateConversionDisplays() {
            const degPerPx = getDegreesPerPixel();

            // Update spatial frequency conversion
            const spatFreqEl = document.getElementById('spatialFreq');
            const spatFreqUnitEl = document.getElementById('spatialFreqUnit');
            const spatFreqConv = document.getElementById('spatialFreqConversion');

            if (spatFreqEl && spatFreqUnitEl && spatFreqConv) {
                const spatFreqValue = parseFloat(spatFreqEl.value) || 0;
                const spatFreqUnit = spatFreqUnitEl.value;

                if (spatFreqUnit === 'px') {
                    const degrees = (spatFreqValue * degPerPx).toFixed(2);
                    spatFreqConv.textContent = `= ${degrees}¬∞`;
                } else {  // degrees
                    const pixels = (spatFreqValue / degPerPx).toFixed(1);
                    spatFreqConv.textContent = `= ${pixels} px`;
                }
            }

            // Update step size conversion
            const stepSizeEl = document.getElementById('stepSize');
            const stepSizeUnitEl = document.getElementById('stepSizeUnit');
            const stepSizeConv = document.getElementById('stepSizeConversion');

            if (stepSizeEl && stepSizeUnitEl && stepSizeConv) {
                const stepSizeValue = parseFloat(stepSizeEl.value) || 0;
                const stepSizeUnit = stepSizeUnitEl.value;

                if (stepSizeUnit === 'px') {
                    const degrees = (stepSizeValue * degPerPx).toFixed(2);
                    stepSizeConv.textContent = `= ${degrees}¬∞`;
                } else {  // degrees
                    const pixels = (stepSizeValue / degPerPx).toFixed(2);
                    stepSizeConv.textContent = `= ${pixels} px`;
                }
            }

            // Update live frame count preview
            updateFrameCountPreview();
        }

        /**
         * Update the live frame count preview based on current settings
         * Shows how many frames will be generated for patterns that auto-calculate frame count
         */
        function updateFrameCountPreview() {
            const framePreviewEl = document.getElementById('frameCountPreview');
            if (!framePreviewEl) return;

            const patternType = document.getElementById('patternType').value;

            // Only show frame count for patterns that auto-calculate frames
            if (!['grating', 'sine', 'edge'].includes(patternType)) {
                framePreviewEl.style.display = 'none';
                return;
            }

            framePreviewEl.style.display = 'inline';

            // Get step size in pixels
            const stepSizeValue = parseFloat(document.getElementById('stepSize').value) || 1;
            const stepSizeUnit = document.getElementById('stepSizeUnit').value;
            const stepSizePixels = convertStepSizeToPixels(stepSizeValue, stepSizeUnit);

            // Get wavelength for grating/sine/edge
            let numFrames;
            if (patternType === 'edge') {
                // Edge: frames = spatFreq / stepSize + 1 (MATLAB parity)
                // +1 to include both fully-on and fully-off frames
                const spatFreqValue = parseFloat(document.getElementById('spatialFreq').value) || 20;
                const spatFreqUnit = document.getElementById('spatialFreqUnit').value;
                const spatFreqRadians = convertSpatialFreqToRadians(spatFreqValue, spatFreqUnit);
                const stepSizeRadians = convertStepSizeToRadians(stepSizeValue, stepSizeUnit);
                numFrames = Math.max(1, Math.round(spatFreqRadians / stepSizeRadians)) + 1;
            } else {
                // Grating/Sine: frames = wavelength / step size
                const spatFreqValue = parseFloat(document.getElementById('spatialFreq').value) || 20;
                const spatFreqUnit = document.getElementById('spatialFreqUnit').value;

                let wavelengthPixels;
                if (spatFreqUnit === 'px') {
                    wavelengthPixels = spatFreqValue;
                } else {  // degrees
                    const degPerPx = getDegreesPerPixel();
                    wavelengthPixels = spatFreqValue / degPerPx;
                }

                numFrames = Math.ceil(wavelengthPixels / stepSizePixels);
            }

            framePreviewEl.textContent = `(${numFrames} frames)`;
        }

        /**
         * Parse float with explicit default (handles 0 correctly)
         * Unlike || operator, this only uses default for NaN/undefined/empty
         * @param {string} value - The string value to parse
         * @param {number} defaultVal - Default value if parsing fails
         * @returns {number} Parsed value or default
         */
        function parseFloatWithDefault(value, defaultVal) {
            const parsed = parseFloat(value);
            return Number.isFinite(parsed) ? parsed : defaultVal;
        }

        /**
         * Convert spatial frequency value to radians
         * @param {number} value - The input value
         * @param {string} unit - The unit ('px' or 'deg')
         * @returns {number} Spatial frequency in radians
         */
        function convertSpatialFreqToRadians(value, unit) {
            const degPerPx = getDegreesPerPixel();
            const pRad = degPerPx * Math.PI / 180;  // radians per pixel

            if (unit === 'px') {
                // Wavelength in pixels -> spatFreq in radians
                return value * pRad;
            } else {  // degrees
                return value * Math.PI / 180;
            }
        }

        /**
         * Convert step size value to pixels
         * @param {number} value - The input value
         * @param {string} unit - The unit ('px' or 'deg')
         * @returns {number} Step size in pixels
         */
        function convertStepSizeToPixels(value, unit) {
            if (unit === 'px') {
                return value;
            } else {  // degrees
                const degPerPx = getDegreesPerPixel();
                return value / degPerPx;
            }
        }

        /**
         * Convert step size value to radians
         * @param {number} value - The input value
         * @param {string} unit - The unit ('px' or 'deg')
         * @returns {number} Step size in radians
         */
        function convertStepSizeToRadians(value, unit) {
            const degPerPx = getDegreesPerPixel();
            const pRad = degPerPx * Math.PI / 180;  // radians per pixel

            if (unit === 'px') {
                return value * pRad;
            } else {  // degrees
                return value * Math.PI / 180;
            }
        }

        /**
         * Update the default number of frames hint based on arena config
         */
        function updateNumFramesDefault() {
            const hint = document.getElementById('numFramesHint');
            if (state.arena.config) {
                const config = state.arena.config.arena;
                const specs = PANEL_SPECS[config.generation];
                // Use columns_installed for partial arenas
                const installedCols = config.columns_installed?.length || config.num_cols;
                const pixelCols = installedCols * specs.pixels_per_panel;
                // Calculate actual degrees coverage (partial arenas < 360¬∞)
                const degrees = Math.round((installedCols / config.num_cols) * 360);
                hint.textContent = `(${degrees}¬∞ = ${pixelCols} px)`;
                document.getElementById('numFramesInput').value = pixelCols;
            }
        }

        function handleGenerate() {
            // Safety net: exit preview mode if somehow reached while previewing
            if (state.previewMode) {
                exitPreviewMode();
            }

            const config = state.arena.config;
            if (!config) {
                alert('Please select an arena configuration first');
                return;
            }

            // Context-aware: Route based on active tool tab
            const activeTool = state.editor.activeTool;

            if (activeTool === 'frame') {
                // Animate tab - check which mode
                if (state.frameAnimation.mode === 'shifting') {
                    handleBuildSequence();
                } else {
                    handleFrameAnimationGenerate();
                }
                return;
            }

            if (activeTool === 'combine') {
                handleCombine();
                return;
            }

            if (activeTool === 'image') {
                handleImageGenerate();
                return;
            }

            // Default: Generate tab - pattern generation
            const patternType = document.getElementById('patternType').value;
            const gsMode = parseInt(document.getElementById('gsMode').value);
            const highLevel = parseInt(document.getElementById('highLevel').value);
            const lowLevel = parseInt(document.getElementById('lowLevel').value);

            // Build arena object for generator
            // For partial arenas, pass columns_installed so generator uses correct pixel width
            const arena = {
                generation: config.arena.generation,
                rows: config.arena.num_rows,
                cols: config.arena.num_cols,
                columns_installed: config.arena.columns_installed  // null for full arenas
            };

            let params = {
                high: highLevel,
                low: lowLevel,
                gsMode: gsMode
            };

            let pattern;
            let filename;

            try {
                switch (patternType) {
                    case 'grating': {
                        // Spherical grating generation (always uses proper 3D geometry)
                        const spatialFreqValue = parseFloat(document.getElementById('spatialFreq').value);
                        const spatialFreqUnit = document.getElementById('spatialFreqUnit').value;
                        const stepSizeValue = parseFloat(document.getElementById('stepSize').value);
                        const stepSizeUnit = document.getElementById('stepSizeUnit').value;
                        const motionType = document.getElementById('motionType').value;

                        params.spatFreq = convertSpatialFreqToRadians(spatialFreqValue, spatialFreqUnit);
                        params.motionType = motionType;
                        params.waveform = 'square';
                        params.dutyCycle = parseInt(document.getElementById('dutyCycle').value);
                        params.stepSize = convertStepSizeToPixels(stepSizeValue, stepSizeUnit);
                        params.aaSamples = parseInt(document.getElementById('aaSamples').value);
                        params.arenaModel = document.getElementById('arenaModel').value;

                        // Phase shift as percentage of wavelength (0-100%)
                        params.phaseShift = parseFloat(document.getElementById('phaseShift').value) || 0;

                        // Get pole coordinates (used for ALL motion types - determines direction)
                        const poleAzimuth = parseFloatWithDefault(document.getElementById('poleAzimuth').value, 0);
                        const poleElevation = parseFloatWithDefault(document.getElementById('poleElevation').value, -90);
                        params.poleCoord = [poleAzimuth * Math.PI / 180, poleElevation * Math.PI / 180];

                        pattern = PatternGenerator.generateSphericalGrating(params, arena);

                        // Generate filename
                        const freqStr = spatialFreqUnit === 'px' ? `${spatialFreqValue}px` : `${spatialFreqValue}deg`;
                        filename = `grating_${motionType}_${freqStr}_${params.dutyCycle}pct.pat`;
                        break;
                    }

                    case 'sine': {
                        // Spherical sine grating generation (always uses proper 3D geometry)
                        const spatialFreqValue = parseFloat(document.getElementById('spatialFreq').value);
                        const spatialFreqUnit = document.getElementById('spatialFreqUnit').value;
                        const stepSizeValue = parseFloat(document.getElementById('stepSize').value);
                        const stepSizeUnit = document.getElementById('stepSizeUnit').value;
                        const motionType = document.getElementById('motionType').value;

                        params.spatFreq = convertSpatialFreqToRadians(spatialFreqValue, spatialFreqUnit);
                        params.motionType = motionType;
                        params.waveform = 'sine';
                        params.stepSize = convertStepSizeToPixels(stepSizeValue, stepSizeUnit);
                        params.aaSamples = parseInt(document.getElementById('aaSamples').value);
                        params.arenaModel = document.getElementById('arenaModel').value;

                        // Phase shift as percentage of wavelength (0-100%)
                        params.phaseShift = parseFloat(document.getElementById('phaseShift').value) || 0;

                        // Get pole coordinates (used for ALL motion types - determines direction)
                        const poleAzimuthSine = parseFloatWithDefault(document.getElementById('poleAzimuth').value, 0);
                        const poleElevationSine = parseFloatWithDefault(document.getElementById('poleElevation').value, -90);
                        params.poleCoord = [poleAzimuthSine * Math.PI / 180, poleElevationSine * Math.PI / 180];

                        pattern = PatternGenerator.generateSphericalGrating(params, arena);

                        // Generate filename
                        const freqStr = spatialFreqUnit === 'px' ? `${spatialFreqValue}px` : `${spatialFreqValue}deg`;
                        filename = `sine_${motionType}_${freqStr}.pat`;
                        break;
                    }

                    case 'starfield': {
                        // Starfield uses spherical motion with pole coordinates
                        const stepSizeValueStar = parseFloat(document.getElementById('stepSize').value);
                        const stepSizeUnitStar = document.getElementById('stepSizeUnit').value;
                        const motionTypeStar = document.getElementById('motionType').value;

                        params.dotCount = parseInt(document.getElementById('dotCount').value);
                        params.dotSize = parseInt(document.getElementById('dotSize').value);
                        params.seed = parseInt(document.getElementById('randomSeed').value);
                        params.brightness = highLevel;
                        params.background = lowLevel;
                        params.motionType = motionTypeStar;
                        params.stepSize = convertStepSizeToPixels(stepSizeValueStar, stepSizeUnitStar);
                        params.numFrames = parseInt(document.getElementById('numFramesInput').value);
                        params.arenaModel = document.getElementById('arenaModel').value;

                        // Advanced starfield options (MATLAB parity)
                        params.dotBrightnessMode = document.getElementById('dotBrightnessMode').value;
                        params.dotSizeMode = document.getElementById('dotSizeMode').value;
                        params.dotOcclusion = document.getElementById('dotOcclusion').value;
                        params.snapDots = document.getElementById('snapDots').checked;

                        // Get pole coordinates (determines direction)
                        const poleAzimuthStar = parseFloatWithDefault(document.getElementById('poleAzimuth').value, 0);
                        const poleElevationStar = parseFloatWithDefault(document.getElementById('poleElevation').value, -90);
                        params.poleCoord = [poleAzimuthStar * Math.PI / 180, poleElevationStar * Math.PI / 180];

                        pattern = PatternGenerator.generateStarfield(params, arena);
                        filename = `starfield_${motionTypeStar}_${params.dotCount}dots_${params.numFrames}f.pat`;
                        break;
                    }

                    case 'edge': {
                        // Edge patterns use spherical coordinates with duty-cycle sweep
                        const spatialFreqValueEdge = parseFloat(document.getElementById('spatialFreq').value);
                        const spatialFreqUnitEdge = document.getElementById('spatialFreqUnit').value;
                        const motionTypeEdge = document.getElementById('motionType').value;

                        params.spatFreq = convertSpatialFreqToRadians(spatialFreqValueEdge, spatialFreqUnitEdge);
                        params.motionType = motionTypeEdge;
                        params.aaSamples = parseInt(document.getElementById('aaSamples').value);
                        params.arenaModel = document.getElementById('arenaModel').value;

                        // Phase shift as percentage of wavelength (0-100%)
                        params.phaseShift = parseFloat(document.getElementById('phaseShift').value) || 0;

                        // Auto-calculate numFrames from spatFreq and step size (MATLAB parity)
                        // MATLAB: num_frames = max([1 round(param.spat_freq/param.step_size)]) + 1
                        // Edge sweeps duty cycle 0%‚Üí100% across these frames
                        const stepSizeValueEdge = parseFloat(document.getElementById('stepSize').value);
                        const stepSizeUnitEdge = document.getElementById('stepSizeUnit').value;
                        const stepSizeRadiansEdge = convertStepSizeToRadians(stepSizeValueEdge, stepSizeUnitEdge);
                        params.numFrames = Math.max(1, Math.round(params.spatFreq / stepSizeRadiansEdge)) + 1;

                        // Get pole coordinates (determines direction)
                        const poleAzimuthEdge = parseFloatWithDefault(document.getElementById('poleAzimuth').value, 0);
                        const poleElevationEdge = parseFloatWithDefault(document.getElementById('poleElevation').value, -90);
                        params.poleCoord = [poleAzimuthEdge * Math.PI / 180, poleElevationEdge * Math.PI / 180];

                        pattern = PatternGenerator.generateEdge(params, arena);
                        const freqStrEdge = spatialFreqUnitEdge === 'px' ? `${spatialFreqValueEdge}px` : `${spatialFreqValueEdge}deg`;
                        filename = `edge_${motionTypeEdge}_${freqStrEdge}_${params.numFrames}f.pat`;
                        break;
                    }

                    case 'off-on':
                        pattern = PatternGenerator.generateOffOn(params, arena);
                        filename = `off_on_${highLevel}.pat`;
                        break;

                    default:
                        alert(`Pattern type "${patternType}" not implemented yet`);
                        return;
                }

                // Validate generated pattern
                const validation = PatternGenerator.validate(pattern);
                if (!validation.valid) {
                    console.error('Pattern validation errors:', validation.errors);
                    alert('Generated pattern has errors:\n' + validation.errors.join('\n'));
                    return;
                }
                if (validation.warnings.length > 0) {
                    console.warn('Pattern validation warnings:', validation.warnings);
                }

                // Convert to state.pattern format
                state.pattern = {
                    generation: pattern.generation,
                    gsMode: pattern.gs_val,
                    numFrames: pattern.numFrames,
                    pixelRows: pattern.pixelRows,
                    pixelCols: pattern.pixelCols,
                    frames: pattern.frames,
                    stretchValues: pattern.stretchValues
                };

                state.filename = filename;
                state.isDirty = true;
                state.editor.currentFrame = 0;

                // Lock arena config after generating pattern
                lockArenaConfig();

                updateStatus();
                renderCurrentViewer();
                updateFrameInfo();

                console.log('Generated pattern:', patternType, params, state.pattern);

            } catch (err) {
                console.error('Pattern generation error:', err);
                alert('Failed to generate pattern: ' + err.message);
            }
        }

        // ============================================
        // Frame Operations
        // ============================================
        function captureFrame() {
            if (!state.pattern) {
                alert('No pattern loaded');
                return;
            }

            const frameData = state.pattern.frames[state.editor.currentFrame];
            const frameCopy = new Uint8Array(frameData);

            // Generate cylindrical icon thumbnail (falls back to flat if arena unavailable)
            const thumbnail = generateIconThumbnail(
                frameCopy,
                state.pattern.pixelRows,
                state.pattern.pixelCols,
                state.pattern.gsMode,
                state.pattern.generation
            );

            const clipboardEntry = {
                id: Date.now(),
                frame: frameCopy,
                thumbnail: thumbnail,
                timestamp: new Date(),
                name: `Frame ${state.clipboardFrames.length + 1}`,
                pixelRows: state.pattern.pixelRows,
                pixelCols: state.pattern.pixelCols,
                gsMode: state.pattern.gsMode,
                generation: state.pattern.generation
            };

            // Limit frames clipboard to ~10 entries
            if (state.clipboardFrames.length >= 10) {
                state.clipboardFrames.shift(); // Remove oldest
            }
            state.clipboardFrames.push(clipboardEntry);
            updateClipboardUI();
            switchClipboardTab('frames');  // Show frames tab

            console.log('Captured frame to clipboard:', clipboardEntry.name);
        }

        // Store current pattern to patterns clipboard
        function storePatternToClipboard() {
            if (!state.pattern) {
                alert('No pattern to store');
                return;
            }

            // Generate animated thumbnails for hover preview
            // Sample up to 10 frames evenly distributed
            const numFrames = state.pattern.numFrames;
            const maxThumbnails = Math.min(10, numFrames);
            const frameStep = Math.max(1, Math.floor(numFrames / maxThumbnails));

            const animatedThumbnails = [];
            for (let i = 0; i < numFrames && animatedThumbnails.length < maxThumbnails; i += frameStep) {
                const thumb = generateIconThumbnail(
                    state.pattern.frames[i],
                    state.pattern.pixelRows,
                    state.pattern.pixelCols,
                    state.pattern.gsMode,
                    state.pattern.generation
                );
                animatedThumbnails.push(thumb);
            }

            // Use middle thumbnail as static preview
            const middleIdx = Math.floor(animatedThumbnails.length / 2);
            const thumbnail = animatedThumbnails[middleIdx] || animatedThumbnails[0];

            const patternEntry = {
                id: Date.now(),
                pattern: {
                    generation: state.pattern.generation,
                    gsMode: state.pattern.gsMode,
                    numFrames: state.pattern.numFrames,
                    pixelRows: state.pattern.pixelRows,
                    pixelCols: state.pattern.pixelCols,
                    frames: state.pattern.frames.map(f => new Uint8Array(f)),
                    stretchValues: state.pattern.stretchValues ? [...state.pattern.stretchValues] : null
                },
                thumbnail: thumbnail,
                animatedThumbnails: animatedThumbnails,  // Array of frame thumbnails for hover animation
                timestamp: new Date(),
                name: state.filename || `Pattern ${state.clipboardPatterns.length + 1}`
            };

            // Limit patterns clipboard to ~10 entries
            if (state.clipboardPatterns.length >= 10) {
                state.clipboardPatterns.shift();
            }
            state.clipboardPatterns.push(patternEntry);
            updateClipboardUI();
            switchClipboardTab('patterns');  // Show patterns tab

            console.log('Stored pattern to clipboard:', patternEntry.name);
        }

        function generateThumbnail(frameData, pixelRows, pixelCols, gsMode) {
            const canvas = document.createElement('canvas');
            const thumbSize = 40;
            canvas.width = thumbSize;
            canvas.height = thumbSize;
            const ctx = canvas.getContext('2d');

            // Calculate scaling
            const scaleX = thumbSize / pixelCols;
            const scaleY = thumbSize / pixelRows;
            const maxVal = gsMode === 2 ? 1 : 15;

            // Draw pixels
            for (let row = 0; row < pixelRows; row++) {
                for (let col = 0; col < pixelCols; col++) {
                    const value = frameData[row * pixelCols + col];
                    const brightness = value / maxVal;

                    const r = Math.round(brightness * 0.6 * 255);
                    const g = Math.round(brightness * 255);
                    const b = Math.round(brightness * 0.2 * 255);

                    ctx.fillStyle = brightness > 0 ? `rgb(${r},${g},${b})` : '#1e2329';

                    // Flip Y so row 0 is at bottom
                    const canvasY = (pixelRows - 1 - row) * scaleY;
                    ctx.fillRect(col * scaleX, canvasY, Math.ceil(scaleX), Math.ceil(scaleY));
                }
            }

            return canvas;
        }

        // Generate cylindrical icon thumbnail using icon-generator
        function generateIconThumbnail(frameData, pixelRows, pixelCols, gsMode, generation) {
            // Validate arena config exists and matches generation
            if (!state.arena.config || state.arena.config.arena.generation !== generation) {
                // Fall back to flat thumbnail if arena doesn't match
                return generateThumbnail(frameData, pixelRows, pixelCols, gsMode);
            }

            const patternData = {
                frames: [frameData],
                rows: pixelRows,
                cols: pixelCols,
                grayscaleMode: gsMode === 2 ? 'GS2' : 'GS16'
            };

            const arenaConfig = state.arena.config.arena;

            try {
                return generatePatternIcon(patternData, arenaConfig, {
                    width: 56,
                    height: 56,
                    backgroundColor: '#1a1f26',  // Dark theme surface color
                    innerRadiusRatio: 0.4,       // Thicker ring = more pattern visible
                    padding: 2,                   // Minimal padding
                    showGaps: false,
                    showOutlines: false,
                    frameIndex: 0
                });
            } catch (err) {
                console.warn('Icon generation failed, using flat thumbnail:', err);
                return generateThumbnail(frameData, pixelRows, pixelCols, gsMode);
            }
        }

        // Clear both clipboards (called when arena changes)
        function clearClipboards() {
            state.clipboardFrames = [];
            state.clipboardPatterns = [];
            state.selectedFrameId = null;
            state.selectedPatternId = null;
            state.loadedClipboardFrameId = null;
            state.loadedClipboardPatternId = null;

            // Clear the main pattern viewer
            state.pattern = null;
            state.editor.currentFrame = 0;
            state.filename = null;
            state.isDirty = false;

            // Clear combine patterns
            state.combinePatternA = null;
            state.combinePatternB = null;
            updateCombineInfo();

            // Clear frame animation sequence
            state.frameAnimation.sequence = [];
            updateSequenceBuilderUI();

            // Clear shifting frame status
            clearShiftingFrame();

            // Update UI
            updateClipboardUI();
            renderCurrentViewer();
            updateStatus();
            updateFrameInfo();

            console.log('Clipboards and viewer cleared due to arena change');
        }

        // Switch clipboard tab (frames or patterns)
        function switchClipboardTab(tabType) {
            const framesTab = document.getElementById('framesTab');
            const patternsTab = document.getElementById('patternsTab');
            const framesContent = document.getElementById('clipboardFrames');
            const patternsContent = document.getElementById('clipboardPatterns');

            if (tabType === 'frames') {
                framesTab.classList.add('active');
                patternsTab.classList.remove('active');
                framesContent.classList.add('active');
                patternsContent.classList.remove('active');
            } else {
                framesTab.classList.remove('active');
                patternsTab.classList.add('active');
                framesContent.classList.remove('active');
                patternsContent.classList.add('active');
            }
        }

        function updateClipboardUI() {
            // Update Frames section
            const framesContainer = document.getElementById('clipboardFrames');
            const framesCountEl = document.getElementById('framesCount');

            framesCountEl.textContent = `(${state.clipboardFrames.length})`;

            if (state.clipboardFrames.length === 0) {
                framesContainer.innerHTML = '<span class="clipboard-empty">Capture frames from viewer</span>';
            } else {
                framesContainer.innerHTML = '';
                for (let i = 0; i < state.clipboardFrames.length; i++) {
                    const entry = state.clipboardFrames[i];
                    const thumb = createClipboardThumb(entry, 'frame', i);
                    framesContainer.appendChild(thumb);
                }
            }

            // Update Patterns section
            const patternsContainer = document.getElementById('clipboardPatterns');
            const patternsCountEl = document.getElementById('patternsCount');

            patternsCountEl.textContent = `(${state.clipboardPatterns.length})`;

            if (state.clipboardPatterns.length === 0) {
                patternsContainer.innerHTML = '<span class="clipboard-empty">Capture patterns from viewer</span>';
            } else {
                patternsContainer.innerHTML = '';
                for (let i = 0; i < state.clipboardPatterns.length; i++) {
                    const entry = state.clipboardPatterns[i];
                    const item = createPatternClipboardItem(entry, i);
                    patternsContainer.appendChild(item);
                }
            }
        }

        // Create a pattern item with animated thumbnail and editable name
        function createPatternClipboardItem(entry, index) {
            const item = document.createElement('div');
            item.className = 'clipboard-pattern-item';

            const isSelected = state.selectedPatternId === entry.id;
            if (isSelected) {
                item.classList.add('selected');
            }

            item.title = `${entry.name}\n${entry.pattern ? entry.pattern.frames.length + ' frames' : '1 frame'}\n${formatTimestamp(entry.timestamp)}\nDouble-click to load pattern`;

            // Animated thumbnail container
            const thumbContainer = document.createElement('div');
            thumbContainer.className = 'pattern-thumbnail';

            // Create image element for thumbnail
            const thumbImg = document.createElement('img');
            thumbImg.src = entry.thumbnail || '';
            thumbImg.alt = entry.name;
            thumbContainer.appendChild(thumbImg);

            // Frame count badge on thumbnail
            const numFrames = entry.pattern ? entry.pattern.frames.length : 1;
            if (numFrames > 1) {
                const frameBadge = document.createElement('span');
                frameBadge.className = 'frame-badge';
                frameBadge.textContent = `${numFrames}f`;
                thumbContainer.appendChild(frameBadge);
            }

            // Animation state for hover
            let animationInterval = null;
            let currentFrameIdx = 0;

            // Hover animation for multi-frame patterns
            if (entry.animatedThumbnails && entry.animatedThumbnails.length > 1) {
                thumbContainer.addEventListener('mouseenter', () => {
                    currentFrameIdx = 0;
                    animationInterval = setInterval(() => {
                        currentFrameIdx = (currentFrameIdx + 1) % entry.animatedThumbnails.length;
                        thumbImg.src = entry.animatedThumbnails[currentFrameIdx];
                    }, 150);  // ~6-7 FPS for smooth preview
                });

                thumbContainer.addEventListener('mouseleave', () => {
                    if (animationInterval) {
                        clearInterval(animationInterval);
                        animationInterval = null;
                    }
                    thumbImg.src = entry.thumbnail;  // Reset to static thumbnail
                });
            }

            item.appendChild(thumbContainer);

            // Editable name
            const nameSpan = document.createElement('span');
            nameSpan.className = 'pattern-name';
            nameSpan.textContent = entry.name || `Pattern ${index + 1}`;
            nameSpan.contentEditable = true;
            nameSpan.spellcheck = false;
            nameSpan.addEventListener('blur', () => {
                entry.name = nameSpan.textContent.trim() || `Pattern ${index + 1}`;
            });
            nameSpan.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    nameSpan.blur();
                }
            });
            nameSpan.addEventListener('click', (e) => {
                e.stopPropagation(); // Don't select when editing name
            });
            item.appendChild(nameSpan);

            // Delete button
            const deleteBtn = document.createElement('button');
            deleteBtn.className = 'delete-btn';
            deleteBtn.textContent = '√ó';
            deleteBtn.title = 'Delete pattern';
            deleteBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                deleteClipboardEntry(entry.id, 'pattern');
            });
            item.appendChild(deleteBtn);

            // Click to select
            item.addEventListener('click', () => {
                selectClipboardEntry(entry.id, 'pattern');
            });

            // Double-click to load
            item.addEventListener('dblclick', () => {
                loadClipboardPattern(entry.id);
            });

            // Right-click context menu
            item.addEventListener('contextmenu', (e) => {
                e.preventDefault();
                showClipboardContextMenu(e, entry, 'pattern');
            });

            return item;
        }

        function createClipboardThumb(entry, type, index) {
            const thumb = document.createElement('div');
            thumb.className = 'clipboard-thumb';

            // Check if selected (single selection per type)
            const isSelected = type === 'frame'
                ? state.selectedFrameId === entry.id
                : state.selectedPatternId === entry.id;
            if (isSelected) {
                thumb.classList.add('selected');
            }

            // Check if this item is currently loaded in viewer
            const isLoaded = type === 'frame'
                ? state.loadedClipboardFrameId === entry.id
                : state.loadedClipboardPatternId === entry.id;
            if (isLoaded) {
                thumb.classList.add('loaded');
            }

            thumb.title = `${entry.name}\n${formatTimestamp(entry.timestamp)}\nDouble-click to view`;

            // Use actual thumbnail if available
            if (entry.thumbnail) {
                if (typeof entry.thumbnail === 'string') {
                    // Data URL from icon generator
                    const img = document.createElement('img');
                    img.src = entry.thumbnail;
                    img.style.width = '100%';
                    img.style.height = '100%';
                    img.style.borderRadius = '2px';
                    thumb.appendChild(img);
                } else {
                    // Canvas element (legacy flat thumbnail)
                    thumb.appendChild(entry.thumbnail.cloneNode(true));
                }
                thumb.style.padding = '0';
            } else {
                thumb.textContent = (index + 1).toString();
            }

            // Add LOADED badge if this item is currently loaded
            if (isLoaded) {
                const badge = document.createElement('span');
                badge.className = 'loaded-badge';
                badge.textContent = 'LOADED';
                thumb.appendChild(badge);
            }

            // Add delete button
            const deleteBtn = document.createElement('button');
            deleteBtn.className = 'delete-btn';
            deleteBtn.textContent = '√ó';
            deleteBtn.title = `Delete ${type}`;
            deleteBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                deleteClipboardEntry(entry.id, type);
            });
            thumb.appendChild(deleteBtn);

            // Single click: select (single selection only)
            thumb.addEventListener('click', (e) => {
                e.stopPropagation();
                selectClipboardEntry(entry.id, type);
            });

            // Double click: send to editor (frame) or load (pattern)
            thumb.addEventListener('dblclick', (e) => {
                e.stopPropagation();
                if (type === 'frame') {
                    sendClipboardFrameToEditor(entry.id);
                } else {
                    loadClipboardPattern(entry.id);
                }
            });

            // Right-click context menu
            thumb.addEventListener('contextmenu', (e) => {
                e.preventDefault();
                showClipboardContextMenu(e, entry, type);
            });

            return thumb;
        }

        function selectClipboardEntry(id, type) {
            if (type === 'frame') {
                // Single selection: toggle or set
                state.selectedFrameId = state.selectedFrameId === id ? null : id;
            } else {
                state.selectedPatternId = state.selectedPatternId === id ? null : id;
            }
            updateClipboardUI();
            console.log(`Selected ${type}:`, id);
        }

        function deleteClipboardEntry(id, type) {
            if (type === 'frame') {
                const idx = state.clipboardFrames.findIndex(e => e.id === id);
                if (idx >= 0) {
                    state.clipboardFrames.splice(idx, 1);
                    if (state.selectedFrameId === id) {
                        state.selectedFrameId = null;
                    }
                    // Clear loaded frame reference if this was the loaded frame
                    if (state.loadedClipboardFrameId === id) {
                        state.loadedClipboardFrameId = null;
                        state.editor.editingClipboardId = null;
                        clearShiftingFrame();
                    }
                }
            } else {
                const idx = state.clipboardPatterns.findIndex(e => e.id === id);
                if (idx >= 0) {
                    state.clipboardPatterns.splice(idx, 1);
                    if (state.selectedPatternId === id) {
                        state.selectedPatternId = null;
                    }
                    // Clear loaded pattern reference if this was the loaded pattern
                    if (state.loadedClipboardPatternId === id) {
                        state.loadedClipboardPatternId = null;
                    }
                }
            }
            updateClipboardUI();
            console.log(`Deleted ${type}:`, id);
        }

        function loadClipboardPattern(id) {
            const entry = state.clipboardPatterns.find(e => e.id === id);
            if (!entry || !entry.pattern) return;

            // Load pattern into main view
            state.pattern = JSON.parse(JSON.stringify(entry.pattern)); // Deep copy
            state.pattern.frames = entry.pattern.frames.map(f => new Uint8Array(f));
            state.filename = entry.name.endsWith('.pat') ? entry.name : `${entry.name}.pat`;
            state.isDirty = false;
            state.editor.currentFrame = 0;

            // Track loaded clipboard item for LOADED badge
            state.loadedClipboardPatternId = id;
            state.loadedClipboardFrameId = null;

            // Exit edit mode when loading a pattern (patterns are view-only)
            setActiveViewer('grid');

            updateStatus();
            updateFrameInfo();
            updateClipboardUI();  // Refresh to show LOADED badge

            console.log('Loaded clipboard pattern:', entry.name);
        }

        function sendClipboardFrameToEditor(id) {
            const entry = state.clipboardFrames.find(e => e.id === id);
            if (!entry) return;

            // Create a single-frame pattern from this clipboard entry
            state.pattern = {
                generation: entry.generation || 'G6',
                gsMode: entry.gsMode,
                numFrames: 1,
                pixelRows: entry.pixelRows,
                pixelCols: entry.pixelCols,
                frames: [new Uint8Array(entry.frame)],
                stretchValues: [1]
            };

            state.editor.editingClipboardId = id;
            state.editor.currentFrame = 0;
            state.filename = `${entry.name}.pat`;
            state.isDirty = false;

            // Track loaded clipboard item for LOADED badge
            state.loadedClipboardFrameId = id;
            state.loadedClipboardPatternId = null;

            // Switch to edit view
            setActiveViewer('edit');

            // Update shifting frame status if in Animate tab (with icon thumbnail)
            updateShiftingFrameStatus(entry.name, entry.thumbnail);

            updateStatus();
            updateFrameInfo();
            updateClipboardUI();  // Refresh to show LOADED badge

            console.log('Loaded clipboard frame for editing:', entry.name);
        }

        function updateClipboardFromEditor() {
            if (!state.editor.editingClipboardId || !state.pattern) {
                alert('No clipboard frame is currently being edited');
                return;
            }

            const entry = state.clipboardFrames.find(e => e.id === state.editor.editingClipboardId);
            if (!entry) {
                alert('Original clipboard entry not found');
                return;
            }

            // Update the clipboard entry with edited frame data
            entry.frame = new Uint8Array(state.pattern.frames[state.editor.currentFrame]);
            entry.thumbnail = generateThumbnail(
                entry.frame,
                entry.pixelRows,
                entry.pixelCols,
                entry.gsMode
            );
            entry.timestamp = new Date();

            updateClipboardUI();
            console.log('Updated clipboard frame:', entry.name);
        }

        function showClipboardContextMenu(e, entry, type) {
            // Remove existing context menu
            const existingMenu = document.getElementById('clipboardContextMenu');
            if (existingMenu) existingMenu.remove();

            const menu = document.createElement('div');
            menu.id = 'clipboardContextMenu';
            menu.style.cssText = `
                position: fixed;
                left: ${e.clientX}px;
                top: ${e.clientY}px;
                background: var(--surface);
                border: 1px solid var(--border);
                border-radius: 4px;
                padding: 0.25rem 0;
                z-index: 1000;
                min-width: 120px;
            `;

            // Different menu items for frames vs patterns
            const menuItems = type === 'frame' ? [
                { label: 'Edit', action: () => sendClipboardFrameToEditor(entry.id) },
                { label: 'Rename...', action: () => renameClipboardEntry(entry, type) },
                { label: 'Delete', action: () => deleteClipboardEntry(entry.id, type) }
            ] : [
                { label: 'Load Pattern', action: () => loadClipboardPattern(entry.id) },
                { label: 'Use as Pattern A', action: () => usePatternAs(entry.id, 'A') },
                { label: 'Use as Pattern B', action: () => usePatternAs(entry.id, 'B') },
                { label: 'Rename...', action: () => renameClipboardEntry(entry, type) },
                { label: 'Delete', action: () => deleteClipboardEntry(entry.id, type) }
            ];

            menuItems.forEach(item => {
                const menuItem = document.createElement('div');
                menuItem.textContent = item.label;
                menuItem.style.cssText = `
                    padding: 0.4rem 0.75rem;
                    cursor: pointer;
                    font-size: 0.75rem;
                    color: var(--text);
                `;
                menuItem.addEventListener('mouseenter', () => {
                    menuItem.style.background = 'var(--accent)';
                    menuItem.style.color = 'var(--bg)';
                });
                menuItem.addEventListener('mouseleave', () => {
                    menuItem.style.background = 'transparent';
                    menuItem.style.color = 'var(--text)';
                });
                menuItem.addEventListener('click', () => {
                    menu.remove();
                    item.action();
                });
                menu.appendChild(menuItem);
            });

            document.body.appendChild(menu);

            // Close menu when clicking elsewhere
            const closeMenu = () => {
                menu.remove();
                document.removeEventListener('click', closeMenu);
            };
            setTimeout(() => document.addEventListener('click', closeMenu), 0);
        }

        function renameClipboardEntry(entry, type) {
            const newName = prompt('Enter new name:', entry.name);
            if (newName && newName.trim()) {
                entry.name = newName.trim();
                updateClipboardUI();
            }
        }

        function usePatternAs(id, slot) {
            const entry = state.clipboardPatterns.find(e => e.id === id);
            if (!entry || !entry.pattern) return;

            // Deep copy pattern
            const patternCopy = {
                generation: entry.pattern.generation,
                gsMode: entry.pattern.gsMode,
                numFrames: entry.pattern.numFrames,
                pixelRows: entry.pattern.pixelRows,
                pixelCols: entry.pattern.pixelCols,
                frames: entry.pattern.frames.map(f => new Uint8Array(f)),
                stretchValues: entry.pattern.stretchValues ? [...entry.pattern.stretchValues] : null
            };

            if (slot === 'A') {
                state.combinePatternA = patternCopy;
                console.log('Set Pattern A from clipboard:', entry.name);
            } else {
                state.combinePatternB = patternCopy;
                console.log('Set Pattern B from clipboard:', entry.name);
            }

            // Update combiner UI if visible
            updateCombinerUI();
        }

        function formatTimestamp(date) {
            const diff = Date.now() - date.getTime();
            const minutes = Math.floor(diff / 60000);
            if (minutes < 1) return 'just now';
            if (minutes < 60) return `${minutes}m ago`;
            const hours = Math.floor(minutes / 60);
            if (hours < 24) return `${hours}h ago`;
            return date.toLocaleDateString();
        }

        // ============================================
        // Playback
        // ============================================
        function togglePlayback() {
            if (state.playback.isPlaying) {
                stopPlayback();
            } else {
                startPlayback();
            }
        }

        function startPlayback() {
            if (!state.pattern || state.pattern.numFrames <= 1) return;

            state.playback.isPlaying = true;
            document.getElementById('playBtn').textContent = '‚è∏';

            // Use absolute value of fps for interval, direction from sign
            const fps = state.playback.fps;
            const interval = 1000 / Math.abs(fps);
            const direction = fps >= 0 ? 1 : -1;

            state.playback.intervalId = setInterval(() => {
                navigateFrame(direction);
            }, interval);
        }

        function stopPlayback() {
            state.playback.isPlaying = false;
            document.getElementById('playBtn').textContent = '‚ñ∂';

            if (state.playback.intervalId) {
                clearInterval(state.playback.intervalId);
                state.playback.intervalId = null;
            }
        }

        function navigateFrame(delta) {
            if (!state.pattern) return;

            let newFrame = state.editor.currentFrame + delta;
            if (newFrame >= state.pattern.numFrames) newFrame = 0;
            if (newFrame < 0) newFrame = state.pattern.numFrames - 1;

            goToFrame(newFrame);
        }

        function goToFrame(frameIndex) {
            if (!state.pattern) return;

            state.editor.currentFrame = frameIndex;
            updateFrameInfo();
            renderCurrentViewer();
        }

        function updateFrameInfo() {
            const frameInfo = document.getElementById('frameInfo');
            const stretchInput = document.getElementById('stretchValue');
            if (state.pattern) {
                frameInfo.textContent = `${state.editor.currentFrame + 1} / ${state.pattern.numFrames}`;
                // Update stretch value display
                const stretch = state.pattern.stretchValues?.[state.editor.currentFrame] || 1;
                stretchInput.value = stretch;
            } else {
                frameInfo.textContent = '‚Äî / ‚Äî';
                stretchInput.value = 1;
            }
        }

        function handleStretchChange(e) {
            if (!state.pattern) return;

            const newStretch = parseInt(e.target.value);
            if (isNaN(newStretch) || newStretch < 1) {
                e.target.value = 1;
                return;
            }

            // Initialize stretchValues if not present
            if (!state.pattern.stretchValues) {
                state.pattern.stretchValues = new Array(state.pattern.numFrames).fill(1);
            }

            state.pattern.stretchValues[state.editor.currentFrame] = newStretch;
            state.isDirty = true;
            updateStatus();
            console.log(`Set frame ${state.editor.currentFrame} stretch to ${newStretch}`);
        }

        // ============================================
        // Edit Mode Functions
        // ============================================
        function initEditPalette() {
            const palette = document.getElementById('editPalette');
            palette.innerHTML = '';

            // Default to GS16 (0-15)
            for (let i = 0; i <= 15; i++) {
                const swatch = document.createElement('div');
                swatch.className = 'palette-swatch';
                swatch.dataset.value = i;

                const brightness = i / 15;
                const r = Math.round(brightness * 0.6 * 255);
                const g = Math.round(brightness * 255);
                const b = Math.round(brightness * 0.2 * 255);
                swatch.style.background = brightness > 0 ? `rgb(${r},${g},${b})` : '#1e2329';
                swatch.style.color = i < 8 ? '#888' : '#000';
                swatch.textContent = i;

                if (i === 15) swatch.classList.add('selected');

                swatch.addEventListener('click', () => selectDrawColor(i));
                palette.appendChild(swatch);
            }
        }

        function updateEditPalette(gsMode) {
            const palette = document.getElementById('editPalette');
            const maxVal = gsMode === 2 ? 1 : 15;

            palette.innerHTML = '';

            for (let i = 0; i <= maxVal; i++) {
                const swatch = document.createElement('div');
                swatch.className = 'palette-swatch';
                swatch.dataset.value = i;

                const brightness = i / maxVal;
                const r = Math.round(brightness * 0.6 * 255);
                const g = Math.round(brightness * 255);
                const b = Math.round(brightness * 0.2 * 255);
                swatch.style.background = brightness > 0 ? `rgb(${r},${g},${b})` : '#1e2329';

                if (gsMode === 2) {
                    swatch.textContent = i === 0 ? 'Off' : 'On';
                    swatch.style.width = '40px';
                    swatch.style.fontSize = '0.6rem';
                } else {
                    swatch.textContent = i;
                    swatch.style.color = i < 8 ? '#888' : '#000';
                }

                if (i === maxVal) swatch.classList.add('selected');

                swatch.addEventListener('click', () => selectDrawColor(i));
                palette.appendChild(swatch);
            }

            // Adjust current color if needed
            if (state.editor.drawColor > maxVal) {
                state.editor.drawColor = maxVal;
            }
            document.getElementById('currentColorDisplay').textContent = state.editor.drawColor;
        }

        function selectDrawColor(value) {
            state.editor.drawColor = value;

            document.querySelectorAll('.edit-palette .palette-swatch').forEach(s => {
                s.classList.toggle('selected', parseInt(s.dataset.value) === value);
            });

            document.getElementById('currentColorDisplay').textContent = value;
        }

        function handleCanvasClick(e) {
            if (!state.editor.editMode || !state.pattern) return;

            const canvas = document.getElementById('gridCanvas');
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            const { pixelRows, pixelCols } = state.pattern;
            const pixelSize = canvas.width / pixelCols;

            const col = Math.floor(x / pixelSize);
            // Flip Y: canvas Y=0 is top, but row 0 is bottom
            const row = pixelRows - 1 - Math.floor(y / pixelSize);

            if (col >= 0 && col < pixelCols && row >= 0 && row < pixelRows) {
                setPixel(row, col, state.editor.drawColor);
            }
        }

        function handleCanvasMouseMove(e) {
            if (!state.editor.editMode || !state.pattern || e.buttons !== 1) return;
            handleCanvasClick(e);
        }

        function setPixel(row, col, value) {
            if (!state.pattern) return;

            const { pixelCols, frames } = state.pattern;
            const frame = frames[state.editor.currentFrame];
            const idx = row * pixelCols + col;

            frame[idx] = value;
            state.isDirty = true;
            updateStatus();
            renderCurrentViewer();
        }

        function fillRow(row) {
            if (!state.pattern || !state.editor.editMode) return;

            const { pixelCols, frames } = state.pattern;
            const frame = frames[state.editor.currentFrame];

            for (let col = 0; col < pixelCols; col++) {
                frame[row * pixelCols + col] = state.editor.drawColor;
            }

            state.isDirty = true;
            updateStatus();
            renderCurrentViewer();
        }

        function fillColumn(col) {
            if (!state.pattern || !state.editor.editMode) return;

            const { pixelRows, pixelCols, frames } = state.pattern;
            const frame = frames[state.editor.currentFrame];

            for (let row = 0; row < pixelRows; row++) {
                frame[row * pixelCols + col] = state.editor.drawColor;
            }

            state.isDirty = true;
            updateStatus();
            renderCurrentViewer();
        }

        function flipHorizontal() {
            if (!state.pattern) return;

            const { pixelRows, pixelCols, frames } = state.pattern;
            const frame = frames[state.editor.currentFrame];

            for (let row = 0; row < pixelRows; row++) {
                for (let col = 0; col < Math.floor(pixelCols / 2); col++) {
                    const leftIdx = row * pixelCols + col;
                    const rightIdx = row * pixelCols + (pixelCols - 1 - col);
                    const temp = frame[leftIdx];
                    frame[leftIdx] = frame[rightIdx];
                    frame[rightIdx] = temp;
                }
            }

            state.isDirty = true;
            updateStatus();
            renderCurrentViewer();
        }

        function flipVertical() {
            if (!state.pattern) return;

            const { pixelRows, pixelCols, frames } = state.pattern;
            const frame = frames[state.editor.currentFrame];

            for (let row = 0; row < Math.floor(pixelRows / 2); row++) {
                for (let col = 0; col < pixelCols; col++) {
                    const topIdx = row * pixelCols + col;
                    const bottomIdx = (pixelRows - 1 - row) * pixelCols + col;
                    const temp = frame[topIdx];
                    frame[topIdx] = frame[bottomIdx];
                    frame[bottomIdx] = temp;
                }
            }

            state.isDirty = true;
            updateStatus();
            renderCurrentViewer();
        }

        function invertBrightness() {
            if (!state.pattern) return;

            const { pixelRows, pixelCols, gsMode, frames } = state.pattern;
            const frame = frames[state.editor.currentFrame];
            const maxVal = gsMode === 2 ? 1 : 15;

            for (let i = 0; i < frame.length; i++) {
                frame[i] = maxVal - frame[i];
            }

            state.isDirty = true;
            updateStatus();
            renderCurrentViewer();
        }

        function applyFindReplace() {
            if (!state.pattern) return;

            const findVal = parseInt(document.getElementById('findValue').value);
            const replaceVal = parseInt(document.getElementById('replaceValue').value);
            const { frames } = state.pattern;
            const frame = frames[state.editor.currentFrame];

            let count = 0;
            for (let i = 0; i < frame.length; i++) {
                if (frame[i] === findVal) {
                    frame[i] = replaceVal;
                    count++;
                }
            }

            document.getElementById('findReplaceModal').classList.remove('visible');

            if (count > 0) {
                state.isDirty = true;
                updateStatus();
                renderCurrentViewer();
                console.log(`Replaced ${count} pixels: ${findVal} -> ${replaceVal}`);
            } else {
                console.log(`No pixels found with value ${findVal}`);
            }
        }

        // ============================================
        // Combine Operations
        // ============================================
        function handleSetPatternA() {
            if (!state.pattern) {
                alert('No current pattern to use');
                return;
            }
            // Deep copy the pattern to prevent changes from affecting the combine slot
            state.combinePatternA = {
                ...state.pattern,
                frames: state.pattern.frames.map(f => new Uint8Array(f)),
                filename: state.filename || 'Current pattern'
            };
            updateCombineInfo();
            console.log('Set Pattern A from current:', state.combinePatternA.filename);
        }

        async function handleLoadPatternA(e) {
            const file = e.target.files[0];
            if (!file) return;

            try {
                const buffer = await file.arrayBuffer();
                state.combinePatternA = normalizePattern(PatParser.parsePatFile(buffer));
                state.combinePatternA.filename = file.name;

                updateCombineInfo();
                console.log('Loaded pattern A:', state.combinePatternA);
            } catch (err) {
                console.error('Failed to load pattern A:', err);
                alert('Failed to load pattern file: ' + err.message);
            }

            e.target.value = '';
        }

        function handleClearPatternA() {
            state.combinePatternA = null;
            updateCombineInfo();
            console.log('Cleared Pattern A');
        }

        function handleSetPatternB() {
            if (!state.pattern) {
                alert('No current pattern to use');
                return;
            }
            // Deep copy the pattern to prevent changes from affecting the combine slot
            state.combinePatternB = {
                ...state.pattern,
                frames: state.pattern.frames.map(f => new Uint8Array(f)),
                filename: state.filename || 'Current pattern'
            };
            updateCombineInfo();
            console.log('Set Pattern B from current:', state.combinePatternB.filename);
        }

        function handleClearPatternB() {
            state.combinePatternB = null;
            updateCombineInfo();
            console.log('Cleared Pattern B');
        }

        function handleSwap() {
            const temp = state.combinePatternA;
            state.combinePatternA = state.combinePatternB;
            state.combinePatternB = temp;

            updateCombineInfo();
            console.log('Swapped Pattern A and B');
        }

        function updateCombineModeUI() {
            const mode = document.getElementById('combineMode').value;

            // Hide all mode-specific options
            document.getElementById('combineMaskOptions').style.display = 'none';
            document.getElementById('combineSplitOptions').style.display = 'none';

            // Show length options only for non-sequential modes AND when patterns have different lengths
            const lengthOptions = document.getElementById('combineLengthOptions');
            const showLengthOptions = mode !== 'sequential' &&
                state.combinePatternA && state.combinePatternB &&
                state.combinePatternA.numFrames !== state.combinePatternB.numFrames;
            lengthOptions.style.display = showLengthOptions ? 'block' : 'none';

            // Show mode-specific options
            if (mode === 'mask') {
                document.getElementById('combineMaskOptions').style.display = 'block';
            } else if (mode === 'split-h' || mode === 'split-v') {
                document.getElementById('combineSplitOptions').style.display = 'block';
                updateSplitPositionDisplay();
            }
        }

        function updateSplitPositionDisplay() {
            const percent = parseInt(document.getElementById('splitPosition').value);
            document.getElementById('splitPositionPercent').textContent = percent + '%';

            // Calculate pixel position based on pattern dimensions and split direction
            const mode = document.getElementById('combineMode').value;
            let pixelText = 'pixel ‚Äî';

            if (state.combinePatternA) {
                if (mode === 'split-h') {
                    const totalPixels = state.combinePatternA.pixelCols;
                    const pixelPos = Math.floor(totalPixels * percent / 100);
                    pixelText = `pixel ${pixelPos} / ${totalPixels}`;
                } else if (mode === 'split-v') {
                    const totalPixels = state.combinePatternA.pixelRows;
                    const pixelPos = Math.floor(totalPixels * percent / 100);
                    pixelText = `pixel ${pixelPos} / ${totalPixels}`;
                }
            }

            document.getElementById('splitPositionPixel').textContent = pixelText;
        }

        function handleCombine() {
            if (!state.combinePatternA) {
                alert('Set or load Pattern A first');
                return;
            }
            if (!state.combinePatternB) {
                alert('Set or load Pattern B first');
                return;
            }

            const mode = document.getElementById('combineMode').value;
            const lengthHandling = document.getElementById('lengthHandling').value;

            try {
                let options = {};
                let combineMode = mode;

                // Parse mode-specific options
                if (mode === 'mask') {
                    options.mode = 'threshold';
                    options.threshold = parseInt(document.getElementById('maskThreshold').value);
                    combineMode = 'mask';
                } else if (mode === 'blend') {
                    options.mode = 'blend';
                    combineMode = 'blend';
                } else if (mode === 'split-h') {
                    options.direction = 'horizontal';
                    options.splitPosition = parseInt(document.getElementById('splitPosition').value) / 100;
                    combineMode = 'split';
                } else if (mode === 'split-v') {
                    options.direction = 'vertical';
                    options.splitPosition = parseInt(document.getElementById('splitPosition').value) / 100;
                    combineMode = 'split';
                }

                // Handle different frame counts
                let patternA = state.combinePatternA;
                let patternB = state.combinePatternB;

                if (combineMode !== 'sequential' && patternA.numFrames !== patternB.numFrames) {
                    const maxFrames = Math.max(patternA.numFrames, patternB.numFrames);
                    const minFrames = Math.min(patternA.numFrames, patternB.numFrames);

                    if (lengthHandling === 'truncate') {
                        // Truncate both to shorter length
                        patternA = truncatePattern(patternA, minFrames);
                        patternB = truncatePattern(patternB, minFrames);
                    } else if (lengthHandling === 'extend') {
                        // Extend shorter pattern by repeating last frame
                        patternA = extendPattern(patternA, maxFrames);
                        patternB = extendPattern(patternB, maxFrames);
                    }
                    // 'loop' is the default behavior in combiner.js
                }

                const combined = combinePatterns(patternA, patternB, combineMode, options);

                state.pattern = combined;
                state.isDirty = true;

                // Generate suggested filename based on combine mode and input patterns
                const nameA = getBaseName(state.combinePatternA.filename || 'patternA');
                const nameB = getBaseName(state.combinePatternB.filename || 'patternB');
                let modeSuffix;
                switch (combineMode) {
                    case 'sequential': modeSuffix = 'seq'; break;
                    case 'blend': modeSuffix = 'blend'; break;
                    case 'mask': modeSuffix = 'mask'; break;
                    case 'split-h': modeSuffix = `splitH${options.splitPosition || 50}`; break;
                    case 'split-v': modeSuffix = `splitV${options.splitPosition || 50}`; break;
                    default: modeSuffix = 'combined';
                }
                state.filename = `${nameA}_${nameB}_${modeSuffix}.pat`;

                state.editor.currentFrame = 0;

                updateStatus();
                renderCurrentViewer();
                updateFrameInfo();
                updateCombineInfo();

                console.log('Combined pattern:', combined);
            } catch (err) {
                alert('Combine failed: ' + err.message);
                console.error('Combine error:', err);
            }
        }

        /**
         * Handle Generate button for Image tab
         */
        function handleImageGenerate() {
            if (!ImageConverter.hasImage()) {
                alert('Please load an image first');
                return;
            }

            const gsMode = parseInt(document.getElementById('imageGsMode').value);
            const invert = document.getElementById('imageInvert').checked;

            const config = state.arena.config;
            if (!config) {
                alert('Please select an arena configuration first');
                return;
            }

            // Build arena object for generator
            const arena = {
                generation: config.arena.generation,
                rows: config.arena.num_rows,
                cols: config.arena.num_cols,
                columns_installed: config.arena.columns_installed
            };

            try {
                const pattern = ImageConverter.generatePattern({ gsMode, invert }, arena);

                state.pattern = pattern;
                state.isDirty = true;
                state.editor.currentFrame = 0;

                // Generate suggested filename
                const imageInfo = ImageConverter.getImageInfo();
                const baseName = imageInfo?.name?.replace(/\.[^.]+$/, '') || 'image';
                state.filename = `${baseName}_frame.pat`;

                // Lock arena config after generating pattern
                lockArenaConfig();

                // Switch to grid view to show result
                setActiveViewer('grid');

                updateStatus();
                renderCurrentViewer();
                updateFrameInfo();

                console.log('Generated pattern from image:', state.pattern);
            } catch (err) {
                console.error('Image conversion error:', err);
                alert('Failed to convert image: ' + err.message);
            }
        }

        /**
         * Initialize Image Converter tab
         */
        function initImageConverter() {
            const loadBtn = document.getElementById('loadImageBtn');
            const scaleSlider = document.getElementById('imageScale');
            const scaleValue = document.getElementById('imageScaleValue');
            const rotationInput = document.getElementById('imageRotation');
            const fitBtn = document.getElementById('fitImageBtn');
            const previewCanvas = document.getElementById('imagePreviewCanvas');
            const imageInfo = document.getElementById('imageInfo');

            // Set canvas size
            function resizeCanvas() {
                const container = document.getElementById('imagePreviewContainer');
                previewCanvas.width = container.clientWidth;
                previewCanvas.height = container.clientHeight;
                updateImagePreview();
            }

            // Update arena dimensions when config changes
            function updateArenaDimensions() {
                if (state.arena.config) {
                    const config = state.arena.config.arena;
                    const panelSpecs = PANEL_SPECS[config.generation];
                    // Use columns_installed for partial arenas
                    const installedCols = config.columns_installed?.length || config.num_cols;
                    const pixelCols = installedCols * panelSpecs.pixels_per_panel;
                    const pixelRows = config.num_rows * panelSpecs.pixels_per_panel;
                    ImageConverter.setArenaDimensions(pixelCols, pixelRows);
                }
            }

            // Update preview
            function updateImagePreview() {
                updateArenaDimensions();
                ImageConverter.renderPreview(previewCanvas);
            }

            // Make updateImagePreview available globally for tab switching
            window.updateImagePreview = updateImagePreview;

            // Load image button
            loadBtn.addEventListener('click', () => {
                const input = document.createElement('input');
                input.type = 'file';
                input.accept = 'image/png,image/jpeg,image/jpg';
                input.onchange = async (e) => {
                    const file = e.target.files[0];
                    if (!file) return;

                    try {
                        const dims = await ImageConverter.loadImage(file);
                        imageInfo.innerHTML = `<strong style="color: var(--text);">${file.name}</strong><br>${dims.width} x ${dims.height} pixels`;

                        // Auto-fit on load
                        const fitTransform = ImageConverter.calculateFitTransform();
                        ImageConverter.setTransform(fitTransform);
                        scaleSlider.value = Math.round(fitTransform.scale * 100);
                        scaleValue.textContent = scaleSlider.value + '%';
                        rotationInput.value = 0;

                        updateImagePreview();
                    } catch (err) {
                        alert('Failed to load image: ' + err.message);
                    }
                };
                input.click();
            });

            // Scale slider
            scaleSlider.addEventListener('input', () => {
                const scale = parseInt(scaleSlider.value) / 100;
                scaleValue.textContent = scaleSlider.value + '%';
                ImageConverter.setTransform({ scale });
                updateImagePreview();
            });

            // Rotation input
            rotationInput.addEventListener('change', () => {
                let rotation = parseFloat(rotationInput.value) || 0;
                rotation = Math.max(-180, Math.min(180, rotation));
                rotationInput.value = rotation;
                ImageConverter.setTransform({ rotation });
                updateImagePreview();
            });

            // Fit button
            fitBtn.addEventListener('click', () => {
                const fitTransform = ImageConverter.calculateFitTransform();
                ImageConverter.setTransform(fitTransform);
                scaleSlider.value = Math.round(fitTransform.scale * 100);
                scaleValue.textContent = scaleSlider.value + '%';
                rotationInput.value = 0;
                updateImagePreview();
            });

            // Drag-to-pan
            previewCanvas.addEventListener('mousedown', (e) => {
                const rect = previewCanvas.getBoundingClientRect();
                ImageConverter.startDrag(e.clientX - rect.left, e.clientY - rect.top, previewCanvas);
            });

            previewCanvas.addEventListener('mousemove', (e) => {
                const rect = previewCanvas.getBoundingClientRect();
                if (ImageConverter.updateDrag(e.clientX - rect.left, e.clientY - rect.top, previewCanvas)) {
                    updateImagePreview();
                }
            });

            previewCanvas.addEventListener('mouseup', () => {
                ImageConverter.endDrag();
            });

            previewCanvas.addEventListener('mouseleave', () => {
                ImageConverter.endDrag();
            });

            // Resize observer for canvas
            const resizeObserver = new ResizeObserver(resizeCanvas);
            resizeObserver.observe(document.getElementById('imagePreviewContainer'));

            // Initial setup
            resizeCanvas();
        }

        /**
         * Get base name without extension from a filename
         */
        function getBaseName(filename) {
            if (!filename) return 'pattern';
            // Remove .pat extension and path
            let name = filename.replace(/\.pat$/i, '');
            // Remove any path components
            const lastSlash = Math.max(name.lastIndexOf('/'), name.lastIndexOf('\\'));
            if (lastSlash >= 0) {
                name = name.substring(lastSlash + 1);
            }
            // Truncate to reasonable length for combined names
            if (name.length > 20) {
                name = name.substring(0, 20);
            }
            return name;
        }

        /**
         * Truncate a pattern to specified number of frames
         */
        function truncatePattern(pattern, numFrames) {
            if (pattern.numFrames <= numFrames) return pattern;
            return {
                ...pattern,
                frames: pattern.frames.slice(0, numFrames),
                numFrames: numFrames
            };
        }

        /**
         * Extend a pattern by repeating last frame
         */
        function extendPattern(pattern, numFrames) {
            if (pattern.numFrames >= numFrames) return pattern;
            const newFrames = [...pattern.frames];
            const lastFrame = pattern.frames[pattern.frames.length - 1];
            while (newFrames.length < numFrames) {
                newFrames.push(new Uint8Array(lastFrame)); // Copy last frame
            }
            return {
                ...pattern,
                frames: newFrames,
                numFrames: numFrames
            };
        }

        /**
         * Update the default total frames based on direction and arena config
         */
        function updateDefaultFrames() {
            const direction = document.getElementById('rotateDirection').value;
            const framesInput = document.getElementById('totalFrames');
            const framesHint = document.getElementById('framesHint');

            // Get pixel dimensions from arena config or clipboard entry
            let pixelCols = 200;  // Default
            let pixelRows = 60;   // Default

            if (state.arena.config) {
                const config = state.arena.config.arena;
                const specs = PANEL_SPECS[config.generation];
                // Use columns_installed for partial arenas
                const installedCols = config.columns_installed?.length || config.num_cols;
                pixelCols = installedCols * specs.pixels_per_panel;
                pixelRows = config.num_rows * specs.pixels_per_panel;
            } else if (state.clipboardFrames.length > 0) {
                // Fallback to clipboard entry dimensions
                pixelCols = state.clipboardFrames[0].pixelCols;
                pixelRows = state.clipboardFrames[0].pixelRows;
            }

            let defaultFrames;
            let hint;
            if (direction.startsWith('h-')) {
                // Horizontal motion: full 360¬∞ loop
                defaultFrames = pixelCols;
                hint = `(360¬∞ = ${pixelCols} px)`;
            } else {
                // Vertical motion: full vertical traverse
                defaultFrames = pixelRows;
                hint = `(full height = ${pixelRows} px)`;
            }

            framesInput.value = defaultFrames;
            framesHint.textContent = hint;
        }

        function handleBuildSequence() {
            if (state.clipboardFrames.length === 0) {
                alert('Capture some frames first');
                return;
            }

            // Use the loaded frame (double-clicked) for Frame Shifting mode
            // Falls back to selected frame, then first clipboard frame
            let baseEntry = null;

            if (state.loadedClipboardFrameId) {
                // Use the double-clicked/loaded frame
                baseEntry = state.clipboardFrames.find(e => e.id === state.loadedClipboardFrameId);
            }

            if (!baseEntry && state.selectedFrameId) {
                // Fall back to single-click selected frame
                baseEntry = state.clipboardFrames.find(e => e.id === state.selectedFrameId);
            }

            if (!baseEntry) {
                // Fall back to first clipboard entry
                baseEntry = state.clipboardFrames[0];
            }

            if (!baseEntry) {
                alert('No frame available for shifting');
                return;
            }

            // Get motion parameters from UI
            const stepSize = parseInt(document.getElementById('rotateStep').value) || 1;
            const direction = document.getElementById('rotateDirection').value;
            const totalFrames = parseInt(document.getElementById('totalFrames').value) || 200;

            const { pixelRows, pixelCols, gsMode, generation } = baseEntry;

            // Build motion sequence based on direction
            const frames = [];
            const isHorizontal = direction.startsWith('h-');
            const isPositive = direction === 'h-cw' || direction === 'v-up';

            for (let f = 0; f < totalFrames; f++) {
                const offset = (isPositive ? f : -f) * stepSize;
                let shiftedFrame;
                if (isHorizontal) {
                    shiftedFrame = shiftFrameHorizontally(baseEntry.frame, pixelCols, pixelRows, offset);
                } else {
                    shiftedFrame = shiftFrameVertically(baseEntry.frame, pixelCols, pixelRows, offset);
                }
                frames.push(shiftedFrame);
            }

            // Create new pattern from sequence
            state.pattern = {
                generation: generation || 'G6',
                gsMode: gsMode,
                numFrames: totalFrames,
                pixelRows: pixelRows,
                pixelCols: pixelCols,
                frames: frames,
                stretchValues: new Array(totalFrames).fill(1)
            };

            // Generate filename based on motion type
            const dirLabel = direction.replace('-', '_');
            state.filename = `${baseEntry.name}_${dirLabel}_${totalFrames}f.pat`;
            state.isDirty = true;
            state.editor.currentFrame = 0;
            state.editor.editingClipboardId = null;

            // Clear selection
            state.selectedClipboardIds = [];
            updateClipboardUI();

            // Switch to 2D view (exit edit mode if active)
            setActiveViewer('grid');

            updateStatus();
            updateFrameInfo();

            console.log(`Generated motion sequence: ${totalFrames} frames, step=${stepSize}px, direction=${direction}`);
        }

        /**
         * Shift frame horizontally (wrap around)
         */
        function shiftFrameHorizontally(frameData, pixelCols, pixelRows, offset) {
            const shifted = new Uint8Array(frameData.length);

            // Normalize offset to be positive and within bounds
            offset = ((offset % pixelCols) + pixelCols) % pixelCols;

            for (let row = 0; row < pixelRows; row++) {
                for (let col = 0; col < pixelCols; col++) {
                    const srcCol = (col + offset) % pixelCols;
                    shifted[row * pixelCols + col] = frameData[row * pixelCols + srcCol];
                }
            }

            return shifted;
        }

        /**
         * Shift frame vertically (wrap around)
         * Positive offset = pattern shifts upward on screen
         */
        function shiftFrameVertically(frameData, pixelCols, pixelRows, offset) {
            const shifted = new Uint8Array(frameData.length);

            // Normalize offset to be positive and within bounds
            offset = ((offset % pixelRows) + pixelRows) % pixelRows;

            for (let row = 0; row < pixelRows; row++) {
                const srcRow = (row + offset) % pixelRows;
                for (let col = 0; col < pixelCols; col++) {
                    shifted[row * pixelCols + col] = frameData[srcRow * pixelCols + col];
                }
            }

            return shifted;
        }

        // ============================================
        // Animate Tab Mode Toggle
        // ============================================
        function setAnimateMode(mode) {
            state.frameAnimation.mode = mode;

            // Update toggle buttons
            document.getElementById('shiftingModeBtn').classList.toggle('active', mode === 'shifting');
            document.getElementById('animationModeBtn').classList.toggle('active', mode === 'animation');

            // Update content visibility
            document.getElementById('shiftingMode').classList.toggle('active', mode === 'shifting');
            document.getElementById('animationMode').classList.toggle('active', mode === 'animation');

            // Update sequence UI if switching to animation mode
            if (mode === 'animation') {
                updateSequenceBuilderUI();
            }
        }

        function updateSequenceBuilderUI() {
            const container = document.getElementById('sequenceFrames');
            const emptyMsg = document.getElementById('sequenceEmpty');
            const sequence = state.frameAnimation.sequence;

            if (sequence.length === 0) {
                container.innerHTML = '';
                emptyMsg.style.display = 'block';
            } else {
                emptyMsg.style.display = 'none';
                container.innerHTML = '';

                sequence.forEach((entry, index) => {
                    const frameEl = createSequenceFrameElement(entry, index);
                    container.appendChild(frameEl);
                });
            }
        }

        function createSequenceFrameElement(entry, index) {
            const frameEl = document.createElement('div');
            frameEl.className = 'sequence-frame';
            frameEl.draggable = true;
            frameEl.dataset.index = index;
            frameEl.title = `Frame ${index + 1}: ${entry.name || 'Frame'}`;

            // Show thumbnail if available - handle both string (data URL) and DOM node
            if (entry.thumbnail) {
                if (typeof entry.thumbnail === 'string') {
                    // Data URL from icon generator
                    const img = document.createElement('img');
                    img.src = entry.thumbnail;
                    img.style.width = '100%';
                    img.style.height = '100%';
                    img.style.borderRadius = '2px';
                    frameEl.appendChild(img);
                } else if (entry.thumbnail.cloneNode) {
                    // DOM node (canvas)
                    frameEl.appendChild(entry.thumbnail.cloneNode(true));
                }
            } else {
                frameEl.textContent = index + 1;
            }

            // Remove button
            const removeBtn = document.createElement('button');
            removeBtn.className = 'remove-btn';
            removeBtn.textContent = '√ó';
            removeBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                removeFromSequence(index);
            });
            frameEl.appendChild(removeBtn);

            // Drag and drop for reordering
            frameEl.addEventListener('dragstart', (e) => {
                e.dataTransfer.setData('text/plain', index);
                frameEl.classList.add('dragging');
                // Add class to container for styling context
                document.getElementById('sequenceFrames').classList.add('dragging-active');
            });

            frameEl.addEventListener('dragend', () => {
                frameEl.classList.remove('dragging');
                document.getElementById('sequenceFrames').classList.remove('dragging-active');
                // Clean up any remaining drag-over classes
                document.querySelectorAll('.sequence-frame.drag-over').forEach(f => {
                    f.classList.remove('drag-over');
                });
            });

            frameEl.addEventListener('dragover', (e) => {
                e.preventDefault();
                // Only add drag-over if not the dragged element
                if (!frameEl.classList.contains('dragging')) {
                    frameEl.classList.add('drag-over');
                }
            });

            frameEl.addEventListener('dragleave', () => {
                frameEl.classList.remove('drag-over');
            });

            frameEl.addEventListener('drop', (e) => {
                e.preventDefault();
                frameEl.classList.remove('drag-over');
                const fromIndex = parseInt(e.dataTransfer.getData('text/plain'));
                const toIndex = index;
                if (fromIndex !== toIndex) {
                    reorderSequence(fromIndex, toIndex);
                }
            });

            // Click to select/deselect
            frameEl.addEventListener('click', (e) => {
                if (e.target.classList.contains('remove-btn')) return; // Ignore remove button clicks

                // Toggle selection
                const wasSelected = frameEl.classList.contains('selected');

                // Deselect all frames
                document.querySelectorAll('.sequence-frame.selected').forEach(f => {
                    f.classList.remove('selected');
                });

                // Update selection feedback
                const feedbackEl = document.getElementById('sequenceSelectionFeedback');

                // Select this frame (if it wasn't already selected)
                if (!wasSelected) {
                    frameEl.classList.add('selected');
                    state.frameAnimation.selectedIndex = index;
                    if (feedbackEl) {
                        feedbackEl.textContent = `Frame ${index + 1} of ${state.frameAnimation.sequence.length} selected`;
                        feedbackEl.style.display = 'block';
                    }
                } else {
                    state.frameAnimation.selectedIndex = -1;
                    if (feedbackEl) {
                        feedbackEl.style.display = 'none';
                    }
                }
            });

            return frameEl;
        }

        function addAllClipboardFramesToSequence() {
            if (state.clipboardFrames.length === 0) {
                alert('No frames in clipboard. Capture some frames first.');
                return;
            }

            // Add all clipboard frames to the sequence
            state.clipboardFrames.forEach(entry => {
                // Clone thumbnail - handle both string (data URL) and DOM node cases
                let thumbnailCopy = null;
                if (entry.thumbnail) {
                    if (typeof entry.thumbnail === 'string') {
                        // Data URL - just copy the string
                        thumbnailCopy = entry.thumbnail;
                    } else if (entry.thumbnail.cloneNode) {
                        // DOM node - clone it
                        thumbnailCopy = entry.thumbnail.cloneNode(true);
                    }
                }

                state.frameAnimation.sequence.push({
                    ...entry,
                    // Create a copy of the frame data
                    frame: new Uint8Array(entry.frame),
                    thumbnail: thumbnailCopy
                });
            });

            updateSequenceBuilderUI();
            console.log(`Added ${state.clipboardFrames.length} frames to sequence`);
        }

        function clearFrameAnimationSequence() {
            state.frameAnimation.sequence = [];
            state.frameAnimation.selectedIndex = -1;
            updateSequenceBuilderUI();
            console.log('Frame animation sequence cleared');
        }

        function clearShiftingFrame() {
            // Clear the loaded frame from state
            state.loadedClipboardFrameId = null;

            // Update UI - hide icon preview
            document.getElementById('shiftingFramePreview').style.display = 'none';
            document.getElementById('shiftingFrameInfo').textContent = 'No frame loaded - double-click a frame in clipboard';
            document.getElementById('shiftingFrameInfo').style.color = 'var(--text-dim)';
            document.getElementById('clearShiftingFrameBtn').style.display = 'none';

            console.log('Shifting source frame cleared');
        }

        function updateShiftingFrameStatus(frameName, thumbnail) {
            // Show icon preview if thumbnail available
            const previewEl = document.getElementById('shiftingFramePreview');
            const iconEl = document.getElementById('shiftingFrameIcon');
            if (thumbnail) {
                iconEl.src = thumbnail;
                previewEl.style.display = 'block';
            } else {
                previewEl.style.display = 'none';
            }

            document.getElementById('shiftingFrameInfo').innerHTML = `<span style="color: var(--accent);">‚úì Loaded:</span> ${frameName}`;
            document.getElementById('clearShiftingFrameBtn').style.display = 'block';
        }

        function removeFromSequence(index) {
            state.frameAnimation.sequence.splice(index, 1);
            updateSequenceBuilderUI();
        }

        function reorderSequence(fromIndex, toIndex) {
            const [moved] = state.frameAnimation.sequence.splice(fromIndex, 1);
            state.frameAnimation.sequence.splice(toIndex, 0, moved);
            updateSequenceBuilderUI();
        }

        function previewFrameAnimation() {
            const sequence = state.frameAnimation.sequence;

            if (sequence.length === 0) {
                alert('Add frames to the sequence first');
                return;
            }

            // Build pattern from sequence
            const firstEntry = sequence[0];
            const { pixelRows, pixelCols, gsMode, generation } = firstEntry;

            const frames = sequence.map(entry => new Uint8Array(entry.frame));

            state.pattern = {
                generation: generation || 'G6',
                gsMode: gsMode || 2,
                numFrames: frames.length,
                pixelRows: pixelRows,
                pixelCols: pixelCols,
                frames: frames,
                stretchValues: new Array(frames.length).fill(1)
            };

            state.filename = `animation_${frames.length}f.pat`;
            state.isDirty = true;
            state.editor.currentFrame = 0;

            // Switch to 2D view
            setActiveViewer('grid');

            updateStatus();
            updateFrameInfo();

            console.log(`Preview animation: ${frames.length} frames`);
        }

        // Called from global Generate button when in Frame Animation mode
        function handleFrameAnimationGenerate() {
            previewFrameAnimation();

            // Auto-start playback if pattern was created
            if (state.pattern && state.pattern.frames.length > 1) {
                if (!state.playback.isPlaying) {
                    togglePlayback();
                }
            }
        }

        function saveFrameAnimationAsPat() {
            const sequence = state.frameAnimation.sequence;

            if (sequence.length === 0) {
                alert('Add frames to the sequence first');
                return;
            }

            // Build pattern from sequence first
            previewFrameAnimation();

            // Then trigger save
            if (state.pattern) {
                savePatternFile();
            }
        }

        // Legacy alias for backwards compatibility
        function rotateFrameHorizontally(frameData, pixelCols, pixelRows, offset) {
            return shiftFrameHorizontally(frameData, pixelCols, pixelRows, offset);
        }

        // ============================================
        // Rendering
        // ============================================
        function renderCurrentViewer() {
            if (state.editor.activeViewer === 'grid') {
                renderGridViewer();
            } else if (state.editor.activeViewer === '3d') {
                render3DViewer();
            }
        }

        function render3DViewer() {
            if (!threeViewer) {
                init3DViewer();
                return;
            }

            if (state.pattern) {
                // Ensure arena config matches pattern dimensions
                const patternGen = state.pattern.generation;
                const patternSpecs = PANEL_SPECS[patternGen];
                const patternCols = state.pattern.pixelCols / patternSpecs.pixels_per_panel;
                const patternRows = state.pattern.pixelRows / patternSpecs.pixels_per_panel;

                // Check if current arena config matches pattern
                const currentConfig = state.arena.config;
                // For partial arenas, use columns_installed length instead of num_cols
                const currentInstalledCols = currentConfig?.arena?.columns_installed?.length
                    || currentConfig?.arena?.num_cols;
                const needsReinit = !currentConfig ||
                    currentConfig.arena.generation !== patternGen ||
                    currentInstalledCols !== patternCols ||
                    currentConfig.arena.num_rows !== patternRows;

                if (needsReinit) {
                    // Try to find matching config
                    const matchingConfig = findMatchingArenaConfig(patternGen, patternCols, patternRows);
                    if (matchingConfig) {
                        state.arena.configName = matchingConfig;
                        state.arena.config = getConfig(matchingConfig);
                        document.getElementById('arenaConfigStatus').value = matchingConfig;
                        threeViewer.reinit(state.arena.config, patternSpecs);
                    }
                }

                threeViewer.setPattern(state.pattern);
                threeViewer.setFrame(state.editor.currentFrame);
            } else {
                // Clear the 3D viewer when no pattern is loaded
                threeViewer.setPattern(null);
            }
        }

        // Find arena config that matches pattern dimensions
        function findMatchingArenaConfig(generation, numCols, numRows) {
            const configsByGen = getConfigsByGeneration();
            for (const [gen, configs] of Object.entries(configsByGen)) {
                for (const configObj of configs) {
                    // For partial arenas, use columns_installed length instead of num_cols
                    const configCols = configObj.arena.columns_installed?.length
                        || configObj.arena.num_cols;
                    if (configObj.arena.generation === generation &&
                        configCols === numCols &&
                        configObj.arena.num_rows === numRows) {
                        return configObj.name;
                    }
                }
            }
            return null;
        }

        function renderGridViewer() {
            const container = document.getElementById('gridViewer');

            if (!state.pattern) {
                container.innerHTML = `
                    <div class="placeholder">
                        <div class="placeholder-icon">‚¨ö</div>
                        <h2>No Pattern Loaded</h2>
                        <p>Load a .pat file or generate a new pattern to view it here.</p>
                    </div>
                `;
                return;
            }

            const { pixelRows, pixelCols, frames, gsMode } = state.pattern;
            const frame = frames[state.editor.currentFrame];

            // Calculate pixel size to fit in viewer
            const headerSize = state.editor.editMode ? 24 : 0;
            const maxWidth = container.clientWidth - 40 - headerSize;
            const maxHeight = container.clientHeight - 40 - headerSize;
            const pixelSize = Math.max(1, Math.min(
                Math.floor(maxWidth / pixelCols),
                Math.floor(maxHeight / pixelRows)
            ));

            // Create or update container structure based on edit mode
            if (state.editor.editMode) {
                container.innerHTML = `
                    <div class="grid-with-headers" style="width: ${pixelCols * pixelSize + headerSize}px;">
                        <div class="corner-spacer"></div>
                        <div class="col-headers" id="colHeaders" style="display: flex;"></div>
                        <div class="row-headers" id="rowHeaders" style="display: flex; flex-direction: column;"></div>
                        <div class="grid-canvas-container">
                            <canvas id="gridCanvas"></canvas>
                        </div>
                    </div>
                `;

                // Create column headers
                const colHeaders = document.getElementById('colHeaders');
                for (let col = 0; col < pixelCols; col++) {
                    const header = document.createElement('div');
                    header.className = 'col-header';
                    header.style.width = pixelSize + 'px';
                    header.style.height = '24px';
                    header.textContent = col % 10 === 0 ? col : '';
                    header.title = `Fill column ${col}`;
                    header.addEventListener('click', () => fillColumn(col));
                    colHeaders.appendChild(header);
                }

                // Create row headers (row 0 at bottom)
                const rowHeaders = document.getElementById('rowHeaders');
                for (let row = pixelRows - 1; row >= 0; row--) {
                    const header = document.createElement('div');
                    header.className = 'row-header';
                    header.style.width = '24px';
                    header.style.height = pixelSize + 'px';
                    header.textContent = row % 10 === 0 ? row : '';
                    header.title = `Fill row ${row}`;
                    header.addEventListener('click', () => fillRow(row));
                    rowHeaders.appendChild(header);
                }
            } else {
                // Non-edit mode: simple canvas container
                let canvasContainer = container.querySelector('.grid-canvas-container');
                if (!canvasContainer || container.querySelector('.grid-with-headers')) {
                    container.innerHTML = '<div class="grid-canvas-container"><canvas id="gridCanvas"></canvas></div>';
                }
            }

            const canvas = document.getElementById('gridCanvas');
            const ctx = canvas.getContext('2d');

            canvas.width = pixelCols * pixelSize;
            canvas.height = pixelRows * pixelSize;

            // Add mouse handlers for edit mode
            if (state.editor.editMode) {
                canvas.style.cursor = 'crosshair';
                canvas.onmousedown = handleCanvasClick;
                canvas.onmousemove = handleCanvasMouseMove;
            } else {
                canvas.style.cursor = 'default';
                canvas.onmousedown = null;
                canvas.onmousemove = null;
            }

            // Draw pixels (row 0 = bottom)
            const maxVal = gsMode === 2 ? 1 : 15;
            for (let row = 0; row < pixelRows; row++) {
                for (let col = 0; col < pixelCols; col++) {
                    const value = frame[row * pixelCols + col];
                    const brightness = value / maxVal;

                    // Green phosphor color
                    const r = Math.round(brightness * 0.6 * 255);
                    const g = Math.round(brightness * 255);
                    const b = Math.round(brightness * 0.2 * 255);

                    ctx.fillStyle = brightness > 0 ? `rgb(${r},${g},${b})` : '#1e2329';

                    // Flip Y so row 0 is at bottom
                    const canvasY = (pixelRows - 1 - row) * pixelSize;
                    ctx.fillRect(col * pixelSize, canvasY, pixelSize, pixelSize);
                }
            }

            // Draw grid lines in edit mode for better visibility
            if (state.editor.editMode && pixelSize >= 4) {
                ctx.strokeStyle = 'rgba(45, 54, 64, 0.5)';
                ctx.lineWidth = 1;
                for (let row = 0; row <= pixelRows; row++) {
                    ctx.beginPath();
                    ctx.moveTo(0, row * pixelSize);
                    ctx.lineTo(canvas.width, row * pixelSize);
                    ctx.stroke();
                }
                for (let col = 0; col <= pixelCols; col++) {
                    ctx.beginPath();
                    ctx.moveTo(col * pixelSize, 0);
                    ctx.lineTo(col * pixelSize, canvas.height);
                    ctx.stroke();
                }
            }

            // Draw panel boundaries
            if (state.editor.showPanelBoundaries && state.arena.config) {
                const pixelsPerPanel = PANEL_SPECS[state.arena.config.arena.generation].pixels_per_panel;

                ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.lineWidth = 1;

                // Vertical lines
                for (let col = pixelsPerPanel; col < pixelCols; col += pixelsPerPanel) {
                    ctx.beginPath();
                    ctx.moveTo(col * pixelSize, 0);
                    ctx.lineTo(col * pixelSize, canvas.height);
                    ctx.stroke();
                }

                // Horizontal lines
                for (let row = pixelsPerPanel; row < pixelRows; row += pixelsPerPanel) {
                    const canvasY = (pixelRows - row) * pixelSize;
                    ctx.beginPath();
                    ctx.moveTo(0, canvasY);
                    ctx.lineTo(canvas.width, canvasY);
                    ctx.stroke();
                }
            }

            // Draw panel numbers
            if (state.editor.showPanelNumbers && state.arena.config) {
                const pixelsPerPanel = PANEL_SPECS[state.arena.config.arena.generation].pixels_per_panel;
                const panelCols = state.arena.config.arena.num_cols;
                const panelRows = state.arena.config.arena.num_rows;

                // Calculate font size based on panel size in pixels
                const panelPixelWidth = pixelsPerPanel * pixelSize;
                const fontSize = Math.max(14, Math.floor(panelPixelWidth * 0.4)); // Larger font

                ctx.fillStyle = '#ff0000'; // Pure red for visibility
                ctx.font = `bold ${fontSize}px JetBrains Mono`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';

                let panelNum = 1;
                for (let pc = 0; pc < panelCols; pc++) {
                    for (let pr = 0; pr < panelRows; pr++) {
                        const centerX = (pc + 0.5) * pixelsPerPanel * pixelSize;
                        const centerY = (panelRows - pr - 0.5) * pixelsPerPanel * pixelSize;
                        ctx.fillText(panelNum.toString(), centerX, centerY);
                        panelNum++;
                    }
                }
            }
        }

        // ============================================
        // Status Updates
        // ============================================
        function updateStatus() {
            document.getElementById('statusFilename').textContent = state.filename || 'No pattern';

            if (state.pattern) {
                document.getElementById('statusDimensions').textContent =
                    `${state.pattern.pixelCols} √ó ${state.pattern.pixelRows} px`;
                document.getElementById('statusFrames').textContent =
                    `${state.pattern.numFrames} frame${state.pattern.numFrames !== 1 ? 's' : ''}`;
                document.getElementById('statusGsMode').textContent =
                    state.pattern.gsMode === 2 ? 'GS2' : 'GS16';

                // Show V2 header metadata if pattern was loaded from file
                const metaEl = document.getElementById('statusHeaderMeta');
                if (state.pattern.headerVersion >= 2) {
                    const parts = [];
                    const gen = state.pattern.generation;
                    if (gen === 'G6') {
                        const arenaName = getArenaName('G6', state.pattern.arena_id);
                        parts.push(arenaName || `arena:${state.pattern.arena_id}`);
                    } else if (state.pattern.arena_id > 0) {
                        const arenaName = getArenaName(gen, state.pattern.arena_id);
                        parts.push(arenaName || `arena:${state.pattern.arena_id}`);
                    }
                    metaEl.textContent = parts.length ? `[${parts.join(', ')}]` : '';
                } else {
                    metaEl.textContent = '';
                }
            } else {
                document.getElementById('statusDimensions').textContent = '‚Äî';
                document.getElementById('statusFrames').textContent = '‚Äî';
                document.getElementById('statusGsMode').textContent = '‚Äî';
                document.getElementById('statusHeaderMeta').textContent = '';
            }

            document.getElementById('statusUnsaved').textContent = state.isDirty ? 'Unsaved*' : '';
        }

        function updateCombineInfo() {
            // Update Pattern A info and thumbnail
            const thumbA = document.getElementById('patternAThumbnail');
            const nameA = document.getElementById('patternAName');
            const dimsA = document.getElementById('patternADims');

            if (state.combinePatternA) {
                const p = state.combinePatternA;
                nameA.textContent = p.filename || 'Unnamed pattern';
                dimsA.textContent = `${p.pixelCols}√ó${p.pixelRows}, ${p.numFrames} frames`;

                // Generate thumbnail
                thumbA.classList.remove('empty');
                thumbA.innerHTML = '';
                const gen = p.generation || state.arena.config?.arena?.generation || 'G6';
                const thumb = generateIconThumbnail(p.frames[0], p.pixelRows, p.pixelCols, p.gsMode, gen);
                if (thumb) {
                    if (typeof thumb === 'string') {
                        const img = document.createElement('img');
                        img.src = thumb;
                        thumbA.appendChild(img);
                    } else {
                        thumbA.appendChild(thumb);
                    }
                }
            } else {
                nameA.textContent = 'No pattern set';
                dimsA.textContent = '';
                thumbA.classList.add('empty');
                thumbA.innerHTML = '?';
            }

            // Update Pattern B info and thumbnail
            const thumbB = document.getElementById('patternBThumbnail');
            const nameB = document.getElementById('patternBName');
            const dimsB = document.getElementById('patternBDims');

            if (state.combinePatternB) {
                const p = state.combinePatternB;
                nameB.textContent = p.filename || 'Unnamed pattern';
                dimsB.textContent = `${p.pixelCols}√ó${p.pixelRows}, ${p.numFrames} frames`;

                // Generate thumbnail
                thumbB.classList.remove('empty');
                thumbB.innerHTML = '';
                const gen = p.generation || state.arena.config?.arena?.generation || 'G6';
                const thumb = generateIconThumbnail(p.frames[0], p.pixelRows, p.pixelCols, p.gsMode, gen);
                if (thumb) {
                    if (typeof thumb === 'string') {
                        const img = document.createElement('img');
                        img.src = thumb;
                        thumbB.appendChild(img);
                    } else {
                        thumbB.appendChild(thumb);
                    }
                }
            } else {
                nameB.textContent = 'No pattern set';
                dimsB.textContent = '';
                thumbB.classList.add('empty');
                thumbB.innerHTML = '?';
            }

            // Update length options visibility based on current mode and patterns
            updateCombineModeUI();
        }

        /**
         * Update Save/Load button states based on arena generation
         * G3 format is not supported for .pat files
         */
        function updateG3ButtonStates() {
            const loadBtn = document.getElementById('loadBtn');
            const saveBtn = document.getElementById('saveBtn');

            // Check if current arena or pattern is G3
            const isG3Arena = state.arena.config && state.arena.config.arena.generation === 'G3';
            const isG3Pattern = state.pattern && state.pattern.generation === 'G3';

            if (isG3Arena || isG3Pattern) {
                loadBtn.disabled = true;
                saveBtn.disabled = true;
                loadBtn.title = 'G3 .pat format not supported';
                saveBtn.title = 'G3 .pat format not supported';
                loadBtn.style.opacity = '0.5';
                saveBtn.style.opacity = '0.5';
            } else {
                loadBtn.disabled = false;
                saveBtn.disabled = false;
                loadBtn.title = 'Load .pat file';
                saveBtn.title = 'Save as .pat file';
                loadBtn.style.opacity = '1';
                saveBtn.style.opacity = '1';
            }
        }

        // ============================================
        // Arena Config Lock/Unlock
        // ============================================
        function lockArenaConfig() {
            state.arena.locked = true;
            const select = document.getElementById('arenaConfigStatus');
            const lockBtn = document.getElementById('arenaLockBtn');
            select.disabled = true;
            lockBtn.textContent = 'üîí';
            lockBtn.classList.add('locked');
            lockBtn.title = 'Arena config locked (click to unlock)';
        }

        function unlockArenaConfig() {
            state.arena.locked = false;
            const select = document.getElementById('arenaConfigStatus');
            const lockBtn = document.getElementById('arenaLockBtn');
            select.disabled = false;
            lockBtn.textContent = 'üîì';
            lockBtn.classList.remove('locked');
            lockBtn.title = 'Lock arena config';
        }

        // ============================================
        // Preview Mode (loaded pattern viewing)
        // ============================================
        function enterPreviewMode() {
            state.previewMode = true;
            document.querySelector('.tools-panel').classList.add('preview-mode');
            document.querySelector('.generate-column').classList.add('preview-mode');
        }

        function exitPreviewMode() {
            state.previewMode = false;
            document.querySelector('.tools-panel').classList.remove('preview-mode');
            document.querySelector('.generate-column').classList.remove('preview-mode');
        }

        function toggleArenaLock() {
            if (state.arena.locked) {
                // Warn if pattern or clipboard items exist
                const hasClipboardItems = state.clipboardFrames.length > 0 || state.clipboardPatterns.length > 0;
                if (state.pattern || hasClipboardItems) {
                    const clipboardWarning = hasClipboardItems ? '\n\nClipboard contents will be cleared.' : '';
                    const confirmed = confirm(
                        'Warning: Changing the arena config while a pattern is loaded may cause dimension mismatches.' +
                        clipboardWarning + '\n\nAre you sure you want to unlock the arena config?'
                    );
                    if (!confirmed) return;
                    clearClipboards();
                }
                unlockArenaConfig();
            } else {
                lockArenaConfig();
            }
        }

        // Note: getConfigsByGeneration() and getConfig() are provided by arena-configs.js
        // getConfigsByGeneration() returns arrays of { name, label, description, arena } objects
        // getConfig(name) returns the full config object for a given name

        // ============================================
        // Initialize
        // ============================================
        function initializeApp() {
            initUI();
            updateClipboardUI();
            updateDefaultFrames();  // Set initial frames based on default arena
            updatePatternTypeUI();  // Set initial pattern type UI visibility
            updateG3ButtonStates(); // Disable save/load for G3 arenas

            // Re-render 2D view on window resize to scale to fill available space
            let resizeTimeout;
            window.addEventListener('resize', () => {
                clearTimeout(resizeTimeout);
                resizeTimeout = setTimeout(() => {
                    if (state.pattern && state.editor.activeViewer === 'grid') {
                        renderGridViewer();
                    }
                }, 100);  // Debounce for smoother resizing
            });
        }

        // Wait for both DOM and arena configs (loaded as ES6 module) to be ready
        let domReady = false;
        let configsReady = typeof STANDARD_CONFIGS !== 'undefined';

        function tryInitialize() {
            if (domReady && configsReady) {
                initializeApp();
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            domReady = true;
            tryInitialize();
        });

        window.addEventListener('arenaConfigsLoaded', () => {
            configsReady = true;
            tryInitialize();
        });
    </script>
</body>
</html>
