#!/usr/bin/env node
/**
 * Generate Reference Protocol YAML for Web → MATLAB Roundtrip Testing
 *
 * Replicates the generateYAML() logic from experiment_designer.html to
 * produce V1 protocol YAML files, then self-verifies by parsing them back
 * with simpleYAMLParse(). Writes YAML + JSON manifest to output dir.
 *
 * Usage:
 *   node tests/generate-roundtrip-protocol.js --outdir ../../maDisplayTools/tests/web_generated_patterns
 *
 * The generated YAML references existing web-generated .pat files so that
 * MATLAB can run a full dry-run validation including pattern file checks.
 */

const fs = require('fs');
const path = require('path');

// ─── Parse command-line args ────────────────────────────────────────────────

const args = process.argv.slice(2);
let outDir = null;
for (let i = 0; i < args.length; i++) {
    if (args[i] === '--outdir' && args[i + 1]) {
        outDir = path.resolve(args[i + 1]);
    }
}
if (!outDir) {
    console.error('Usage: node generate-roundtrip-protocol.js --outdir <path>');
    process.exit(1);
}

// Ensure output directory exists
if (!fs.existsSync(outDir)) {
    fs.mkdirSync(outDir, { recursive: true });
}

// ─── YAML generation (mirrors experiment_designer.html) ─────────────────────

/**
 * Generate a V1 protocol YAML string.
 * Structured as generateProtocol(version, options) for future V2 support.
 *
 * @param {number} version - Protocol version (1 or 2)
 * @param {object} options - Protocol configuration
 * @returns {string} YAML content
 */
function generateProtocol(version, options) {
    if (version === 2) {
        throw new Error('V2 protocol generation not yet implemented');
    }
    return generateV1Protocol(options);
}

function generateV1Protocol(opts) {
    const lines = [];

    lines.push('# Protocol Version 1');
    lines.push('# Generated by generate-roundtrip-protocol.js — ' + new Date().toISOString());
    lines.push('# DO NOT EDIT: This file is auto-generated for roundtrip testing');
    lines.push('');
    lines.push('version: 1');
    lines.push('');

    // Experiment info
    lines.push('experiment_info:');
    lines.push('  name: ' + yamlStr(opts.name));
    lines.push('  date_created: ' + yamlStr(opts.date_created));
    lines.push('  author: ' + yamlStr(opts.author));
    lines.push('  pattern_library: ' + yamlStr(opts.pattern_library || ''));
    lines.push('');

    // Arena info
    lines.push('arena_info:');
    lines.push('  num_rows: ' + opts.num_rows);
    lines.push('  num_cols: ' + opts.num_cols);
    lines.push('  generation: ' + yamlStr(opts.generation));
    lines.push('');

    // Experiment structure
    lines.push('experiment_structure:');
    lines.push('  repetitions: ' + opts.repetitions);
    lines.push('  randomization:');
    lines.push('    enabled: ' + opts.randomization_enabled);
    lines.push('    seed: ' + (opts.randomization_seed === null ? 'null' : opts.randomization_seed));
    lines.push('    method: "block"');
    lines.push('');

    // Pretrial
    lines.push('pretrial:');
    lines.push('  include: ' + opts.pretrial.include);
    if (opts.pretrial.include && opts.pretrial.commands) {
        lines.push('  commands:');
        for (const cmd of opts.pretrial.commands) {
            appendCommand(lines, cmd, 2);
        }
    }
    lines.push('');

    // Block conditions
    lines.push('block:');
    lines.push('  conditions:');
    for (let i = 0; i < opts.conditions.length; i++) {
        const cond = opts.conditions[i];
        lines.push('    - id: ' + yamlStr(cond.id));
        lines.push('      commands:');
        for (const cmd of cond.commands) {
            appendCommand(lines, cmd, 4);
        }
    }
    lines.push('');

    // Intertrial
    lines.push('intertrial:');
    lines.push('  include: ' + opts.intertrial.include);
    if (opts.intertrial.include && opts.intertrial.commands) {
        lines.push('  commands:');
        for (const cmd of opts.intertrial.commands) {
            appendCommand(lines, cmd, 2);
        }
    }
    lines.push('');

    // Posttrial
    lines.push('posttrial:');
    lines.push('  include: ' + opts.posttrial.include);
    if (opts.posttrial.include && opts.posttrial.commands) {
        lines.push('  commands:');
        for (const cmd of opts.posttrial.commands) {
            appendCommand(lines, cmd, 2);
        }
    }

    return lines.join('\n') + '\n';
}

function appendCommand(lines, cmd, indentLevel) {
    const ind = '  '.repeat(indentLevel);
    lines.push(ind + '- type: ' + yamlStr(cmd.type));
    if (cmd.command_name) {
        lines.push(ind + '  command_name: ' + yamlStr(cmd.command_name));
    }
    if (cmd.pattern) {
        lines.push(ind + '  pattern: ' + yamlStr(cmd.pattern));
    }
    if (cmd.pattern_ID !== undefined) {
        lines.push(ind + '  pattern_ID: ' + cmd.pattern_ID);
    }
    if (cmd.duration !== undefined) {
        lines.push(ind + '  duration: ' + cmd.duration);
    }
    if (cmd.mode !== undefined) {
        lines.push(ind + '  mode: ' + cmd.mode);
    }
    if (cmd.frame_index !== undefined) {
        lines.push(ind + '  frame_index: ' + cmd.frame_index);
    }
    if (cmd.frame_rate !== undefined) {
        lines.push(ind + '  frame_rate: ' + cmd.frame_rate);
    }
    if (cmd.gain !== undefined) {
        lines.push(ind + '  gain: ' + cmd.gain);
    }
}

function yamlStr(str) {
    if (str === null || str === undefined || str === '') return '""';
    str = String(str);
    if (/[:#\{\}\[\],&\*\?|>!'"%@`\n]/.test(str) || str.trim() !== str) {
        return '"' + str.replace(/\\/g, '\\\\').replace(/"/g, '\\"') + '"';
    }
    return '"' + str + '"';
}

// ─── simpleYAMLParse (mirrors experiment_designer.html for self-test) ───────

function simpleYAMLParse(text) {
    const lines = text.split('\n');
    let i = 0;

    function getIndent(line) {
        const m = line.match(/^(\s*)/);
        return m ? m[1].length : 0;
    }

    function parseValue(raw) {
        if (raw === undefined || raw === '') return '';
        raw = raw.trim();
        if ((raw.startsWith('"') && raw.endsWith('"')) || (raw.startsWith("'") && raw.endsWith("'"))) {
            return raw.slice(1, -1);
        }
        if (raw === 'null' || raw === '~') return null;
        if (raw === 'true') return true;
        if (raw === 'false') return false;
        const num = Number(raw);
        if (!isNaN(num) && raw !== '') return num;
        return raw;
    }

    function parseBlock(baseIndent) {
        const obj = {};
        while (i < lines.length) {
            const line = lines[i];
            if (line.trim() === '' || line.trim().startsWith('#')) { i++; continue; }
            const indent = getIndent(line);
            if (indent < baseIndent) break;
            if (indent > baseIndent) { i++; continue; }

            const trimmed = line.trim();
            if (trimmed.startsWith('- ')) break;

            const kvMatch = trimmed.match(/^([^:]+?):\s*(.*)?$/);
            if (!kvMatch) { i++; continue; }

            const key = kvMatch[1].trim();
            const valRaw = (kvMatch[2] || '').trim();

            if (valRaw === '' || valRaw === undefined) {
                i++;
                // Skip blank lines and comments to find actual child content
                while (i < lines.length && (lines[i].trim() === '' || lines[i].trim().startsWith('#'))) {
                    i++;
                }
                if (i < lines.length) {
                    const nextLine = lines[i];
                    const nextIndent = getIndent(nextLine);
                    if (nextIndent > indent) {
                        if (nextLine.trim().startsWith('- ')) {
                            obj[key] = parseList(nextIndent);
                        } else {
                            obj[key] = parseBlock(nextIndent);
                        }
                    }
                }
            } else {
                obj[key] = parseValue(valRaw);
                i++;
            }
        }
        return obj;
    }

    function parseList(baseIndent) {
        const arr = [];
        while (i < lines.length) {
            const line = lines[i];
            if (line.trim() === '' || line.trim().startsWith('#')) { i++; continue; }
            const indent = getIndent(line);
            if (indent < baseIndent) break;

            const trimmed = line.trim();
            if (!trimmed.startsWith('- ')) { i++; continue; }

            const itemContent = trimmed.slice(2).trim();
            const kvMatch = itemContent.match(/^([^:]+?):\s*(.*)?$/);

            if (kvMatch) {
                const item = {};
                item[kvMatch[1].trim()] = parseValue((kvMatch[2] || '').trim());
                i++;
                while (i < lines.length) {
                    const subLine = lines[i];
                    if (subLine.trim() === '' || subLine.trim().startsWith('#')) { i++; continue; }
                    const subIndent = getIndent(subLine);
                    if (subIndent <= baseIndent) break;
                    const subTrimmed = subLine.trim();
                    if (subTrimmed.startsWith('- ')) break;
                    const subKv = subTrimmed.match(/^([^:]+?):\s*(.*)?$/);
                    if (subKv) {
                        const subKey = subKv[1].trim();
                        const subVal = (subKv[2] || '').trim();
                        if (subVal === '') {
                            i++;
                            // Skip blank lines and comments to find actual child content
                            while (i < lines.length && (lines[i].trim() === '' || lines[i].trim().startsWith('#'))) {
                                i++;
                            }
                            if (i < lines.length) {
                                const nLine = lines[i];
                                const nIndent = getIndent(nLine);
                                if (nIndent > subIndent) {
                                    if (nLine.trim().startsWith('- ')) {
                                        item[subKey] = parseList(nIndent);
                                    } else {
                                        item[subKey] = parseBlock(nIndent);
                                    }
                                }
                            }
                        } else {
                            item[subKey] = parseValue(subVal);
                            i++;
                        }
                    } else {
                        i++;
                    }
                }
                arr.push(item);
            } else {
                arr.push(parseValue(itemContent));
                i++;
            }
        }
        return arr;
    }

    return parseBlock(0);
}

// ─── Test protocol definitions ──────────────────────────────────────────────

// Use existing web-generated .pat files for realistic protocol
const webPatterns = [
    'web_G41_2x12_gs16_sine_grating_G4.pat',
    'web_G4_4x12_gs16_square_grating_G4.pat',
    'web_G4_4x12_gs2_square_grating_G4.pat',
];

const testProtocol = {
    name: 'Web Roundtrip Test Protocol',
    date_created: '2026-02-28',
    author: 'Roundtrip Test Generator',
    pattern_library: '',
    num_rows: 2,
    num_cols: 12,
    generation: 'G4.1',
    repetitions: 1,
    randomization_enabled: false,
    randomization_seed: null,
    pretrial: {
        include: true,
        commands: [
            { type: 'controller', command_name: 'allOn' },
            { type: 'wait', duration: 1 },
            { type: 'controller', command_name: 'allOff' },
            { type: 'wait', duration: 0.5 },
        ]
    },
    conditions: [
        {
            id: 'sine_grating_gs16',
            commands: [{
                type: 'controller',
                command_name: 'startG41Trial',
                pattern: webPatterns[0],
                pattern_ID: 1,
                duration: 5,
                mode: 2,
                frame_index: 1,
                frame_rate: 60,
                gain: 0
            }]
        },
        {
            id: 'square_grating_gs16',
            commands: [{
                type: 'controller',
                command_name: 'startG41Trial',
                pattern: webPatterns[1],
                pattern_ID: 2,
                duration: 5,
                mode: 2,
                frame_index: 1,
                frame_rate: 10,
                gain: 0
            }]
        },
        {
            id: 'square_grating_gs2',
            commands: [{
                type: 'controller',
                command_name: 'startG41Trial',
                pattern: webPatterns[2],
                pattern_ID: 3,
                duration: 3,
                mode: 2,
                frame_index: 1,
                frame_rate: 30,
                gain: 0
            }]
        },
    ],
    intertrial: {
        include: true,
        commands: [
            { type: 'controller', command_name: 'allOff' },
            { type: 'wait', duration: 2 },
        ]
    },
    posttrial: {
        include: true,
        commands: [
            { type: 'controller', command_name: 'allOff' },
            { type: 'wait', duration: 1 },
        ]
    }
};

// ─── Generate and self-verify ───────────────────────────────────────────────

console.log('=== Protocol YAML Roundtrip Generator ===\n');

// Generate V1 YAML
const yamlContent = generateProtocol(1, testProtocol);
const yamlFile = path.join(outDir, 'test_protocol_v1.yaml');
fs.writeFileSync(yamlFile, yamlContent);
console.log('Generated: ' + yamlFile);

// Self-verify: parse the YAML back
console.log('\nSelf-verification (simpleYAMLParse):');
const parsed = simpleYAMLParse(yamlContent);

let errors = 0;

function check(label, actual, expected) {
    if (actual !== expected) {
        console.log('  FAIL: ' + label + ' = ' + JSON.stringify(actual) + ', expected ' + JSON.stringify(expected));
        errors++;
    } else {
        console.log('  OK: ' + label + ' = ' + JSON.stringify(actual));
    }
}

check('version', parsed.version, 1);
check('experiment_info.name', parsed.experiment_info.name, testProtocol.name);
check('arena_info.num_rows', parsed.arena_info.num_rows, testProtocol.num_rows);
check('arena_info.num_cols', parsed.arena_info.num_cols, testProtocol.num_cols);
check('arena_info.generation', parsed.arena_info.generation, testProtocol.generation);
check('experiment_structure.repetitions', parsed.experiment_structure.repetitions, testProtocol.repetitions);
check('randomization.enabled', parsed.experiment_structure.randomization.enabled, testProtocol.randomization_enabled);

// Verify conditions
const conditions = parsed.block && parsed.block.conditions;
if (!Array.isArray(conditions)) {
    console.log('  FAIL: block.conditions is not an array: ' + typeof conditions);
    errors++;
} else {
    check('block.conditions.length', conditions.length, testProtocol.conditions.length);
    for (let i = 0; i < testProtocol.conditions.length; i++) {
        const expected = testProtocol.conditions[i];
        const actual = conditions[i];
        if (!actual) {
            console.log('  FAIL: condition ' + i + ' is missing');
            errors++;
            continue;
        }
        check('condition[' + i + '].id', actual.id, expected.id);
        if (actual.commands && actual.commands[0]) {
            check('condition[' + i + '].commands[0].pattern', actual.commands[0].pattern, expected.commands[0].pattern);
            check('condition[' + i + '].commands[0].duration', actual.commands[0].duration, expected.commands[0].duration);
            check('condition[' + i + '].commands[0].frame_rate', actual.commands[0].frame_rate, expected.commands[0].frame_rate);
        } else {
            console.log('  FAIL: condition ' + i + ' has no commands');
            errors++;
        }
    }
}

// Verify phases
check('pretrial.include', parsed.pretrial.include, true);
check('intertrial.include', parsed.intertrial.include, true);
check('posttrial.include', parsed.posttrial.include, true);

if (parsed.pretrial.commands) {
    check('pretrial.commands.length', parsed.pretrial.commands.length, 4);
} else {
    console.log('  FAIL: pretrial.commands is missing');
    errors++;
}

// Write manifest for MATLAB validation
const manifest = {
    generator: 'generate-roundtrip-protocol.js',
    generated_at: new Date().toISOString(),
    version: 1,
    protocol_file: 'test_protocol_v1.yaml',
    expected: {
        name: testProtocol.name,
        author: testProtocol.author,
        generation: testProtocol.generation,
        num_rows: testProtocol.num_rows,
        num_cols: testProtocol.num_cols,
        repetitions: testProtocol.repetitions,
        randomization_enabled: testProtocol.randomization_enabled,
        num_conditions: testProtocol.conditions.length,
        conditions: testProtocol.conditions.map(c => ({
            id: c.id,
            pattern: c.commands[0].pattern,
            pattern_ID: c.commands[0].pattern_ID,
            duration: c.commands[0].duration,
            mode: c.commands[0].mode,
            frame_index: c.commands[0].frame_index,
            frame_rate: c.commands[0].frame_rate,
            gain: c.commands[0].gain,
        })),
        pretrial_include: true,
        pretrial_num_commands: 4,
        intertrial_include: true,
        intertrial_num_commands: 2,
        posttrial_include: true,
        posttrial_num_commands: 2,
    }
};

const manifestFile = path.join(outDir, 'test_protocol_manifest.json');
fs.writeFileSync(manifestFile, JSON.stringify(manifest, null, 2));
console.log('\nManifest: ' + manifestFile);

// Also test parsing the hand-written YAML with comments (import bug regression test)
console.log('\n--- Comment-handling regression test ---');
const commentYaml = `
version: 1

experiment_info:
  name: "Comment Test"

arena_info:
  num_rows: 2
  num_cols: 12
  generation: "G4.1"

experiment_structure:
  repetitions: 1
  randomization:
    enabled: false
    seed: null
    method: "block"

pretrial:
  include: false

block:
  conditions:
    # --- GROUP A ---

    - id: "cond_a1"
      commands:
        - type: "controller"
          command_name: "allOn"

    # --- GROUP B ---

    - id: "cond_b1"
      commands:
        - type: "controller"
          command_name: "allOff"

    - id: "cond_b2"
      commands:
        - type: "controller"
          command_name: "allOn"

intertrial:
  include: false

posttrial:
  include: false
`;

const commentParsed = simpleYAMLParse(commentYaml);
const commentConditions = commentParsed.block && commentParsed.block.conditions;
if (!Array.isArray(commentConditions)) {
    console.log('  FAIL: conditions not parsed (comment bug still present!)');
    errors++;
} else {
    check('comment_test: num_conditions', commentConditions.length, 3);
    if (commentConditions.length >= 3) {
        check('comment_test: cond[0].id', commentConditions[0].id, 'cond_a1');
        check('comment_test: cond[1].id', commentConditions[1].id, 'cond_b1');
        check('comment_test: cond[2].id', commentConditions[2].id, 'cond_b2');
    }
}

// Summary
console.log('\n' + (errors === 0 ? '✓ All checks passed' : '✗ ' + errors + ' check(s) failed'));
process.exit(errors > 0 ? 1 : 0);
