/**
 * MATLAB Reference Validation Suite for Spherical Pattern Generation
 *
 * This test suite compares JavaScript spherical pattern output against
 * MATLAB reference data. The reference data should be generated by running
 * the MATLAB script `generate_spherical_reference.m` in the maDisplayTools repo.
 *
 * Run with: node tests/validate-matlab-reference.js
 *
 * Reference data file: data/spherical_pattern_reference.json
 */

const fs = require('fs');
const path = require('path');
const PatternGenerator = require('../js/pattern-editor/tools/generator.js');

const TOLERANCE = 1;  // Pixel value tolerance (±1 for GS16 0-15 range)
const COORD_TOLERANCE = 0.0001;  // Coordinate tolerance in radians

let passed = 0;
let failed = 0;
let skipped = 0;

function assertEqual(actual, expected, message) {
    if (actual === expected) {
        passed++;
        return true;
    } else {
        failed++;
        console.error(`FAIL: ${message}`);
        console.error(`  Expected: ${expected}, Got: ${actual}`);
        return false;
    }
}

function assertClose(actual, expected, tolerance, message) {
    if (Math.abs(actual - expected) <= tolerance) {
        passed++;
        return true;
    } else {
        failed++;
        console.error(`FAIL: ${message}`);
        console.error(`  Expected: ${expected} ± ${tolerance}, Got: ${actual}`);
        return false;
    }
}

function assertTrue(condition, message) {
    if (condition) {
        passed++;
        return true;
    } else {
        failed++;
        console.error(`FAIL: ${message}`);
        return false;
    }
}

/**
 * Compare a generated pattern frame against MATLAB reference
 */
function compareFrame(jsFrame, matlabFrame, tolerance, testName) {
    const pixelCount = jsFrame.length;
    let mismatches = 0;
    let maxDiff = 0;
    let firstMismatchIdx = -1;

    for (let i = 0; i < pixelCount; i++) {
        const diff = Math.abs(jsFrame[i] - matlabFrame[i]);
        if (diff > tolerance) {
            mismatches++;
            if (firstMismatchIdx < 0) firstMismatchIdx = i;
        }
        if (diff > maxDiff) maxDiff = diff;
    }

    if (mismatches === 0) {
        passed++;
        return true;
    } else {
        failed++;
        console.error(`FAIL: ${testName}`);
        console.error(`  ${mismatches}/${pixelCount} pixels differ by more than ±${tolerance}`);
        console.error(`  Max difference: ${maxDiff}`);
        console.error(`  First mismatch at pixel ${firstMismatchIdx}: JS=${jsFrame[firstMismatchIdx]}, MATLAB=${matlabFrame[firstMismatchIdx]}`);
        return false;
    }
}

/**
 * Load MATLAB reference data from JSON file
 */
function loadReferenceData() {
    const refPath = path.join(__dirname, '../data/spherical_pattern_reference.json');

    if (!fs.existsSync(refPath)) {
        console.log('=== MATLAB Reference Validation ===\n');
        console.log('Reference data file not found:', refPath);
        console.log('');
        console.log('To generate reference data, run the MATLAB script:');
        console.log('  >> run("maDisplayTools/tests/generate_spherical_reference.m")');
        console.log('');
        console.log('Then copy the output file to:');
        console.log('  webDisplayTools/data/spherical_pattern_reference.json');
        console.log('');
        return null;
    }

    try {
        const data = JSON.parse(fs.readFileSync(refPath, 'utf8'));
        return data;
    } catch (e) {
        console.error('Error loading reference data:', e.message);
        return null;
    }
}

// Standard arena config for tests
const arenaConfig = {
    generation: 'G6',
    rows: 2,
    cols: 10
};

console.log('=== MATLAB Reference Validation Suite ===\n');

// Load reference data
const refData = loadReferenceData();

if (!refData) {
    console.log('Skipping MATLAB reference tests (no reference data)');
    console.log('');
    console.log('Running self-consistency tests instead...\n');

    // Run self-consistency tests when no MATLAB reference is available

    // Test 1: Rotation grating consistency
    console.log('Test 1: Rotation grating self-consistency');
    {
        const params = {
            spatFreq: Math.PI / 10,  // 20 pixel wavelength
            motionType: 'rotation',
            waveform: 'square',
            dutyCycle: 50,
            high: 15,
            low: 0,
            poleCoord: [0, 0],
            numFrames: 1,
            aaSamples: 1,
            gsMode: 16
        };

        const pattern = PatternGenerator.generate('spherical-grating', params, arenaConfig);

        // All rows should be identical for rotation with vertical pole
        let rowsMatch = true;
        const pixelCols = pattern.pixelCols;
        for (let r = 1; r < pattern.pixelRows; r++) {
            for (let c = 0; c < pixelCols; c++) {
                if (pattern.frames[0][r * pixelCols + c] !== pattern.frames[0][c]) {
                    rowsMatch = false;
                    break;
                }
            }
            if (!rowsMatch) break;
        }
        assertTrue(rowsMatch, 'Rotation grating: all rows identical');
    }

    // Test 2: Frame-to-frame phase progression
    console.log('\nTest 2: Phase progression between frames');
    {
        const params = {
            spatFreq: Math.PI / 10,
            motionType: 'rotation',
            waveform: 'square',
            dutyCycle: 50,
            high: 15,
            low: 0,
            poleCoord: [0, 0],
            numFrames: 5,
            stepSize: 1,
            direction: 'cw',
            aaSamples: 1,
            gsMode: 16
        };

        const pattern = PatternGenerator.generate('spherical-grating', params, arenaConfig);
        const pixelCols = pattern.pixelCols;

        // For CW rotation, the pattern shifts left in the coordinate frame,
        // so at a fixed pixel column, the value comes from earlier in the pattern
        // Frame N column C should equal Frame 0 column (C - N + pixelCols) % pixelCols
        let shiftCorrect = true;
        for (let f = 1; f < pattern.numFrames && shiftCorrect; f++) {
            for (let c = 0; c < pixelCols; c++) {
                const sourceCol = ((c - f) % pixelCols + pixelCols) % pixelCols;
                if (pattern.frames[f][c] !== pattern.frames[0][sourceCol]) {
                    shiftCorrect = false;
                    break;
                }
            }
        }
        assertTrue(shiftCorrect, 'Frames are correctly phase-shifted');
    }

    // Test 3: Duty cycle affects proportion
    console.log('\nTest 3: Duty cycle ratio');
    {
        const params25 = {
            spatFreq: Math.PI / 10,
            motionType: 'rotation',
            waveform: 'square',
            dutyCycle: 25,
            high: 15,
            low: 0,
            poleCoord: [0, 0],
            numFrames: 1,
            aaSamples: 1,
            gsMode: 16
        };

        const params75 = { ...params25, dutyCycle: 75 };

        const pattern25 = PatternGenerator.generate('spherical-grating', params25, arenaConfig);
        const pattern75 = PatternGenerator.generate('spherical-grating', params75, arenaConfig);

        const count25 = pattern25.frames[0].filter(v => v === 15).length;
        const count75 = pattern75.frames[0].filter(v => v === 15).length;

        // 25% duty should have ~25% high pixels, 75% should have ~75%
        const total = pattern25.frames[0].length;
        const ratio25 = count25 / total;
        const ratio75 = count75 / total;

        assertClose(ratio25, 0.25, 0.05, '25% duty cycle has ~25% high pixels');
        assertClose(ratio75, 0.75, 0.05, '75% duty cycle has ~75% high pixels');
    }

    // Test 4: Sine wave smoothness
    console.log('\nTest 4: Sine wave produces smooth gradient');
    {
        const params = {
            spatFreq: Math.PI / 10,
            motionType: 'rotation',
            waveform: 'sine',
            high: 15,
            low: 0,
            poleCoord: [0, 0],
            numFrames: 1,
            aaSamples: 1,
            gsMode: 16
        };

        const pattern = PatternGenerator.generate('spherical-sine', params, arenaConfig);
        const uniqueValues = new Set(pattern.frames[0]);

        // Sine should produce multiple values (not just 0 and 15)
        assertTrue(uniqueValues.size > 2, `Sine wave has multiple values (${uniqueValues.size})`);
    }

    // Test 5: Expansion pattern varies with elevation
    console.log('\nTest 5: Expansion pattern varies with elevation');
    {
        const params = {
            spatFreq: Math.PI / 4,
            motionType: 'expansion',
            waveform: 'square',
            dutyCycle: 50,
            high: 15,
            low: 0,
            poleCoord: [0, 0],
            numFrames: 1,
            aaSamples: 1,
            gsMode: 16
        };

        const pattern = PatternGenerator.generate('spherical-grating', params, arenaConfig);
        const frame = pattern.frames[0];
        const pixelCols = pattern.pixelCols;

        // For expansion, different rows should have different patterns
        // Check if there's at least one row that differs from row 0
        let foundDifferentRow = false;
        for (let r = 1; r < pattern.pixelRows && !foundDifferentRow; r++) {
            for (let c = 0; c < pixelCols; c++) {
                if (frame[r * pixelCols + c] !== frame[c]) {
                    foundDifferentRow = true;
                    break;
                }
            }
        }
        assertTrue(foundDifferentRow, 'Expansion pattern has row variation');
    }

    // Test 6: Anti-aliasing effect
    console.log('\nTest 6: Anti-aliasing produces intermediate values');
    {
        const paramsNoAA = {
            spatFreq: 0.65,  // Misaligned with pixel grid
            motionType: 'rotation',
            waveform: 'square',
            dutyCycle: 50,
            high: 15,
            low: 0,
            poleCoord: [0, 0],
            numFrames: 1,
            aaSamples: 1,
            gsMode: 16
        };

        const paramsWithAA = { ...paramsNoAA, aaSamples: 15 };

        const patternNoAA = PatternGenerator.generate('spherical-grating', paramsNoAA, arenaConfig);
        const patternWithAA = PatternGenerator.generate('spherical-grating', paramsWithAA, arenaConfig);

        const uniqueNoAA = new Set(patternNoAA.frames[0]);
        const uniqueWithAA = new Set(patternWithAA.frames[0]);

        assertEqual(uniqueNoAA.size, 2, 'No AA: exactly 2 values');
        assertTrue(uniqueWithAA.size > 2, `With AA: more than 2 values (${uniqueWithAA.size})`);
    }

} else {
    // Run MATLAB reference comparison tests
    console.log(`Loaded reference data with ${refData.testCases.length} test cases\n`);

    for (const testCase of refData.testCases) {
        console.log(`Test: ${testCase.name}`);

        // Build params from test case
        const params = {
            spatFreq: testCase.spatFreq,
            motionType: testCase.motionType,
            waveform: testCase.waveform,
            dutyCycle: testCase.dutyCycle || 50,
            high: testCase.high || 15,
            low: testCase.low || 0,
            poleCoord: testCase.poleCoord || [0, 0],
            numFrames: testCase.numFrames || 1,
            aaSamples: testCase.aaSamples || 1,
            arenaModel: testCase.arenaModel || 'smooth',
            gsMode: testCase.gsMode || 16
        };

        const arena = {
            generation: testCase.generation || 'G6',
            rows: testCase.rows || 2,
            cols: testCase.cols || 10
        };

        try {
            const pattern = PatternGenerator.generate('spherical-grating', params, arena);

            // Compare frame 0 (or specified test frame)
            const frameIdx = testCase.testFrame || 0;
            const jsFrame = Array.from(pattern.frames[frameIdx]);
            const matlabFrame = testCase.referenceFrame;

            compareFrame(jsFrame, matlabFrame, TOLERANCE, `${testCase.name} - frame ${frameIdx}`);

        } catch (e) {
            failed++;
            console.error(`FAIL: ${testCase.name} - Error: ${e.message}`);
        }

        console.log('');
    }
}

console.log('========================================');
console.log(`Results: ${passed} passed, ${failed} failed, ${skipped} skipped`);
console.log('========================================\n');

process.exit(failed === 0 ? 0 : 1);
