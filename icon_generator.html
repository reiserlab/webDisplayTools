<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pattern Icon Generator - PanelDisplayTools</title>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700&family=IBM+Plex+Mono:wght@400;600&display=swap" rel="stylesheet">
    <!-- Load as ES6 modules for compatibility with pat-parser.js export -->
    <script type="module">
        // Cache-busting: v4 adds GIF generation support
        import { STANDARD_CONFIGS, PANEL_SPECS, getConfig, getConfigsByGeneration } from './js/arena-configs.js?v=4';
        import PatParser from './js/pat-parser.js?v=4';
        import { generatePatternIcon, generateMotionIcon, generatePatternGIF } from './js/icon-generator.js?v=4';

        // Make available globally for inline script
        window.STANDARD_CONFIGS = STANDARD_CONFIGS;
        window.PANEL_SPECS = PANEL_SPECS;
        window.getConfig = getConfig;
        window.getConfigsByGeneration = getConfigsByGeneration;
        window.PatParser = PatParser;
        window.IconGenerator = { generatePatternIcon, generateMotionIcon, generatePatternGIF };

        // Dispatch event when modules are loaded
        window.dispatchEvent(new Event('modulesLoaded'));
    </script>
    <!-- gif.js library for GIF encoding -->
    <script src="https://cdn.jsdelivr.net/npm/gif.js@0.2.0/dist/gif.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        :root {
            --bg: #0f1419;
            --surface: #1a1f26;
            --border: #2d3640;
            --text: #e6edf3;
            --text-dim: #8b949e;
            --accent: #00e676;
            --hover: #00c853;
        }

        body {
            font-family: 'IBM Plex Mono', monospace;
            background: var(--bg);
            color: var(--text);
            padding: 1rem;
            min-height: 100vh;
        }

        .container {
            max-width: 1000px;
            margin: 0 auto;
        }

        header {
            margin-bottom: 1rem;
        }

        h1 {
            font-family: 'JetBrains Mono', monospace;
            font-size: 1.5rem;
            color: var(--accent);
            margin-bottom: 0.25rem;
        }

        .subtitle {
            color: var(--text-dim);
            font-size: 0.8rem;
        }

        .content {
            display: grid;
            grid-template-columns: 280px 1fr;
            gap: 1rem;
        }

        .panel {
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 6px;
            padding: 1rem;
        }

        .section {
            margin-bottom: 1rem;
        }

        .section:last-child {
            margin-bottom: 0;
        }

        .section-title {
            font-family: 'JetBrains Mono', monospace;
            font-weight: 700;
            font-size: 0.8rem;
            color: var(--accent);
            margin-bottom: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .control-group {
            margin-bottom: 0.75rem;
        }

        .control-group:last-child {
            margin-bottom: 0;
        }

        label {
            display: block;
            font-size: 0.8rem;
            color: var(--text-dim);
            margin-bottom: 0.3rem;
        }

        input[type="file"],
        select {
            width: 100%;
            padding: 0.4rem;
            background: var(--bg);
            border: 1px solid var(--border);
            border-radius: 4px;
            color: var(--text);
            font-family: 'IBM Plex Mono', monospace;
            font-size: 0.8rem;
        }

        input[type="range"] {
            width: 100%;
            margin: 0.3rem 0;
        }

        .range-value {
            display: inline-block;
            min-width: 40px;
            text-align: right;
            color: var(--accent);
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.8rem;
        }

        .btn {
            padding: 0.5rem 1rem;
            background: var(--accent);
            color: var(--bg);
            border: none;
            border-radius: 4px;
            font-family: 'JetBrains Mono', monospace;
            font-weight: 600;
            font-size: 0.8rem;
            cursor: pointer;
            transition: background 0.2s;
            width: 100%;
        }

        .btn:hover {
            background: var(--hover);
        }

        .btn:disabled {
            background: var(--border);
            cursor: not-allowed;
        }

        .btn.secondary {
            background: var(--border);
            color: var(--text);
        }

        .btn.secondary:hover {
            background: #3d4650;
        }

        .radio-group {
            display: flex;
            gap: 1rem;
            margin-top: 0.5rem;
        }

        .radio-label {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            cursor: pointer;
        }

        .radio-label input[type="radio"] {
            width: auto;
        }

        .divider {
            height: 1px;
            background: var(--border);
            margin: 1rem 0;
        }

        .icon-display {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 1rem;
        }

        .icon-container {
            background: var(--bg);
            border: 2px solid var(--border);
            border-radius: 6px;
            padding: 1rem;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 280px;
        }

        .icon-container img {
            max-width: 100%;
            border-radius: 4px;
            image-rendering: crisp-edges;
        }

        .icon-placeholder {
            color: var(--text-dim);
            text-align: center;
            font-size: 0.9rem;
        }

        .info-box {
            background: var(--bg);
            border: 1px solid var(--border);
            border-radius: 4px;
            padding: 0.5rem;
            font-size: 0.75rem;
            color: var(--text-dim);
        }

        .info-box .label {
            color: var(--text);
            font-weight: 600;
        }

        .frame-range-inputs {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0.4rem;
        }

        .frame-range-inputs input {
            padding: 0.3rem;
        }

        input[type="number"] {
            padding: 0.4rem;
            background: var(--bg);
            border: 1px solid var(--border);
            border-radius: 4px;
            color: var(--text);
            font-family: 'IBM Plex Mono', monospace;
            font-size: 0.8rem;
        }

        .help-text {
            font-size: 0.7rem;
            color: var(--text-dim);
            margin-top: 0.3rem;
        }

        .help-text code {
            background: var(--bg);
            padding: 0.1rem 0.3rem;
            border-radius: 3px;
            font-family: 'JetBrains Mono', monospace;
        }

        footer {
            margin-top: 1.5rem;
            text-align: center;
            color: var(--text-dim);
            font-size: 0.75rem;
        }

        footer a {
            color: var(--accent);
            text-decoration: none;
        }

        footer a:hover {
            text-decoration: underline;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Pattern Icon Generator</h1>
            <p class="subtitle">Generate top-down cylindrical view icons from arena patterns</p>
        </header>

        <div class="content">
            <!-- Controls Panel -->
            <div class="panel">
                <div class="section">
                    <div class="section-title">Pattern Source</div>

                    <div class="control-group">
                        <label>Load Pattern File</label>
                        <input type="file" id="pattern-file" accept=".pat">
                    </div>

                    <div class="control-group">
                        <label>Or Load from Folder</label>
                        <input type="file" id="folder-input" webkitdirectory directory accept=".pat" style="display: none;">
                        <button class="btn secondary" id="folder-btn" onclick="document.getElementById('folder-input').click()">Select Folder...</button>
                        <div class="help-text">Select a folder like <code>G6_2x10</code> to auto-detect arena</div>
                    </div>

                    <!-- Pattern file dropdown - shown after folder selection -->
                    <div id="folder-pattern-select" class="control-group" style="display: none;">
                        <label>Select Pattern from Folder</label>
                        <select id="folder-pattern-dropdown">
                            <option value="">-- Select a pattern --</option>
                        </select>
                    </div>
                </div>

                <div class="divider"></div>

                <div class="section">
                    <div class="section-title">Detected Arena</div>

                    <div class="info-box" id="arena-info">
                        <div id="arena-detected" style="color: var(--text-dim);">
                            Load a pattern to detect arena configuration
                        </div>
                    </div>

                    <!-- Manual arena override - shown only when auto-detection fails -->
                    <div id="arena-override" class="control-group" style="display: none; margin-top: 0.75rem;">
                        <label>Manual Arena Selection</label>
                        <select id="arena-select">
                            <option value="">-- Select Arena --</option>
                        </select>
                    </div>
                </div>

                <div class="divider"></div>

                <div class="section">
                    <div class="section-title">Icon Mode</div>

                    <div class="radio-group" style="flex-wrap: wrap;">
                        <label class="radio-label">
                            <input type="radio" name="icon-mode" value="single" checked>
                            <span>Single Frame</span>
                        </label>
                        <label class="radio-label">
                            <input type="radio" name="icon-mode" value="motion">
                            <span>Motion Blur</span>
                        </label>
                        <label class="radio-label">
                            <input type="radio" name="icon-mode" value="gif">
                            <span>Animated GIF</span>
                        </label>
                    </div>

                    <!-- Single frame controls -->
                    <div id="single-frame-controls" class="control-group" style="margin-top: 1rem;">
                        <label>Frame <span class="range-value" id="frame-value">0</span></label>
                        <input type="range" id="frame-slider" min="0" max="0" value="0">
                    </div>

                    <!-- Motion blur controls -->
                    <div id="motion-controls" style="display: none; margin-top: 1rem;">
                        <div class="control-group">
                            <label>Frame Range</label>
                            <div class="frame-range-inputs">
                                <input type="number" id="frame-start" min="0" value="0" placeholder="Start">
                                <input type="number" id="frame-end" min="0" value="0" placeholder="End">
                            </div>
                        </div>
                        <div class="control-group">
                            <label>Max Frames to Sample</label>
                            <input type="number" id="max-frames" min="2" max="20" value="10">
                        </div>
                        <div class="control-group">
                            <label>Weighting</label>
                            <select id="weighting-select">
                                <option value="exponential">Exponential</option>
                                <option value="linear">Linear</option>
                            </select>
                        </div>
                    </div>

                    <!-- GIF controls -->
                    <div id="gif-controls" style="display: none; margin-top: 1rem;">
                        <div class="control-group">
                            <label>Playback FPS</label>
                            <select id="gif-fps">
                                <option value="5">5 FPS</option>
                                <option value="10" selected>10 FPS</option>
                                <option value="15">15 FPS</option>
                                <option value="20">20 FPS</option>
                                <option value="30">30 FPS</option>
                            </select>
                        </div>
                        <div class="help-text">All frames in the pattern will be included in the GIF animation.</div>
                    </div>
                </div>

                <div class="divider"></div>

                <div class="section">
                    <div class="section-title">Icon Settings</div>

                    <div class="control-group">
                        <label>Icon Size</label>
                        <select id="size-select">
                            <option value="128">128 × 128</option>
                            <option value="256" selected>256 × 256</option>
                            <option value="512">512 × 512</option>
                        </select>
                    </div>

                    <div class="control-group">
                        <label>Inner Radius <span class="range-value" id="radius-value">0.40</span></label>
                        <input type="range" id="radius-slider" min="0.1" max="0.75" step="0.01" value="0.4">
                    </div>

                    <div class="control-group">
                        <label>Background</label>
                        <select id="background-select">
                            <option value="dark">Dark</option>
                            <option value="white">White</option>
                            <option value="transparent">Transparent</option>
                        </select>
                    </div>
                </div>

                <div class="divider"></div>

                <div class="section">
                    <button class="btn" id="generate-btn" disabled>Generate Icon</button>
                    <button class="btn secondary" id="download-btn" style="margin-top: 0.5rem;" disabled>Download PNG</button>
                    <div id="gif-progress" style="display: none; margin-top: 0.75rem;">
                        <div style="background: var(--bg); border-radius: 4px; overflow: hidden; height: 6px;">
                            <div id="gif-progress-bar" style="width: 0%; height: 100%; background: var(--accent); transition: width 0.1s;"></div>
                        </div>
                        <div id="gif-progress-text" style="font-size: 0.7rem; color: var(--text-dim); text-align: center; margin-top: 0.25rem;">Encoding GIF...</div>
                    </div>
                </div>
            </div>

            <!-- Icon Display -->
            <div class="panel">
                <div class="icon-display">
                    <div class="icon-container" id="icon-container">
                        <div class="icon-placeholder">
                            Load a pattern file to begin
                        </div>
                    </div>

                    <div class="info-box" id="pattern-info" style="display: none; width: 100%;">
                        <div><span class="label">Pattern:</span> <span id="info-pattern">-</span></div>
                        <div><span class="label">Dimensions:</span> <span id="info-dims">-</span></div>
                        <div><span class="label">Frames:</span> <span id="info-frames">-</span></div>
                        <div><span class="label">Mode:</span> <span id="info-mode">-</span></div>
                    </div>
                </div>
            </div>
        </div>

        <footer>
            <p>Pattern Icon Generator v1.4 | 2026-02-04 08:19 ET</p>
            <p><a href="index.html">← Back to Tools</a></p>
        </footer>
    </div>

    <script>
        let currentPatternData = null;
        let currentArenaConfig = null;
        let currentIconDataURL = null;
        let currentFilename = null;
        let folderPatFiles = null; // Store .pat files from folder selection

        // Initialize - wait for modules to load
        function init() {
            setupEventListeners();
            updateArenaDisplay(null, null);
        }

        // Wait for ES6 modules to load, then initialize
        if (window.PatParser) {
            document.addEventListener('DOMContentLoaded', init);
        } else {
            window.addEventListener('modulesLoaded', () => {
                if (document.readyState === 'loading') {
                    document.addEventListener('DOMContentLoaded', init);
                } else {
                    init();
                }
            });
        }

        /**
         * Infer arena configuration from filename or parent folder path.
         * Matches patterns like: G6_2x10, G4_4x12, G4.1_3x12
         * @param {string} filepath - Full file path or filename
         * @returns {Object|null} - Config object { name, config } or null if not detected
         */
        function inferArenaFromPath(filepath) {
            if (!filepath) return null;

            // Patterns to match: G6_2x10, G4_4x12, G4.1_3x12, G6_2x8of10 (partial arenas)
            // Allow both "x" and "×" as separator
            // Optional "ofN" suffix for partial arenas (e.g., G6_2x8of10 = 8 of 10 columns installed)
            const arenaPattern = /G(6|4\.1|4|3)[_-](\d+)[x×](\d+)(?:of(\d+))?/i;

            // First check filename
            const filename = filepath.split('/').pop().split('\\').pop();
            let match = filename.match(arenaPattern);

            // If not found in filename, check parent folder (one level up)
            if (!match) {
                const pathParts = filepath.replace(/\\/g, '/').split('/');
                if (pathParts.length >= 2) {
                    const parentFolder = pathParts[pathParts.length - 2];
                    match = parentFolder.match(arenaPattern);
                }
            }

            if (!match) return null;

            const generation = 'G' + match[1];
            const rows = parseInt(match[2]);
            const installedCols = parseInt(match[3]);
            const totalCols = match[4] ? parseInt(match[4]) : installedCols;

            // Build config name - try partial format first if applicable
            let configName;
            if (totalCols !== installedCols) {
                // Partial arena format: G6_2x8of10
                configName = `${generation}_${rows}x${installedCols}of${totalCols}`;
            } else {
                // Full arena format: G6_2x10
                configName = `${generation}_${rows}x${totalCols}`;
            }

            // Try to find this config
            let config = getConfig(configName);
            if (config) {
                return { name: configName, config };
            }

            // Fallback: try without partial suffix (use full arena config)
            if (totalCols !== installedCols) {
                const fallbackName = `${generation}_${rows}x${totalCols}`;
                config = getConfig(fallbackName);
                if (config) {
                    console.warn(`Partial arena config ${configName} not found, using ${fallbackName}`);
                    return { name: fallbackName, config };
                }
            }

            // Config not found - return null
            console.warn(`Arena config not found for: ${configName}`);
            return null;
        }

        function updateArenaDisplay(configName, config) {
            const arenaInfo = document.getElementById('arena-info');
            const arenaDetected = document.getElementById('arena-detected');

            if (!config) {
                arenaDetected.innerHTML = `<span style="color: var(--text-dim);">Load a pattern to detect arena configuration</span>`;
                return;
            }

            const installedCols = config.arena.columns_installed?.length || config.arena.num_cols;
            const coverage = Math.round(360 * installedCols / config.arena.num_cols);

            arenaDetected.innerHTML =
                `<div style="color: var(--accent); font-weight: 600; margin-bottom: 0.5rem;">✓ Detected: ${config.label || configName}</div>` +
                `<div><span class="label">Generation:</span> ${config.arena.generation}</div>` +
                `<div><span class="label">Layout:</span> ${config.arena.num_rows} × ${config.arena.num_cols}</div>` +
                `<div><span class="label">Coverage:</span> ${coverage}°</div>`;
        }

        function showArenaError(filepath) {
            const arenaDetected = document.getElementById('arena-detected');
            arenaDetected.innerHTML =
                `<div style="color: #ff6b6b; font-weight: 600;">✗ Arena not detected</div>` +
                `<div style="margin-top: 0.5rem; font-size: 0.8rem;">` +
                `Could not detect arena from filename or parent folder.<br>` +
                `Expected format: <code>G6_2x10_*.pat</code> or folder named <code>G6_2x10</code>` +
                `</div>`;
        }

        function setupEventListeners() {
            // Pattern file input
            document.getElementById('pattern-file').addEventListener('change', handlePatternFile);

            // Folder input
            document.getElementById('folder-input').addEventListener('change', handleFolderSelect);

            // Folder pattern dropdown
            document.getElementById('folder-pattern-dropdown').addEventListener('change', handleFolderPatternSelect);

            // Arena override dropdown
            document.getElementById('arena-select').addEventListener('change', handleArenaOverride);

            // Icon mode radio buttons
            document.querySelectorAll('input[name="icon-mode"]').forEach(radio => {
                radio.addEventListener('change', toggleIconMode);
            });

            // Sliders
            document.getElementById('frame-slider').addEventListener('input', updateFrameValue);
            document.getElementById('radius-slider').addEventListener('input', updateRadiusValue);

            // Generate button
            document.getElementById('generate-btn').addEventListener('click', generateIcon);

            // Download button
            document.getElementById('download-btn').addEventListener('click', downloadIcon);

            // Populate arena dropdown for manual override
            populateArenaDropdown();
        }

        function populateArenaDropdown() {
            const select = document.getElementById('arena-select');
            const configsByGen = getConfigsByGeneration();

            for (const [gen, configs] of Object.entries(configsByGen)) {
                const optgroup = document.createElement('optgroup');
                optgroup.label = gen;
                configs.forEach(config => {
                    const option = document.createElement('option');
                    option.value = config.name;
                    option.textContent = config.label;
                    optgroup.appendChild(option);
                });
                select.appendChild(optgroup);
            }
        }

        function handleFolderSelect(event) {
            const files = event.target.files;
            if (!files || files.length === 0) return;

            // Find .pat files
            const patFiles = Array.from(files).filter(f => f.name.toLowerCase().endsWith('.pat'));

            if (patFiles.length === 0) {
                alert('No .pat files found in the selected folder');
                document.getElementById('folder-pattern-select').style.display = 'none';
                return;
            }

            // Store files for later loading
            folderPatFiles = patFiles;

            // Sort files alphabetically
            patFiles.sort((a, b) => a.name.localeCompare(b.name));

            // Populate dropdown
            const dropdown = document.getElementById('folder-pattern-dropdown');
            dropdown.innerHTML = '<option value="">-- Select a pattern --</option>';

            patFiles.forEach((file, index) => {
                const option = document.createElement('option');
                option.value = index;
                option.textContent = file.name;
                dropdown.appendChild(option);
            });

            // Show the dropdown
            document.getElementById('folder-pattern-select').style.display = 'block';

            // Try to detect arena from folder name (first file's path)
            const firstFilePath = patFiles[0].webkitRelativePath || patFiles[0].name;
            const arenaResult = inferArenaFromPath(firstFilePath);

            if (arenaResult) {
                updateArenaDisplay(arenaResult.name, arenaResult.config);
                currentArenaConfig = arenaResult.config.arena;
            } else {
                // Show warning but let user continue - they can select arena manually later
                showArenaError(firstFilePath);
                document.getElementById('arena-override').style.display = 'block';
            }

            // If only one file, auto-select it
            if (patFiles.length === 1) {
                dropdown.value = '0';
                handleFolderPatternSelect({ target: dropdown });
            }
        }

        async function handleFolderPatternSelect(event) {
            const index = event.target.value;
            if (index === '' || !folderPatFiles) return;

            const selectedFile = folderPatFiles[parseInt(index)];
            if (!selectedFile) return;

            try {
                const arrayBuffer = await selectedFile.arrayBuffer();
                const patternData = PatParser.parsePatFile(arrayBuffer);

                // webkitRelativePath contains the folder structure: "G6_2x10/filename.pat"
                const filepath = selectedFile.webkitRelativePath || selectedFile.name;
                currentFilename = selectedFile.name;

                console.log('Folder file path:', filepath); // Debug

                // Try to infer arena from the path (folder name or filename)
                const arenaResult = inferArenaFromPath(filepath);

                if (!arenaResult) {
                    showArenaError(filepath);
                    showArenaOverride(patternData);
                    // Still update pattern UI
                    updatePatternUI(patternData, selectedFile.name);
                    return;
                }

                currentArenaConfig = arenaResult.config.arena;
                currentPatternData = patternData;

                // Hide manual override
                document.getElementById('arena-override').style.display = 'none';

                // Update arena display
                updateArenaDisplay(arenaResult.name, arenaResult.config);

                // Update UI with pattern info
                updatePatternUI(patternData, selectedFile.name);

                // Enable generate button
                document.getElementById('generate-btn').disabled = false;
            } catch (error) {
                alert('Error loading pattern file: ' + error.message);
                console.error(error);
            }
        }

        // Store pending pattern data when manual override is needed
        let pendingPatternData = null;

        function showArenaOverride(patternData) {
            pendingPatternData = patternData;
            document.getElementById('arena-override').style.display = 'block';
            document.getElementById('arena-select').value = '';
            document.getElementById('generate-btn').disabled = true;
        }

        function handleArenaOverride(event) {
            const configName = event.target.value;
            if (!configName || !pendingPatternData) return;

            const config = getConfig(configName);
            if (!config) return;

            currentArenaConfig = config.arena;
            currentPatternData = pendingPatternData;

            // Update arena display
            updateArenaDisplay(configName, config);

            // Update UI with pattern info
            updatePatternUI(currentPatternData, currentFilename);

            // Enable generate button
            document.getElementById('generate-btn').disabled = false;
        }

        function updatePatternUI(patternData, filename) {
            document.getElementById('frame-slider').max = patternData.frames.length - 1;
            document.getElementById('frame-slider').value = Math.floor(patternData.frames.length / 2);
            document.getElementById('frame-start').max = patternData.frames.length - 1;
            document.getElementById('frame-end').max = patternData.frames.length - 1;
            document.getElementById('frame-end').value = patternData.frames.length - 1;
            updateFrameValue();

            // Show pattern info
            document.getElementById('info-pattern').textContent = filename;
            document.getElementById('info-dims').textContent = `${patternData.cols || patternData.pixelCols} × ${patternData.rows || patternData.pixelRows}`;
            document.getElementById('info-frames').textContent = patternData.frames.length;
            document.getElementById('info-mode').textContent = patternData.grayscaleMode || (patternData.gs_val === 16 ? 'GS16' : 'GS2');
            document.getElementById('pattern-info').style.display = 'block';
        }

        async function handlePatternFile(event) {
            const file = event.target.files[0];
            if (!file) return;

            try {
                const arrayBuffer = await file.arrayBuffer();
                const patternData = PatParser.parsePatFile(arrayBuffer);

                // Try to get full path from the file input
                // Note: browsers only expose filename for security, but we also check webkitRelativePath
                const filepath = file.webkitRelativePath || file.name;
                currentFilename = file.name;

                // Try to infer arena from filename/path
                const arenaResult = inferArenaFromPath(filepath);

                if (!arenaResult) {
                    showArenaError(filepath);
                    // Show manual override dropdown instead of blocking
                    showArenaOverride(patternData);
                    // Update pattern info even without arena
                    updatePatternUI(patternData, file.name);
                    return;
                }

                currentArenaConfig = arenaResult.config.arena;
                currentPatternData = patternData;

                // Hide manual override
                document.getElementById('arena-override').style.display = 'none';

                // Update arena display
                updateArenaDisplay(arenaResult.name, arenaResult.config);

                // Update UI
                updatePatternUI(patternData, file.name);

                // Enable generate button
                document.getElementById('generate-btn').disabled = false;
            } catch (error) {
                alert('Error loading pattern file: ' + error.message);
                console.error(error);
            }
        }

        function toggleIconMode() {
            const mode = document.querySelector('input[name="icon-mode"]:checked').value;

            // Hide all mode-specific controls
            document.getElementById('single-frame-controls').style.display = 'none';
            document.getElementById('motion-controls').style.display = 'none';
            document.getElementById('gif-controls').style.display = 'none';

            // Show controls for selected mode
            if (mode === 'single') {
                document.getElementById('single-frame-controls').style.display = 'block';
            } else if (mode === 'motion') {
                document.getElementById('motion-controls').style.display = 'block';
            } else if (mode === 'gif') {
                document.getElementById('gif-controls').style.display = 'block';
            }

            // Update button text
            const generateBtn = document.getElementById('generate-btn');
            generateBtn.textContent = mode === 'gif' ? 'Generate GIF' : 'Generate Icon';

            // Update download button text
            const downloadBtn = document.getElementById('download-btn');
            downloadBtn.textContent = mode === 'gif' ? 'Download GIF' : 'Download PNG';
        }

        function updateFrameValue() {
            const value = document.getElementById('frame-slider').value;
            document.getElementById('frame-value').textContent = value;
        }

        function updateRadiusValue() {
            const value = document.getElementById('radius-slider').value;
            document.getElementById('radius-value').textContent = parseFloat(value).toFixed(2);
        }

        let currentGifBlob = null;  // Store GIF blob for download

        async function generateIcon() {
            if (!currentPatternData || !currentArenaConfig) return;

            const mode = document.querySelector('input[name="icon-mode"]:checked').value;
            const size = parseInt(document.getElementById('size-select').value);
            const innerRadiusRatio = parseFloat(document.getElementById('radius-slider').value);
            const background = document.getElementById('background-select').value;

            const options = {
                width: size,
                height: size,
                innerRadiusRatio: innerRadiusRatio,
                backgroundColor: background,
                showGaps: true,
                showOutlines: true
            };

            try {
                if (mode === 'gif') {
                    // GIF generation
                    await generateGif(options);
                } else {
                    // PNG generation (single frame or motion blur)
                    let dataURL;

                    if (mode === 'single') {
                        const frameIndex = parseInt(document.getElementById('frame-slider').value);
                        options.frameIndex = frameIndex;
                        dataURL = IconGenerator.generatePatternIcon(currentPatternData, currentArenaConfig, options);
                    } else {
                        const frameStart = parseInt(document.getElementById('frame-start').value);
                        const frameEnd = parseInt(document.getElementById('frame-end').value);
                        const maxFrames = parseInt(document.getElementById('max-frames').value);
                        const weighting = document.getElementById('weighting-select').value;

                        options.frameRange = [frameStart, frameEnd];
                        options.maxFrames = maxFrames;
                        options.weightingFunction = weighting;

                        dataURL = IconGenerator.generateMotionIcon(currentPatternData, currentArenaConfig, options);
                    }

                    currentIconDataURL = dataURL;
                    currentGifBlob = null;  // Clear any previous GIF

                    // Display icon
                    const container = document.getElementById('icon-container');
                    container.innerHTML = `<img src="${dataURL}" alt="Pattern Icon">`;

                    // Enable download
                    document.getElementById('download-btn').disabled = false;
                }
            } catch (error) {
                alert('Error generating icon: ' + error.message);
                console.error(error);
            }
        }

        async function generateGif(options) {
            const fps = parseInt(document.getElementById('gif-fps').value);
            const progressDiv = document.getElementById('gif-progress');
            const progressBar = document.getElementById('gif-progress-bar');
            const progressText = document.getElementById('gif-progress-text');
            const generateBtn = document.getElementById('generate-btn');
            const downloadBtn = document.getElementById('download-btn');

            // Show progress UI
            progressDiv.style.display = 'block';
            progressBar.style.width = '0%';
            progressText.textContent = 'Encoding GIF...';
            generateBtn.disabled = true;
            generateBtn.textContent = 'Generating...';

            try {
                const gifOptions = {
                    ...options,
                    fps: fps
                };

                const blob = await IconGenerator.generatePatternGIF(currentPatternData, currentArenaConfig, gifOptions, (progress) => {
                    const pct = Math.round(progress * 100);
                    progressBar.style.width = pct + '%';
                    progressText.textContent = `Encoding GIF... ${pct}%`;
                });

                // Store blob for download
                currentGifBlob = blob;
                currentIconDataURL = null;  // Clear PNG data

                // Create object URL for display
                const url = URL.createObjectURL(blob);

                // Display GIF
                const container = document.getElementById('icon-container');
                container.innerHTML = `<img src="${url}" alt="Pattern GIF" style="max-width: 100%;">`;

                progressText.textContent = 'Done!';
                setTimeout(() => {
                    progressDiv.style.display = 'none';
                }, 1000);

                // Enable download
                downloadBtn.disabled = false;

            } catch (err) {
                console.error('GIF generation failed:', err);
                alert('GIF generation failed: ' + err.message);
                progressDiv.style.display = 'none';
            } finally {
                generateBtn.disabled = false;
                generateBtn.textContent = 'Generate GIF';
            }
        }

        function downloadIcon() {
            const mode = document.querySelector('input[name="icon-mode"]:checked').value;
            const link = document.createElement('a');

            // Use current filename (without extension) or arena config for naming
            let baseName = 'pattern';
            if (currentFilename) {
                baseName = currentFilename.replace(/\.pat$/i, '');
            }

            const timestamp = new Date().toISOString().replace(/:/g, '-').split('.')[0];

            if (mode === 'gif' && currentGifBlob) {
                // Download GIF
                const fps = document.getElementById('gif-fps').value;
                link.download = `${baseName}_${fps}fps_${timestamp}.gif`;
                link.href = URL.createObjectURL(currentGifBlob);
                link.click();
                URL.revokeObjectURL(link.href);
            } else if (currentIconDataURL) {
                // Download PNG
                link.download = `${baseName}_icon_${mode}_${timestamp}.png`;
                link.href = currentIconDataURL;
                link.click();
            }
        }
    </script>
</body>
</html>
