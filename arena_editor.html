<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Arena Layout Editor - PanelDisplayTools</title>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700&family=IBM+Plex+Mono:wght@400;600&display=swap" rel="stylesheet">
    <script src="js/arena-configs.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        :root {
            --bg: #0f1419;
            --surface: #1a1f26;
            --border: #2d3640;
            --text: #e6edf3;
            --text-dim: #8b949e;
            --accent: #00e676;
            --hover: #00c853;
            --panel-green: #00e676;
            --panel-active: #00c853;
            --panel-inactive: #3d4450;
            --panel-inactive-dim: #2a2e35;
        }

        body {
            font-family: 'IBM Plex Mono', monospace;
            background: var(--bg);
            color: var(--text);
            min-height: 100vh;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 1.5rem;
        }

        header {
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 2px solid var(--border);
        }

        .nav-link {
            display: inline-block;
            color: var(--text-dim);
            text-decoration: none;
            margin-bottom: 0.75rem;
            font-size: 0.9rem;
            transition: color 0.2s;
        }

        .nav-link:hover { color: var(--accent); }

        h1 {
            font-family: 'JetBrains Mono', monospace;
            font-size: 1.75rem;
            font-weight: 700;
            color: var(--accent);
        }

        .subtitle {
            color: var(--text-dim);
            font-size: 0.85rem;
            margin-top: 0.3rem;
        }

        /* Main Layout */
        .main-content {
            display: grid;
            grid-template-columns: 280px 1fr 280px;
            gap: 1.5rem;
        }

        @media (max-width: 1100px) {
            .main-content {
                grid-template-columns: 1fr;
            }
        }

        /* Panels */
        .panel {
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 1.25rem;
        }

        .panel h2 {
            font-family: 'JetBrains Mono', monospace;
            font-size: 1rem;
            color: var(--accent);
            margin-bottom: 1rem;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid var(--border);
        }

        /* Controls */
        .control-group {
            margin-bottom: 1.25rem;
        }

        .control-group label {
            display: block;
            font-size: 0.8rem;
            color: var(--text-dim);
            margin-bottom: 0.4rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        /* Config Select Dropdown */
        .config-select {
            width: 100%;
            padding: 0.6rem 0.75rem;
            background: var(--bg);
            border: 1px solid var(--border);
            border-radius: 4px;
            color: var(--text);
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.85rem;
            cursor: pointer;
        }

        .config-select:hover {
            border-color: var(--accent);
        }

        .config-select:focus {
            outline: none;
            border-color: var(--accent);
        }

        .config-select option {
            background: var(--surface);
            color: var(--text);
        }

        .config-select optgroup {
            background: var(--bg);
            color: var(--accent);
            font-weight: bold;
        }

        /* Generation Tabs (Create mode only) */
        .gen-tabs {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
        }

        .gen-tab {
            padding: 0.5rem 1rem;
            background: var(--bg);
            border: 1px solid var(--border);
            border-radius: 4px;
            color: var(--text-dim);
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.85rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .gen-tab:hover {
            border-color: var(--accent);
            color: var(--text);
        }

        .gen-tab.active {
            background: var(--accent);
            border-color: var(--accent);
            color: var(--bg);
            font-weight: 700;
        }

        /* Number Input */
        .number-input {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .number-input button {
            width: 36px;
            height: 36px;
            background: var(--bg);
            border: 1px solid var(--border);
            border-radius: 4px;
            color: var(--text);
            font-size: 1.2rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .number-input button:hover {
            border-color: var(--accent);
            color: var(--accent);
        }

        .number-input button:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        .number-input input {
            width: 60px;
            height: 36px;
            background: var(--bg);
            border: 1px solid var(--border);
            border-radius: 4px;
            color: var(--text);
            font-family: 'JetBrains Mono', monospace;
            font-size: 1rem;
            text-align: center;
        }

        .number-input input:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        /* Property display (read-only) */
        .property-row {
            display: flex;
            justify-content: space-between;
            padding: 0.4rem 0;
            border-bottom: 1px solid var(--border);
            font-size: 0.85rem;
        }

        .property-row:last-child {
            border-bottom: none;
        }

        .property-row .label {
            color: var(--text-dim);
        }

        .property-row .value {
            color: var(--text);
            font-family: 'JetBrains Mono', monospace;
        }

        /* Canvas Container */
        .canvas-container {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        #arena-canvas {
            background: white;
            border-radius: 8px;
            max-width: 100%;
        }

        .canvas-controls {
            display: flex;
            gap: 0.75rem;
            margin-top: 0.75rem;
        }

        .toggle-btn {
            padding: 0.4rem 0.8rem;
            background: var(--bg);
            border: 1px solid var(--border);
            border-radius: 4px;
            color: var(--text-dim);
            font-family: 'IBM Plex Mono', monospace;
            font-size: 0.8rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .toggle-btn:hover {
            border-color: var(--accent);
        }

        .toggle-btn.active {
            background: rgba(0, 230, 118, 0.1);
            border-color: var(--accent);
            color: var(--accent);
        }

        .canvas-info {
            margin-top: 0.5rem;
            font-size: 0.85rem;
            color: var(--text-dim);
            text-align: center;
        }

        /* Resolution Box */
        .resolution-box {
            background: rgba(0, 230, 118, 0.1);
            border: 2px solid var(--accent);
            border-radius: 8px;
            padding: 1rem;
            text-align: center;
            margin-bottom: 1.25rem;
        }

        .resolution-box .label {
            font-size: 0.75rem;
            color: var(--accent);
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 0.25rem;
        }

        .resolution-box .sublabel {
            font-size: 0.7rem;
            color: var(--text-dim);
            margin-bottom: 0.5rem;
        }

        .resolution-box .value {
            font-family: 'JetBrains Mono', monospace;
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--accent);
        }

        .resolution-box .pixels {
            font-size: 0.85rem;
            color: var(--text);
            margin-top: 0.25rem;
        }

        /* Metrics */
        .metric {
            display: flex;
            justify-content: space-between;
            padding: 0.5rem 0;
            border-bottom: 1px solid var(--border);
            font-size: 0.85rem;
        }

        .metric:last-child {
            border-bottom: none;
        }

        .metric .label {
            color: var(--text-dim);
        }

        .metric .value {
            color: var(--text);
            font-family: 'JetBrains Mono', monospace;
        }

        /* Buttons */
        .export-btn {
            width: 100%;
            padding: 0.75rem;
            background: var(--accent);
            border: none;
            border-radius: 6px;
            color: var(--bg);
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.9rem;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.2s;
            margin-top: 0.75rem;
        }

        .export-btn:hover {
            background: var(--hover);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 230, 118, 0.3);
        }

        .export-btn.secondary {
            background: var(--surface);
            border: 1px solid var(--accent);
            color: var(--accent);
        }

        .export-btn.secondary:hover {
            background: rgba(0, 230, 118, 0.1);
        }

        .export-btn.small {
            padding: 0.5rem 0.75rem;
            font-size: 0.8rem;
            margin-top: 0.5rem;
        }

        /* Mode sections */
        .mode-section {
            display: none;
        }

        .mode-section.active {
            display: block;
        }

        /* Divider */
        .divider {
            border-top: 1px solid var(--border);
            margin: 1rem 0;
        }

        /* Unit Toggle */
        .unit-toggle {
            display: flex;
            background: var(--bg);
            border: 1px solid var(--border);
            border-radius: 4px;
            overflow: hidden;
        }

        .unit-toggle button {
            flex: 1;
            padding: 0.5rem;
            background: transparent;
            border: none;
            color: var(--text-dim);
            font-family: 'IBM Plex Mono', monospace;
            font-size: 0.85rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .unit-toggle button.active {
            background: var(--accent);
            color: var(--bg);
            font-weight: 600;
        }

        /* Footer */
        footer {
            text-align: center;
            margin-top: 2rem;
            padding-top: 1.5rem;
            border-top: 2px solid var(--border);
            color: var(--text-dim);
            font-size: 0.8rem;
        }

        footer a {
            color: var(--accent);
            text-decoration: none;
        }

        footer a:hover { color: var(--hover); }

        footer .version {
            margin-top: 0.5rem;
            font-size: 0.75rem;
            color: var(--text-dim);
            opacity: 0.7;
        }

        /* Mode indicator */
        .mode-indicator {
            display: inline-block;
            padding: 0.25rem 0.5rem;
            background: var(--bg);
            border: 1px solid var(--border);
            border-radius: 4px;
            font-size: 0.7rem;
            color: var(--text-dim);
            margin-left: 0.5rem;
            text-transform: uppercase;
        }

        .mode-indicator.create {
            border-color: var(--accent);
            color: var(--accent);
        }

        .info-note {
            font-size: 0.7rem;
            color: var(--text-dim);
            margin-top: 0.5rem;
            line-height: 1.4;
            opacity: 0.8;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <a href="index.html" class="nav-link">← Back to Tools</a>
            <h1>Arena Layout Editor <span class="mode-indicator" id="mode-indicator">View</span></h1>
            <p class="subtitle">Select an arena configuration or create a new one</p>
        </header>

        <div class="main-content">
            <!-- Left Panel: Config Selection & Properties -->
            <div class="panel">
                <!-- View Mode: Config Selection -->
                <div id="view-mode-controls" class="mode-section active">
                    <h2>Arena Config</h2>

                    <div class="control-group">
                        <label>Select Configuration</label>
                        <select class="config-select" id="config-select">
                            <optgroup label="G6 Arenas" id="config-group-G6"></optgroup>
                            <optgroup label="G4.1 Arenas" id="config-group-G41"></optgroup>
                            <optgroup label="G4 Arenas" id="config-group-G4"></optgroup>
                            <optgroup label="G3 Arenas" id="config-group-G3"></optgroup>
                        </select>
                        <p class="info-note">G4.1 & G6 actively tested. G3 & G4 for comparison only.</p>
                    </div>

                    <button class="export-btn secondary small" id="load-file">Load from File</button>

                    <div class="divider"></div>

                    <div class="control-group">
                        <label>Properties</label>
                        <div class="property-row">
                            <span class="label">Generation</span>
                            <span class="value" id="prop-generation">G6</span>
                        </div>
                        <div class="property-row">
                            <span class="label">Rows</span>
                            <span class="value" id="prop-rows">2</span>
                        </div>
                        <div class="property-row">
                            <span class="label">Columns</span>
                            <span class="value" id="prop-cols">10</span>
                        </div>
                        <div class="property-row">
                            <span class="label">Column Order</span>
                            <span class="value" id="prop-order">CW</span>
                        </div>
                        <div class="property-row">
                            <span class="label">Offset</span>
                            <span class="value" id="prop-offset">0°</span>
                        </div>
                        <div class="property-row">
                            <span class="label">Coverage</span>
                            <span class="value" id="prop-coverage">360°</span>
                        </div>
                    </div>

                    <div class="divider"></div>

                    <button class="export-btn secondary" id="clone-config">Clone as New</button>
                    <button class="export-btn secondary" id="create-new">+ Create New Arena</button>
                </div>

                <!-- Create Mode: Editable Controls -->
                <div id="create-mode-controls" class="mode-section">
                    <h2>Create Arena</h2>

                    <div class="control-group">
                        <label>Panel Generation</label>
                        <div class="gen-tabs">
                            <button class="gen-tab" data-gen="G3">G3</button>
                            <button class="gen-tab" data-gen="G4">G4</button>
                            <button class="gen-tab" data-gen="G4.1">G4.1</button>
                            <button class="gen-tab active" data-gen="G6">G6</button>
                        </div>
                    </div>

                    <div class="control-group">
                        <label>Number of Columns</label>
                        <div class="number-input">
                            <button id="cols-dec">−</button>
                            <input type="number" id="num-cols" value="10" min="4" max="36">
                            <button id="cols-inc">+</button>
                        </div>
                    </div>

                    <div class="control-group">
                        <label>Number of Rows</label>
                        <div class="number-input">
                            <button id="rows-dec">−</button>
                            <input type="number" id="num-rows" value="2" min="1" max="6">
                            <button id="rows-inc">+</button>
                        </div>
                    </div>

                    <div class="control-group">
                        <label>Column Order</label>
                        <div class="unit-toggle">
                            <button class="active" data-order="cw">CW</button>
                            <button data-order="ccw">CCW</button>
                        </div>
                    </div>

                    <div class="control-group">
                        <label>Angle Offset (degrees)</label>
                        <div class="number-input">
                            <button id="offset-dec">−</button>
                            <input type="number" id="angle-offset" value="0" min="-180" max="180" step="5">
                            <button id="offset-inc">+</button>
                        </div>
                    </div>

                    <div class="control-group">
                        <label>Panels Installed</label>
                        <div class="property-row">
                            <span class="label">Active</span>
                            <span class="value" id="active-panels">10 / 10</span>
                        </div>
                        <p style="font-size: 0.7rem; color: var(--text-dim); margin-top: 0.3rem;">Click panels in the diagram to toggle</p>
                    </div>

                    <div class="divider"></div>

                    <button class="export-btn" id="save-config">Save Config (YAML)</button>
                    <button class="export-btn secondary" id="cancel-create">Cancel</button>
                </div>
            </div>

            <!-- Center: Canvas -->
            <div class="panel canvas-container">
                <svg id="arena-canvas" width="500" height="500" viewBox="-6 -6 12 12"></svg>
                <div class="canvas-controls">
                    <button id="toggle-col-nums" class="toggle-btn active"># Column Numbers</button>
                </div>
                <div class="canvas-info">
                    <span id="title-info">G6 Full (2×10) Arena</span>
                </div>
            </div>

            <!-- Right Panel: Metrics -->
            <div class="panel">
                <h2>Arena Metrics</h2>

                <div class="resolution-box">
                    <div class="label">Azimuthal Resolution</div>
                    <div class="sublabel">(from center)</div>
                    <div class="value" id="deg-per-pixel">1.80°</div>
                    <div class="pixels"><span id="azimuthal-pixels">200</span> pixels around</div>
                </div>

                <div class="metric">
                    <span class="label">Panel Type</span>
                    <span class="value" id="panel-type">G6 (45.4 mm)</span>
                </div>

                <div class="metric">
                    <span class="label">Inner Radius</span>
                    <span class="value" id="inner-radius">70.0 mm</span>
                </div>

                <div class="metric">
                    <span class="label">Outer Radius</span>
                    <span class="value" id="outer-radius">73.4 mm</span>
                </div>

                <div class="metric">
                    <span class="label">Azimuth Coverage</span>
                    <span class="value" id="azimuth-coverage">360.0°</span>
                </div>

                <div class="metric">
                    <span class="label">Azimuth Gap</span>
                    <span class="value" id="azimuth-gap">0.0°</span>
                </div>

                <div class="divider"></div>

                <div class="control-group">
                    <label>Display Units</label>
                    <div class="unit-toggle">
                        <button data-unit="inches">Inches</button>
                        <button class="active" data-unit="mm">mm</button>
                    </div>
                </div>

                <button class="export-btn secondary" id="view-3d">View in 3D</button>
                <button class="export-btn secondary" id="export-pdf">Export PDF</button>
            </div>
        </div>

        <footer>
            <p><a href="https://github.com/reiserlab/webDisplayTools" target="_blank">Reiser Lab</a> | PanelDisplayTools</p>
            <p class="version">Arena Editor v3.1 | 2026-01-30 15:00 ET</p>
        </footer>
    </div>

    <script>
        // State
        let state = {
            mode: 'view',  // 'view' or 'create'
            configSource: {
                type: 'standard',  // 'standard', 'file', 'custom'
                name: 'G6_2x10'
            },
            arena: {
                generation: 'G6',
                num_rows: 2,
                num_cols: 10,
                columns_installed: null,  // null = all installed
                column_order: 'cw',
                angle_offset_deg: 0
            },
            showColumnNumbers: true,
            units: 'mm'
        };

        // DOM elements
        const canvas = document.getElementById('arena-canvas');

        // Populate config dropdown from STANDARD_CONFIGS
        function populateConfigDropdown() {
            const groups = getConfigsByGeneration();

            for (const [gen, configs] of Object.entries(groups)) {
                const groupId = gen === 'G4.1' ? 'G41' : gen;
                const optgroup = document.getElementById(`config-group-${groupId}`);
                if (!optgroup) continue;

                optgroup.innerHTML = '';
                for (const config of configs) {
                    const option = document.createElement('option');
                    option.value = config.name;
                    option.textContent = config.label;
                    optgroup.appendChild(option);
                }
            }
        }

        // Load a standard config by name
        function loadStandardConfig(name) {
            const config = getConfig(name);
            if (!config) return;

            state.configSource = { type: 'standard', name };
            state.arena = { ...config.arena };
            state.mode = 'view';

            updateUIForViewMode();
            updatePropertiesDisplay();
            updateArena();
        }

        // Update UI for view mode
        function updateUIForViewMode() {
            state.mode = 'view';
            document.getElementById('view-mode-controls').classList.add('active');
            document.getElementById('create-mode-controls').classList.remove('active');
            document.getElementById('mode-indicator').textContent = 'View';
            document.getElementById('mode-indicator').classList.remove('create');
        }

        // Update UI for create mode
        function updateUIForCreateMode() {
            state.mode = 'create';
            document.getElementById('view-mode-controls').classList.remove('active');
            document.getElementById('create-mode-controls').classList.add('active');
            document.getElementById('mode-indicator').textContent = 'Create';
            document.getElementById('mode-indicator').classList.add('create');

            // Update create mode controls to match state
            document.querySelectorAll('.gen-tab').forEach(t => t.classList.remove('active'));
            const genTab = document.querySelector(`.gen-tab[data-gen="${state.arena.generation}"]`);
            if (genTab) genTab.classList.add('active');

            document.getElementById('num-cols').value = state.arena.num_cols;
            document.getElementById('num-rows').value = state.arena.num_rows;
            document.getElementById('angle-offset').value = state.arena.angle_offset_deg;

            document.querySelectorAll('[data-order]').forEach(b => b.classList.remove('active'));
            const orderBtn = document.querySelector(`[data-order="${state.arena.column_order}"]`);
            if (orderBtn) orderBtn.classList.add('active');

            updateActivePanelsDisplay();
        }

        // Update properties display (view mode)
        function updatePropertiesDisplay() {
            document.getElementById('prop-generation').textContent = state.arena.generation;
            document.getElementById('prop-rows').textContent = state.arena.num_rows;
            document.getElementById('prop-cols').textContent = state.arena.num_cols;
            document.getElementById('prop-order').textContent = state.arena.column_order.toUpperCase();
            document.getElementById('prop-offset').textContent = state.arena.angle_offset_deg + '°';

            // Calculate coverage
            const installedCols = getInstalledColumnCount();
            const coverage = Math.round(360 * installedCols / state.arena.num_cols);
            document.getElementById('prop-coverage').textContent = coverage + '°';
        }

        // Get installed column count
        function getInstalledColumnCount() {
            if (state.arena.columns_installed === null) {
                return state.arena.num_cols;
            }
            // Handle both column indices and panel indices
            const maxIndex = Math.max(...state.arena.columns_installed);
            if (maxIndex < state.arena.num_cols) {
                return state.arena.columns_installed.length;
            } else {
                const uniqueCols = new Set(state.arena.columns_installed.map(p => p % state.arena.num_cols));
                return uniqueCols.size;
            }
        }

        // Get set of installed column indices (1-indexed for internal use)
        function getInstalledColumnsSet() {
            if (state.arena.columns_installed === null) {
                return new Set([...Array(state.arena.num_cols).keys()].map(i => i + 1));
            }
            // Handle both column indices and panel indices
            const maxIndex = Math.max(...state.arena.columns_installed);
            if (maxIndex < state.arena.num_cols) {
                // Column indices (0-indexed in config, convert to 1-indexed)
                return new Set(state.arena.columns_installed.map(i => i + 1));
            } else {
                // Panel indices - extract unique columns (convert to 1-indexed)
                const uniqueCols = new Set(state.arena.columns_installed.map(p => (p % state.arena.num_cols) + 1));
                return uniqueCols;
            }
        }

        // Update active panels display (create mode)
        function updateActivePanelsDisplay() {
            const installed = getInstalledColumnCount();
            document.getElementById('active-panels').textContent = `${installed} / ${state.arena.num_cols}`;
        }

        // Column numbering convention:
        // - c0/cN-1 boundary is at SOUTH (bottom of screen, -Y in SVG coords)
        // - CW order: c0 just LEFT of south, columns increase counter-clockwise
        // - CCW order: c0 just RIGHT of south, columns increase clockwise (mirror)
        const BASE_OFFSET_RAD = -Math.PI / 2;  // Baseline at south instead of east

        // Calculate geometry
        function calculateGeometry() {
            const specs = PANEL_SPECS[state.arena.generation];
            const numCols = state.arena.num_cols;

            // Convert to working units (inches internally)
            const panelWidth = specs.panel_width_mm / 25.4;
            const panelDepth = specs.panel_depth_mm / 25.4;
            const angleOffsetRad = (state.arena.angle_offset_deg * Math.PI) / 180;

            // Calculate geometry
            const alpha = (2 * Math.PI) / numCols;
            const halfPanel = alpha / 2;  // Offset so c0 starts at boundary, not centered
            const cRadius = panelWidth / (Math.tan(alpha / 2)) / 2;
            const backCRadius = cRadius + panelDepth;

            // Resolution
            const degsPerPixel = 360 / (numCols * specs.pixels_per_panel);
            const azimuthalPixels = numCols * specs.pixels_per_panel;

            // Coverage
            const installedCols = getInstalledColumnCount();
            const azimuthCoverage = 360 * (installedCols / numCols);
            const azimuthGap = 360 - azimuthCoverage;

            return {
                specs,
                panelWidth,
                panelDepth,
                alpha,
                halfPanel,
                cRadius,
                backCRadius,
                degsPerPixel,
                azimuthalPixels,
                azimuthCoverage,
                azimuthGap,
                angleOffsetRad
            };
        }

        // Update the SVG arena visualization
        function updateArena() {
            const geom = calculateGeometry();
            const { specs, panelWidth, panelDepth, cRadius, backCRadius, alpha, halfPanel, angleOffsetRad } = geom;
            const installedSet = getInstalledColumnsSet();

            // Clear canvas
            canvas.innerHTML = '';

            // Set viewBox based on arena size
            const viewSize = backCRadius * 1.5;
            canvas.setAttribute('viewBox', `${-viewSize} ${-viewSize} ${viewSize * 2} ${viewSize * 2}`);

            // Draw axes
            const axisLen = viewSize * 0.95;
            addLine(-axisLen, 0, axisLen, 0, '#ccc', 0.015);
            addLine(0, -axisLen, 0, axisLen, '#ccc', 0.015);

            // Draw compass indicators
            const compassRadius = viewSize * 0.92;
            const compassFontSize = viewSize * 0.08;
            addText(0, -compassRadius, 'N', '#666', compassFontSize, 'middle', 'auto');
            addText(0, compassRadius, 'S', '#666', compassFontSize, 'middle', 'hanging');

            // Draw inner radius dimension line
            drawDimensionLine(geom, viewSize);

            // Draw panels with proper CW/CCW column ordering
            // CW: c0 just LEFT of south, columns increase counter-clockwise
            // CCW: c0 just RIGHT of south, columns increase clockwise (mirror)
            for (let j = 1; j <= state.arena.num_cols; j++) {
                const colIndex = j - 1;  // 0-indexed column number
                let alphaJ;
                if (state.arena.column_order === 'cw') {
                    // CW: start left of south, go counter-clockwise (decreasing angle)
                    alphaJ = BASE_OFFSET_RAD - halfPanel - colIndex * alpha + angleOffsetRad;
                } else {
                    // CCW: start right of south, go clockwise (increasing angle)
                    alphaJ = BASE_OFFSET_RAD + halfPanel + colIndex * alpha + angleOffsetRad;
                }
                const pAngle = alphaJ + Math.PI / 2;
                const isInstalled = installedSet.has(j);

                // Panel center
                const cx = cRadius * Math.cos(alphaJ);
                const cy = cRadius * Math.sin(alphaJ);

                // Front vertices
                const fx1 = cx - (panelWidth / 2) * Math.cos(pAngle);
                const fy1 = cy - (panelWidth / 2) * Math.sin(pAngle);
                const fx2 = cx + (panelWidth / 2) * Math.cos(pAngle);
                const fy2 = cy + (panelWidth / 2) * Math.sin(pAngle);

                // Back center and vertices
                const bcx = backCRadius * Math.cos(alphaJ);
                const bcy = backCRadius * Math.sin(alphaJ);
                const bx1 = bcx - (panelWidth / 2) * Math.cos(pAngle);
                const by1 = bcy - (panelWidth / 2) * Math.sin(pAngle);
                const bx2 = bcx + (panelWidth / 2) * Math.cos(pAngle);
                const by2 = bcy + (panelWidth / 2) * Math.sin(pAngle);

                // Draw panel (clickable group in create mode)
                const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');

                if (state.mode === 'create') {
                    g.style.cursor = 'pointer';
                    g.addEventListener('click', () => togglePanel(j));
                }

                // Colors based on installed state
                const frontColor = isInstalled ? '#00c853' : '#333';
                const edgeColor = isInstalled ? '#333' : '#222';
                const frontWidth = isInstalled ? 0.08 : 0.04;
                const edgeWidth = isInstalled ? 0.04 : 0.02;
                const opacity = isInstalled ? 1 : 0.4;

                g.setAttribute('opacity', opacity);

                // Front edge
                g.appendChild(createLine(fx1, -fy1, fx2, -fy2, frontColor, frontWidth));
                // Back edge
                g.appendChild(createLine(bx1, -by1, bx2, -by2, edgeColor, edgeWidth));
                // Side edges
                g.appendChild(createLine(bx1, -by1, fx1, -fy1, edgeColor, edgeWidth));
                g.appendChild(createLine(bx2, -by2, fx2, -fy2, edgeColor, edgeWidth));

                canvas.appendChild(g);
            }

            // Draw column numbers if enabled
            if (state.showColumnNumbers) {
                drawColumnNumbers(geom, installedSet);
            }

            // Update metrics display
            updateMetrics(geom);

            // Update title
            updateTitle();
        }

        function drawDimensionLine(geom, viewSize) {
            const { cRadius } = geom;
            const unitScale = state.units === 'mm' ? 25.4 : 1;
            const unitLabel = state.units === 'mm' ? 'mm' : 'in';
            const radiusValue = (cRadius * unitScale).toFixed(1);

            // Draw dimension line along positive X axis
            const lineY = 0;
            const tickSize = viewSize * 0.03;
            const dimColor = '#666';
            const strokeWidth = 0.02;

            addLine(0, lineY, cRadius, lineY, dimColor, strokeWidth);
            addLine(0, lineY - tickSize, 0, lineY + tickSize, dimColor, strokeWidth);
            addLine(cRadius, lineY - tickSize, cRadius, lineY + tickSize, dimColor, strokeWidth);

            // Arrows
            const arrowSize = viewSize * 0.025;
            addLine(cRadius, lineY, cRadius - arrowSize, lineY - arrowSize * 0.5, dimColor, strokeWidth);
            addLine(cRadius, lineY, cRadius - arrowSize, lineY + arrowSize * 0.5, dimColor, strokeWidth);
            addLine(0, lineY, arrowSize, lineY - arrowSize * 0.5, dimColor, strokeWidth);
            addLine(0, lineY, arrowSize, lineY + arrowSize * 0.5, dimColor, strokeWidth);

            // Label
            const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            text.setAttribute('x', cRadius / 2);
            text.setAttribute('y', -viewSize * 0.06);
            text.setAttribute('text-anchor', 'middle');
            text.setAttribute('font-size', viewSize * 0.07);
            text.setAttribute('font-family', 'JetBrains Mono, monospace');
            text.setAttribute('fill', '#333');
            text.textContent = `r = ${radiusValue} ${unitLabel}`;
            canvas.appendChild(text);
        }

        function drawColumnNumbers(geom, installedSet) {
            const { alpha, backCRadius, halfPanel, angleOffsetRad } = geom;
            const viewSize = backCRadius * 1.5;
            const labelRadius = backCRadius * 1.15;
            const fontSize = viewSize * 0.06;

            for (let j = 1; j <= state.arena.num_cols; j++) {
                const colIndex = j - 1;  // 0-indexed column number
                const isInstalled = installedSet.has(j);

                // Calculate label position using same logic as panel drawing
                let alphaJ;
                if (state.arena.column_order === 'cw') {
                    alphaJ = BASE_OFFSET_RAD - halfPanel - colIndex * alpha + angleOffsetRad;
                } else {
                    alphaJ = BASE_OFFSET_RAD + halfPanel + colIndex * alpha + angleOffsetRad;
                }

                const labelX = labelRadius * Math.cos(alphaJ);
                const labelY = -labelRadius * Math.sin(alphaJ);

                // Create label with "c#" format matching MATLAB
                const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                text.setAttribute('x', labelX);
                text.setAttribute('y', labelY);
                text.setAttribute('text-anchor', 'middle');
                text.setAttribute('dominant-baseline', 'middle');
                text.setAttribute('font-size', fontSize);
                text.setAttribute('font-family', 'JetBrains Mono, monospace');
                text.setAttribute('font-weight', 'bold');
                text.setAttribute('fill', isInstalled ? '#00897b' : '#666');  // Teal for installed
                text.setAttribute('opacity', isInstalled ? 1 : 0.5);
                text.textContent = `c${colIndex}`;  // "c0", "c1", etc.

                canvas.appendChild(text);
            }
        }

        function createLine(x1, y1, x2, y2, color, width) {
            const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            line.setAttribute('x1', x1);
            line.setAttribute('y1', y1);
            line.setAttribute('x2', x2);
            line.setAttribute('y2', y2);
            line.setAttribute('stroke', color);
            line.setAttribute('stroke-width', width);
            line.setAttribute('stroke-linecap', 'round');
            return line;
        }

        function addLine(x1, y1, x2, y2, color, width) {
            canvas.appendChild(createLine(x1, y1, x2, y2, color, width));
        }

        function addText(x, y, content, color, fontSize, anchor, baseline) {
            const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            text.setAttribute('x', x);
            text.setAttribute('y', y);
            text.setAttribute('text-anchor', anchor || 'middle');
            text.setAttribute('dominant-baseline', baseline || 'middle');
            text.setAttribute('font-size', fontSize);
            text.setAttribute('font-family', 'JetBrains Mono, monospace');
            text.setAttribute('font-weight', 'bold');
            text.setAttribute('fill', color);
            text.textContent = content;
            canvas.appendChild(text);
        }

        function updateMetrics(geom) {
            const { specs, cRadius, backCRadius, degsPerPixel, azimuthalPixels, azimuthCoverage, azimuthGap } = geom;

            const unitScale = state.units === 'mm' ? 25.4 : 1;
            const unitLabel = state.units === 'mm' ? 'mm' : 'in';

            document.getElementById('deg-per-pixel').textContent = degsPerPixel.toFixed(2) + '°';
            document.getElementById('azimuthal-pixels').textContent = azimuthalPixels;
            document.getElementById('panel-type').textContent = `${state.arena.generation} (${specs.panel_width_mm.toFixed(1)} mm)`;
            document.getElementById('inner-radius').textContent = (cRadius * unitScale).toFixed(1) + ' ' + unitLabel;
            document.getElementById('outer-radius').textContent = (backCRadius * unitScale).toFixed(1) + ' ' + unitLabel;
            document.getElementById('azimuth-coverage').textContent = azimuthCoverage.toFixed(1) + '°';
            document.getElementById('azimuth-gap').textContent = azimuthGap.toFixed(1) + '°';
        }

        function updateTitle() {
            const config = getConfig(state.configSource.name);
            if (state.mode === 'view' && config) {
                document.getElementById('title-info').textContent = config.label;
            } else {
                const installedCols = getInstalledColumnCount();
                const isFull = installedCols === state.arena.num_cols;
                const suffix = isFull ? 'Full' : 'Partial';
                document.getElementById('title-info').textContent =
                    `${state.arena.generation} ${suffix} (${state.arena.num_rows}×${state.arena.num_cols}) Arena`;
            }
        }

        // Toggle panel in create mode
        function togglePanel(colIndex) {
            if (state.mode !== 'create') return;

            // Convert columns_installed to column indices set if needed
            let installedCols;
            if (state.arena.columns_installed === null) {
                installedCols = new Set([...Array(state.arena.num_cols).keys()]);
            } else {
                installedCols = new Set(state.arena.columns_installed);
            }

            const colIdx = colIndex - 1;  // Convert to 0-indexed
            if (installedCols.has(colIdx)) {
                installedCols.delete(colIdx);
            } else {
                installedCols.add(colIdx);
            }

            // Update state
            if (installedCols.size === state.arena.num_cols) {
                state.arena.columns_installed = null;
            } else {
                state.arena.columns_installed = Array.from(installedCols).sort((a, b) => a - b);
            }

            updateActivePanelsDisplay();
            updateArena();
        }

        // Reset panels to all installed
        function resetPanels() {
            state.arena.columns_installed = null;
            updateActivePanelsDisplay();
        }

        // Export config as YAML
        function exportConfig() {
            const geom = calculateGeometry();
            const installedCols = getInstalledColumnCount();
            const totalCols = state.arena.num_cols;
            const isFull = installedCols === totalCols;

            const genName = state.arena.generation.replace('.', '');
            const configSuffix = isFull ? 'full' : 'partial';
            const defaultName = `${genName}_${state.arena.num_rows}x${totalCols}_${configSuffix}`;

            let yaml = `# Arena configuration for ${state.arena.generation} display\n`;
            if (isFull) {
                yaml += `# Full ${state.arena.generation} arena: ${state.arena.num_rows} rows, ${totalCols} columns, 360° coverage\n`;
            } else {
                const coverage = geom.azimuthCoverage.toFixed(0);
                yaml += `# Partial ${state.arena.generation} arena: ${state.arena.num_rows} rows, ${totalCols}-column grid, ${installedCols} columns installed (${coverage}° coverage)\n`;
            }
            yaml += `\nformat_version: "1.0"\n`;
            yaml += `name: "${defaultName}"\n`;
            yaml += `description: "${state.arena.generation} arena, ${state.arena.num_rows} rows × ${totalCols} columns`;
            if (!isFull) yaml += `, ${installedCols} columns installed`;
            yaml += `"\n\narena:\n`;
            yaml += `  generation: "${state.arena.generation}"\n`;
            yaml += `  num_rows: ${state.arena.num_rows}\n`;
            yaml += `  num_cols: ${totalCols}\n`;

            if (isFull) {
                yaml += `  columns_installed: null  # null = all columns installed\n`;
            } else {
                const panels = state.arena.columns_installed || [];
                yaml += `  columns_installed: [${panels.join(', ')}]  # 0-indexed column indices\n`;
            }

            yaml += `  orientation: "normal"\n`;
            yaml += `  column_order: "${state.arena.column_order}"\n`;
            yaml += `  angle_offset_deg: ${state.arena.angle_offset_deg}\n`;

            // Download
            const blob = new Blob([yaml], { type: 'text/yaml' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `${defaultName}.yaml`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        // Load config from file
        function loadConfigFromFile() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.yaml,.yml';

            input.addEventListener('change', async (e) => {
                const file = e.target.files[0];
                if (!file) return;

                try {
                    const text = await file.text();
                    const config = parseYAML(text);

                    if (config.arena) {
                        state.configSource = { type: 'file', name: file.name };
                        state.arena = { ...config.arena };
                        // Backward compatibility: accept old field name panels_installed
                        if (state.arena.panels_installed !== undefined && state.arena.columns_installed === undefined) {
                            state.arena.columns_installed = state.arena.panels_installed;
                            delete state.arena.panels_installed;
                        }
                        state.mode = 'view';
                        updateUIForViewMode();
                        updatePropertiesDisplay();
                        updateArena();
                    }
                } catch (err) {
                    alert('Error loading config: ' + err.message);
                }
            });

            input.click();
        }

        // Simple YAML parser
        function parseYAML(yamlText) {
            const config = {};
            let currentSection = config;

            const lines = yamlText.split('\n');
            for (const line of lines) {
                if (line.trim().startsWith('#') || line.trim() === '') continue;

                if (line.match(/^(\w+):$/)) {
                    const sectionName = line.match(/^(\w+):$/)[1];
                    config[sectionName] = {};
                    currentSection = config[sectionName];
                    continue;
                }

                const kvMatch = line.match(/^\s+(\w+):\s*(.+?)(?:\s*#.*)?$/);
                if (kvMatch) {
                    const key = kvMatch[1];
                    let value = kvMatch[2].trim();

                    if (value === 'null') {
                        currentSection[key] = null;
                    } else if (value.startsWith('[') && value.endsWith(']')) {
                        const arrayContent = value.slice(1, -1);
                        currentSection[key] = arrayContent.trim() === '' ? [] :
                            arrayContent.split(',').map(v => {
                                v = v.trim();
                                const num = parseFloat(v);
                                return isNaN(num) ? v.replace(/^"|"$/g, '') : num;
                            });
                    } else if (value.startsWith('"') && value.endsWith('"')) {
                        currentSection[key] = value.slice(1, -1);
                    } else if (!isNaN(parseFloat(value))) {
                        currentSection[key] = parseFloat(value);
                    } else {
                        currentSection[key] = value;
                    }
                }
            }

            return config;
        }

        // Export PDF
        function exportPDF() {
            const geom = calculateGeometry();
            const unitScale = state.units === 'mm' ? 25.4 : 1;
            const unitLabel = state.units === 'mm' ? 'mm' : 'inches';

            const svgClone = canvas.cloneNode(true);
            svgClone.setAttribute('width', '600');
            svgClone.setAttribute('height', '600');
            svgClone.style.background = 'white';

            const printWindow = window.open('', '_blank');
            printWindow.document.write(`
                <!DOCTYPE html>
                <html>
                <head>
                    <title>${state.arena.generation} Arena Layout</title>
                    <style>
                        body { font-family: Arial, sans-serif; padding: 20px; max-width: 800px; margin: 0 auto; }
                        h1 { font-size: 18px; margin-bottom: 5px; }
                        .info { font-size: 12px; color: #666; margin-bottom: 20px; }
                        svg { display: block; margin: 0 auto; border: 1px solid #ccc; }
                        @media print { body { padding: 0; } }
                    </style>
                </head>
                <body>
                    <h1>${state.arena.generation} (${state.arena.num_rows}×${state.arena.num_cols}) Arena Layout</h1>
                    <div class="info">
                        ${geom.azimuthCoverage.toFixed(1)}° coverage |
                        Radius: ${(geom.cRadius * unitScale).toFixed(1)} ${unitLabel} |
                        Resolution: ${geom.degsPerPixel.toFixed(2)}°/pixel
                    </div>
                    ${svgClone.outerHTML}
                    <script>window.print();<\/script>
                </body>
                </html>
            `);
            printWindow.document.close();
        }

        // Setup event listeners
        function setupEventListeners() {
            // Config dropdown
            document.getElementById('config-select').addEventListener('change', (e) => {
                loadStandardConfig(e.target.value);
            });

            // Load from file
            document.getElementById('load-file').addEventListener('click', loadConfigFromFile);

            // Create new
            document.getElementById('create-new').addEventListener('click', () => {
                state.arena = {
                    generation: 'G6',
                    num_rows: 2,
                    num_cols: 10,
                    columns_installed: null,
                    column_order: 'cw',
                    angle_offset_deg: 0
                };
                state.configSource = { type: 'custom', name: null };
                updateUIForCreateMode();
                updateArena();
            });

            // Clone as new
            document.getElementById('clone-config').addEventListener('click', () => {
                state.configSource = { type: 'custom', name: null };
                updateUIForCreateMode();
                updateArena();
            });

            // Cancel create
            document.getElementById('cancel-create').addEventListener('click', () => {
                loadStandardConfig(document.getElementById('config-select').value);
            });

            // Save config
            document.getElementById('save-config').addEventListener('click', exportConfig);

            // Generation tabs (create mode)
            document.querySelectorAll('.gen-tab').forEach(tab => {
                tab.addEventListener('click', () => {
                    if (state.mode !== 'create') return;
                    document.querySelectorAll('.gen-tab').forEach(t => t.classList.remove('active'));
                    tab.classList.add('active');
                    state.arena.generation = tab.dataset.gen;
                    resetPanels();
                    updateArena();
                });
            });

            // Column count (create mode)
            document.getElementById('cols-dec').addEventListener('click', () => {
                if (state.mode !== 'create' || state.arena.num_cols <= 4) return;
                state.arena.num_cols--;
                document.getElementById('num-cols').value = state.arena.num_cols;
                resetPanels();
                updateArena();
            });

            document.getElementById('cols-inc').addEventListener('click', () => {
                if (state.mode !== 'create' || state.arena.num_cols >= 36) return;
                state.arena.num_cols++;
                document.getElementById('num-cols').value = state.arena.num_cols;
                resetPanels();
                updateArena();
            });

            document.getElementById('num-cols').addEventListener('change', (e) => {
                if (state.mode !== 'create') return;
                const val = parseInt(e.target.value);
                if (val >= 4 && val <= 36) {
                    state.arena.num_cols = val;
                    resetPanels();
                    updateArena();
                } else {
                    e.target.value = state.arena.num_cols;
                }
            });

            // Row count (create mode)
            document.getElementById('rows-dec').addEventListener('click', () => {
                if (state.mode !== 'create' || state.arena.num_rows <= 1) return;
                state.arena.num_rows--;
                document.getElementById('num-rows').value = state.arena.num_rows;
                updateArena();
            });

            document.getElementById('rows-inc').addEventListener('click', () => {
                if (state.mode !== 'create' || state.arena.num_rows >= 6) return;
                state.arena.num_rows++;
                document.getElementById('num-rows').value = state.arena.num_rows;
                updateArena();
            });

            document.getElementById('num-rows').addEventListener('change', (e) => {
                if (state.mode !== 'create') return;
                const val = parseInt(e.target.value);
                if (val >= 1 && val <= 6) {
                    state.arena.num_rows = val;
                    updateArena();
                } else {
                    e.target.value = state.arena.num_rows;
                }
            });

            // Column order (create mode)
            document.querySelectorAll('[data-order]').forEach(btn => {
                btn.addEventListener('click', () => {
                    if (state.mode !== 'create') return;
                    document.querySelectorAll('[data-order]').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    state.arena.column_order = btn.dataset.order;
                    updateArena();
                });
            });

            // Angle offset (create mode)
            document.getElementById('offset-dec').addEventListener('click', () => {
                if (state.mode !== 'create') return;
                state.arena.angle_offset_deg = Math.max(-180, state.arena.angle_offset_deg - 5);
                document.getElementById('angle-offset').value = state.arena.angle_offset_deg;
                updateArena();
            });

            document.getElementById('offset-inc').addEventListener('click', () => {
                if (state.mode !== 'create') return;
                state.arena.angle_offset_deg = Math.min(180, state.arena.angle_offset_deg + 5);
                document.getElementById('angle-offset').value = state.arena.angle_offset_deg;
                updateArena();
            });

            document.getElementById('angle-offset').addEventListener('change', (e) => {
                if (state.mode !== 'create') return;
                const val = parseFloat(e.target.value);
                if (val >= -180 && val <= 180) {
                    state.arena.angle_offset_deg = val;
                    updateArena();
                } else {
                    e.target.value = state.arena.angle_offset_deg;
                }
            });

            // Column numbers toggle
            document.getElementById('toggle-col-nums').addEventListener('click', function() {
                this.classList.toggle('active');
                state.showColumnNumbers = this.classList.contains('active');
                updateArena();
            });

            // Unit toggle
            document.querySelectorAll('[data-unit]').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('[data-unit]').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    state.units = btn.dataset.unit;
                    updateArena();
                });
            });

            // View in 3D
            document.getElementById('view-3d').addEventListener('click', () => {
                const params = new URLSearchParams();
                if (state.configSource.type === 'standard') {
                    params.set('config', state.configSource.name);
                } else {
                    params.set('gen', state.arena.generation);
                    params.set('cols', state.arena.num_cols);
                    params.set('rows', state.arena.num_rows);
                    if (state.arena.columns_installed) {
                        params.set('active', state.arena.columns_installed.join(','));
                    }
                    params.set('order', state.arena.column_order);
                    params.set('offset', state.arena.angle_offset_deg);
                }
                window.location.href = 'arena_3d_viewer.html?' + params.toString();
            });

            // Export PDF
            document.getElementById('export-pdf').addEventListener('click', exportPDF);
        }

        // Initialize
        document.addEventListener('DOMContentLoaded', () => {
            populateConfigDropdown();
            setupEventListeners();
            loadStandardConfig('G6_2x10');
        });
    </script>
</body>
</html>
