<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Arena Layout Editor - PanelDisplayTools</title>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700&family=IBM+Plex+Mono:wght@400;600&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        :root {
            --bg: #0f1419;
            --surface: #1a1f26;
            --border: #2d3640;
            --text: #e6edf3;
            --text-dim: #8b949e;
            --accent: #00e676;
            --hover: #00c853;
            --panel-green: #00e676;
            --panel-active: #00c853;
            --panel-inactive: #3d4450;
            --panel-inactive-dim: #2a2e35;
        }

        body {
            font-family: 'IBM Plex Mono', monospace;
            background: var(--bg);
            color: var(--text);
            min-height: 100vh;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 1.5rem;
        }

        header {
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 2px solid var(--border);
        }

        .nav-link {
            display: inline-block;
            color: var(--text-dim);
            text-decoration: none;
            margin-bottom: 0.75rem;
            font-size: 0.9rem;
            transition: color 0.2s;
        }

        .nav-link:hover { color: var(--accent); }

        h1 {
            font-family: 'JetBrains Mono', monospace;
            font-size: 1.75rem;
            font-weight: 700;
            color: var(--accent);
        }

        .subtitle {
            color: var(--text-dim);
            font-size: 0.85rem;
            margin-top: 0.3rem;
        }

        /* Main Layout */
        .main-content {
            display: grid;
            grid-template-columns: 280px 1fr 280px;
            gap: 1.5rem;
        }

        @media (max-width: 1100px) {
            .main-content {
                grid-template-columns: 1fr;
            }
        }

        /* Panels */
        .panel {
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 1.25rem;
        }

        .panel h2 {
            font-family: 'JetBrains Mono', monospace;
            font-size: 1rem;
            color: var(--accent);
            margin-bottom: 1rem;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid var(--border);
        }

        /* Controls */
        .control-group {
            margin-bottom: 1.25rem;
        }

        .control-group label {
            display: block;
            font-size: 0.8rem;
            color: var(--text-dim);
            margin-bottom: 0.4rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        /* Generation Tabs */
        .gen-tabs {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
        }

        .gen-tab {
            padding: 0.5rem 1rem;
            background: var(--bg);
            border: 1px solid var(--border);
            border-radius: 4px;
            color: var(--text-dim);
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.85rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .gen-tab:hover {
            border-color: var(--accent);
            color: var(--text);
        }

        .gen-tab.active {
            background: var(--accent);
            border-color: var(--accent);
            color: var(--bg);
            font-weight: 700;
        }

        /* Number Input */
        .number-input {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .number-input button {
            width: 36px;
            height: 36px;
            background: var(--bg);
            border: 1px solid var(--border);
            border-radius: 4px;
            color: var(--text);
            font-size: 1.2rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .number-input button:hover {
            border-color: var(--accent);
            color: var(--accent);
        }

        .number-input input {
            width: 60px;
            height: 36px;
            background: var(--bg);
            border: 1px solid var(--border);
            border-radius: 4px;
            color: var(--text);
            font-family: 'JetBrains Mono', monospace;
            font-size: 1rem;
            text-align: center;
        }

        /* Unit Toggle */
        .unit-toggle {
            display: flex;
            background: var(--bg);
            border: 1px solid var(--border);
            border-radius: 4px;
            overflow: hidden;
        }

        .unit-toggle button {
            flex: 1;
            padding: 0.5rem;
            background: transparent;
            border: none;
            color: var(--text-dim);
            font-family: 'IBM Plex Mono', monospace;
            font-size: 0.85rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .unit-toggle button.active {
            background: var(--accent);
            color: var(--bg);
            font-weight: 600;
        }

        /* Canvas Container */
        .canvas-container {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        #arena-canvas {
            background: white;
            border-radius: 8px;
            max-width: 100%;
        }

        .canvas-info {
            margin-top: 0.75rem;
            font-size: 0.85rem;
            color: var(--text-dim);
            text-align: center;
        }

        /* Resolution Box */
        .resolution-box {
            background: rgba(0, 230, 118, 0.1);
            border: 2px solid var(--accent);
            border-radius: 8px;
            padding: 1rem;
            text-align: center;
            margin-bottom: 1.25rem;
        }

        .resolution-box .label {
            font-size: 0.75rem;
            color: var(--accent);
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 0.25rem;
        }

        .resolution-box .sublabel {
            font-size: 0.7rem;
            color: var(--text-dim);
            margin-bottom: 0.5rem;
        }

        .resolution-box .value {
            font-family: 'JetBrains Mono', monospace;
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--accent);
        }

        .resolution-box .pixels {
            font-size: 0.85rem;
            color: var(--text);
            margin-top: 0.25rem;
        }

        /* Metrics */
        .metric {
            display: flex;
            justify-content: space-between;
            padding: 0.5rem 0;
            border-bottom: 1px solid var(--border);
            font-size: 0.85rem;
        }

        .metric:last-child {
            border-bottom: none;
        }

        .metric .label {
            color: var(--text-dim);
        }

        .metric .value {
            color: var(--text);
            font-family: 'JetBrains Mono', monospace;
        }

        /* Export Buttons */
        .export-btn {
            width: 100%;
            padding: 0.75rem;
            background: var(--accent);
            border: none;
            border-radius: 6px;
            color: var(--bg);
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.9rem;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.2s;
            margin-top: 0.75rem;
        }

        .export-btn:hover {
            background: var(--hover);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 230, 118, 0.3);
        }

        .export-btn.secondary {
            background: var(--surface);
            border: 1px solid var(--accent);
            color: var(--accent);
        }

        .export-btn.secondary:hover {
            background: rgba(0, 230, 118, 0.1);
        }

        .export-btn.disabled {
            opacity: 0.4;
            cursor: not-allowed;
            pointer-events: none;
        }

        /* Custom Panel Modal */
        .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }

        .modal-overlay.active {
            display: flex;
        }

        .modal {
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 2rem;
            max-width: 400px;
            width: 90%;
        }

        .modal h3 {
            font-family: 'JetBrains Mono', monospace;
            color: var(--accent);
            margin-bottom: 1.5rem;
        }

        .modal .control-group {
            margin-bottom: 1rem;
        }

        .modal input[type="number"],
        .modal input[type="text"] {
            width: 100%;
            padding: 0.5rem;
            background: var(--bg);
            border: 1px solid var(--border);
            border-radius: 4px;
            color: var(--text);
            font-family: 'JetBrains Mono', monospace;
        }

        .modal-buttons {
            display: flex;
            gap: 0.5rem;
            margin-top: 1.5rem;
        }

        .modal-buttons button {
            flex: 1;
            padding: 0.6rem;
            border-radius: 6px;
            font-family: 'JetBrains Mono', monospace;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        .modal-buttons .cancel-btn {
            background: var(--bg);
            border: 1px solid var(--border);
            color: var(--text-dim);
        }

        .modal-buttons .apply-btn {
            background: var(--accent);
            border: none;
            color: var(--bg);
        }

        /* Validation Status */
        .validation-status {
            margin-top: 1rem;
            padding: 0.5rem;
            border-radius: 4px;
            font-size: 0.75rem;
            text-align: center;
            display: none;
        }

        .validation-status.pass {
            display: block;
            background: rgba(0, 230, 118, 0.15);
            color: var(--accent);
            border: 1px solid var(--accent);
        }

        .validation-status.fail {
            display: block;
            background: rgba(255, 82, 82, 0.15);
            color: #ff5252;
            border: 1px solid #ff5252;
        }

        /* Footer */
        footer {
            text-align: center;
            margin-top: 2rem;
            padding-top: 1.5rem;
            border-top: 2px solid var(--border);
            color: var(--text-dim);
            font-size: 0.8rem;
        }

        footer a {
            color: var(--accent);
            text-decoration: none;
        }

        footer a:hover { color: var(--hover); }

        footer .version {
            margin-top: 0.5rem;
            font-size: 0.75rem;
            color: var(--text-dim);
            opacity: 0.7;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <a href="index.html" class="nav-link">← Back to Tools</a>
            <h1>Arena Layout Editor</h1>
            <p class="subtitle">Configure arena geometry and panel layout. Click panels to toggle.</p>
        </header>

        <div class="main-content">
            <!-- Left Panel: Controls -->
            <div class="panel">
                <h2>Configuration</h2>

                <div class="control-group">
                    <label>Panel Generation</label>
                    <div class="gen-tabs">
                        <button class="gen-tab" data-gen="G3">G3</button>
                        <button class="gen-tab" data-gen="G4">G4</button>
                        <button class="gen-tab" data-gen="G4.1">G4.1</button>
                        <button class="gen-tab active" data-gen="G6">G6</button>
                        <button class="gen-tab" data-gen="Custom">Custom</button>
                    </div>
                </div>

                <div class="control-group">
                    <label>Number of Panels</label>
                    <div class="number-input">
                        <button id="panels-dec">−</button>
                        <input type="number" id="num-panels" value="10" min="4" max="36">
                        <button id="panels-inc">+</button>
                    </div>
                </div>

                <div class="control-group">
                    <label>Angle Offset (degrees)</label>
                    <div class="number-input">
                        <button id="offset-dec">−</button>
                        <input type="number" id="angle-offset" value="0" min="-180" max="180" step="5">
                        <button id="offset-inc">+</button>
                    </div>
                </div>

                <div class="control-group">
                    <label>Display Units</label>
                    <div class="unit-toggle">
                        <button class="active" data-unit="inches">Inches</button>
                        <button data-unit="mm">mm</button>
                    </div>
                </div>

                <div class="control-group">
                    <label>Panels Installed</label>
                    <div class="metric">
                        <span class="label">Active</span>
                        <span class="value" id="active-panels">10 / 10</span>
                    </div>
                </div>

                <button class="export-btn" id="view-3d">View in 3D</button>
                <button class="export-btn secondary" id="export-pdf">Export PDF</button>
                <button class="export-btn secondary" id="export-data">Export Data (JSON)</button>
                <div style="font-size: 0.7rem; color: var(--text-dim); margin-top: 0.5rem; text-align: center; display: none;" id="custom-3d-warning">3D view not available for custom panels</div>

                <div class="validation-status" id="validation-status"></div>
            </div>

            <!-- Center: Canvas -->
            <div class="panel canvas-container">
                <svg id="arena-canvas" width="500" height="500" viewBox="-6 -6 12 12"></svg>
                <div class="canvas-info">
                    <span id="title-info">10 of 10 Panel (G6) Arena Layout</span>
                </div>
            </div>

            <!-- Right Panel: Metrics -->
            <div class="panel">
                <h2>Arena Metrics</h2>

                <div class="resolution-box">
                    <div class="label">Azimuthal Resolution</div>
                    <div class="sublabel">(from center)</div>
                    <div class="value" id="deg-per-pixel">1.80°</div>
                    <div class="pixels"><span id="azimuthal-pixels">200</span> pixels around</div>
                </div>

                <div class="metric">
                    <span class="label">Panel Type</span>
                    <span class="value" id="panel-type">G6 (45.4 mm)</span>
                </div>

                <div class="metric">
                    <span class="label">Inner Radius</span>
                    <span class="value" id="inner-radius">2.75 in</span>
                </div>

                <div class="metric">
                    <span class="label">Outer Radius</span>
                    <span class="value" id="outer-radius">2.89 in</span>
                </div>

                <div class="metric">
                    <span class="label">Azimuth Coverage</span>
                    <span class="value" id="azimuth-coverage">360.0°</span>
                </div>

                <div class="metric">
                    <span class="label">Azimuth Gap</span>
                    <span class="value" id="azimuth-gap">0.0°</span>
                </div>
            </div>
        </div>

        <footer>
            <p><a href="https://github.com/reiserlab/webDisplayTools" target="_blank">Reiser Lab</a> | PanelDisplayTools</p>
            <p class="version">Arena Editor v2 | 2026-01-16</p>
        </footer>
    </div>

    <!-- Custom Panel Modal -->
    <div class="modal-overlay" id="custom-modal">
        <div class="modal">
            <h3>Custom Panel Configuration</h3>
            <div class="control-group">
                <label>Panel Width (mm)</label>
                <input type="number" id="custom-width" value="40" min="10" max="100" step="0.1">
            </div>
            <div class="control-group">
                <label>Panel Depth (mm)</label>
                <input type="number" id="custom-depth" value="6" min="1" max="50" step="0.1">
            </div>
            <div class="control-group">
                <label>Pixels per Panel</label>
                <input type="number" id="custom-pixels" value="16" min="1" max="64">
            </div>
            <div class="control-group">
                <label>Number of Pins</label>
                <input type="number" id="custom-pins" value="10" min="1" max="30">
            </div>
            <div class="control-group">
                <label>Pin Distance from Front (mm)</label>
                <input type="number" id="custom-pin-dist" value="4.57" min="0" max="20" step="0.01">
            </div>
            <div class="modal-buttons">
                <button class="cancel-btn" id="custom-cancel">Cancel</button>
                <button class="apply-btn" id="custom-apply">Apply</button>
            </div>
        </div>
    </div>

    <script>
        // Panel specifications (from MATLAB)
        const PANEL_SPECS = {
            'G3': {
                panel_width_mm: 32,
                panel_depth_mm: 18,
                pixels_per_panel: 8,
                num_pins: 8,
                pin_dist_mm: 15.24,
                pin_config: 'single'
            },
            'G4': {
                panel_width_mm: 40.45,
                panel_depth_mm: 18,
                pixels_per_panel: 16,
                num_pins: 15,
                pin_dist_mm: 13,
                pin_config: 'single'
            },
            'G4.1': {
                panel_width_mm: 40,
                panel_depth_mm: 6.35,
                pixels_per_panel: 16,
                num_pins: 15,
                pin_dist_mm: 4.57,
                pin_config: 'single'
            },

            'G6': {
                panel_width_mm: 45.4,
                panel_depth_mm: 3.45,
                pixels_per_panel: 20,
                num_pins: 10,
                pin_dist_mm: 4.57,
                pin_config: 'dual',
                header_separation_mm: 30.8
            },
            'Custom': {
                panel_width_mm: 40,
                panel_depth_mm: 6,
                pixels_per_panel: 16,
                num_pins: 10,
                pin_dist_mm: 4.57,
                pin_config: 'single'
            }
        };

        // State - default to G6 with 10 panels
        let state = {
            panelType: 'G6',
            numPanels: 10,
            panelsInstalled: new Set([...Array(10).keys()].map(i => i + 1)),
            units: 'inches',
            angleOffset: 0
        };

        // DOM elements
        const canvas = document.getElementById('arena-canvas');
        const genTabs = document.querySelectorAll('.gen-tab');
        const unitBtns = document.querySelectorAll('.unit-toggle button');
        const numPanelsInput = document.getElementById('num-panels');

        // Initialize
        document.addEventListener('DOMContentLoaded', () => {
            setupEventListeners();
            updateArena();
        });

        function setupEventListeners() {
            // Generation tabs
            genTabs.forEach(tab => {
                tab.addEventListener('click', () => {
                    if (tab.dataset.gen === 'Custom') {
                        showCustomModal();
                        return;
                    }
                    genTabs.forEach(t => t.classList.remove('active'));
                    tab.classList.add('active');
                    state.panelType = tab.dataset.gen;
                    resetPanels();
                    updateArena();
                });
            });

            // Unit toggle
            unitBtns.forEach(btn => {
                btn.addEventListener('click', () => {
                    unitBtns.forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    state.units = btn.dataset.unit;
                    updateArena();
                });
            });

            // Panel count
            document.getElementById('panels-dec').addEventListener('click', () => {
                if (state.numPanels > 4) {
                    state.numPanels--;
                    numPanelsInput.value = state.numPanels;
                    resetPanels();
                    updateArena();
                }
            });

            document.getElementById('panels-inc').addEventListener('click', () => {
                if (state.numPanels < 36) {
                    state.numPanels++;
                    numPanelsInput.value = state.numPanels;
                    resetPanels();
                    updateArena();
                }
            });

            numPanelsInput.addEventListener('change', () => {
                let val = parseInt(numPanelsInput.value);
                if (val >= 4 && val <= 36) {
                    state.numPanels = val;
                    resetPanels();
                    updateArena();
                } else {
                    numPanelsInput.value = state.numPanels;
                }
            });

            // Angle offset controls
            const angleOffsetInput = document.getElementById('angle-offset');
            document.getElementById('offset-dec').addEventListener('click', () => {
                state.angleOffset = Math.max(-180, state.angleOffset - 5);
                angleOffsetInput.value = state.angleOffset;
                updateArena();
            });

            document.getElementById('offset-inc').addEventListener('click', () => {
                state.angleOffset = Math.min(180, state.angleOffset + 5);
                angleOffsetInput.value = state.angleOffset;
                updateArena();
            });

            angleOffsetInput.addEventListener('change', () => {
                let val = parseFloat(angleOffsetInput.value);
                if (val >= -180 && val <= 180) {
                    state.angleOffset = val;
                    updateArena();
                } else {
                    angleOffsetInput.value = state.angleOffset;
                }
            });

            // Export buttons
            document.getElementById('export-pdf').addEventListener('click', exportPDF);
            document.getElementById('export-data').addEventListener('click', exportData);

            // View in 3D - pass current state as URL parameters
            document.getElementById('view-3d').addEventListener('click', () => {
                const params = new URLSearchParams();
                params.set('gen', state.panelType);
                params.set('cols', state.numPanels);
                // Convert 1-based panelsInstalled to 0-based indices for 3D viewer
                const activeIndices = Array.from(state.panelsInstalled).map(i => i - 1).sort((a, b) => a - b);
                // Only pass active if not all panels are installed
                if (activeIndices.length < state.numPanels) {
                    params.set('active', activeIndices.join(','));
                }
                window.location.href = 'arena_3d_viewer.html?' + params.toString();
            });

            // Custom panel modal
            document.getElementById('custom-cancel').addEventListener('click', hideCustomModal);
            document.getElementById('custom-apply').addEventListener('click', applyCustomConfig);
            document.getElementById('custom-modal').addEventListener('click', (e) => {
                if (e.target.id === 'custom-modal') hideCustomModal();
            });
        }

        function showCustomModal() {
            // Pre-populate with current Custom values
            document.getElementById('custom-width').value = PANEL_SPECS.Custom.panel_width_mm;
            document.getElementById('custom-depth').value = PANEL_SPECS.Custom.panel_depth_mm;
            document.getElementById('custom-pixels').value = PANEL_SPECS.Custom.pixels_per_panel;
            document.getElementById('custom-pins').value = PANEL_SPECS.Custom.num_pins;
            document.getElementById('custom-pin-dist').value = PANEL_SPECS.Custom.pin_dist_mm;
            document.getElementById('custom-modal').classList.add('active');
        }

        function hideCustomModal() {
            document.getElementById('custom-modal').classList.remove('active');
        }

        function applyCustomConfig() {
            PANEL_SPECS.Custom.panel_width_mm = parseFloat(document.getElementById('custom-width').value);
            PANEL_SPECS.Custom.panel_depth_mm = parseFloat(document.getElementById('custom-depth').value);
            PANEL_SPECS.Custom.pixels_per_panel = parseInt(document.getElementById('custom-pixels').value);
            PANEL_SPECS.Custom.num_pins = parseInt(document.getElementById('custom-pins').value);
            PANEL_SPECS.Custom.pin_dist_mm = parseFloat(document.getElementById('custom-pin-dist').value);

            genTabs.forEach(t => t.classList.remove('active'));
            document.querySelector('[data-gen="Custom"]').classList.add('active');
            state.panelType = 'Custom';
            resetPanels();
            updateArena();
            hideCustomModal();
        }

        function resetPanels() {
            state.panelsInstalled = new Set([...Array(state.numPanels).keys()].map(i => i + 1));
        }

        function togglePanel(panelIndex) {
            if (state.panelsInstalled.has(panelIndex)) {
                state.panelsInstalled.delete(panelIndex);
            } else {
                state.panelsInstalled.add(panelIndex);
            }
            updateArena();
        }

        function calculateGeometry() {
            const specs = PANEL_SPECS[state.panelType];
            const numPanels = state.numPanels;

            // Convert to working units (inches internally, like MATLAB)
            const panelWidth = specs.panel_width_mm / 25.4;
            const panelDepth = specs.panel_depth_mm / 25.4;
            const pinDist = specs.pin_dist_mm / 25.4;
            const angleOffsetRad = (state.angleOffset * Math.PI) / 180;

            // Calculate geometry
            const alpha = (2 * Math.PI) / numPanels;
            const cRadius = panelWidth / (Math.tan(alpha / 2)) / 2;
            const backCRadius = cRadius + panelDepth;

            // Resolution
            const degsPerPixel = 360 / (numPanels * specs.pixels_per_panel);
            const azimuthalPixels = numPanels * specs.pixels_per_panel;

            // Coverage
            const azimuthCoverage = 360 * (state.panelsInstalled.size / numPanels);
            const azimuthGap = 360 - azimuthCoverage;

            return {
                specs,
                panelWidth,
                panelDepth,
                pinDist,
                alpha,
                cRadius,
                backCRadius,
                degsPerPixel,
                azimuthalPixels,
                azimuthCoverage,
                azimuthGap,
                angleOffsetRad
            };
        }

        // Calculate all pin coordinates for export
        function calculatePinCoordinates(geom) {
            const { specs, cRadius, alpha, angleOffsetRad } = geom;
            const pinDist = specs.pin_dist_mm / 25.4;
            const pinSpacing = 2.54 / 25.4; // 0.1 inch

            const panelPins = [];

            for (let j = 1; j <= state.numPanels; j++) {
                if (!state.panelsInstalled.has(j)) continue;

                const alphaJ = (j - 1) * alpha + angleOffsetRad;
                const pAngle = alphaJ + Math.PI / 2;

                const pcx = (cRadius + pinDist) * Math.cos(alphaJ);
                const pcy = (cRadius + pinDist) * Math.sin(alphaJ);

                const panelData = {
                    panel_index: j,
                    angle_deg: ((j - 1) * (360 / state.numPanels) + state.angleOffset) % 360,
                    pins: []
                };

                if (specs.pin_config === 'dual' && specs.header_separation_mm) {
                    // Dual headers (G6)
                    const headerSep = specs.header_separation_mm / 25.4;
                    const pinsPerHeader = 5;

                    // Left header
                    const lcx = pcx + (-headerSep / 2) * Math.cos(pAngle);
                    const lcy = pcy + (-headerSep / 2) * Math.sin(pAngle);
                    panelData.pins.push(...getPinRowCoords(lcx, lcy, pAngle, pinsPerHeader, pinSpacing, 'left'));

                    // Right header
                    const rcx = pcx + (headerSep / 2) * Math.cos(pAngle);
                    const rcy = pcy + (headerSep / 2) * Math.sin(pAngle);
                    panelData.pins.push(...getPinRowCoords(rcx, rcy, pAngle, pinsPerHeader, pinSpacing, 'right'));
                } else {
                    // Single header
                    panelData.pins = getPinRowCoords(pcx, pcy, pAngle, specs.num_pins, pinSpacing, 'single');
                }

                panelPins.push(panelData);
            }

            return panelPins;
        }

        function getPinRowCoords(cx, cy, pAngle, numPins, pinSpacing, header) {
            const pins = [];
            const pinWidth = (numPins - 1) * pinSpacing;
            let px = cx - (pinWidth / 2) * Math.cos(pAngle);
            let py = cy - (pinWidth / 2) * Math.sin(pAngle);

            for (let i = 0; i < numPins; i++) {
                pins.push({
                    header: header,
                    pin_index: i + 1,
                    x_inches: px,
                    y_inches: py,
                    x_mm: px * 25.4,
                    y_mm: py * 25.4
                });
                px += pinSpacing * Math.cos(pAngle);
                py += pinSpacing * Math.sin(pAngle);
            }
            return pins;
        }

        function updateArena() {
            const geom = calculateGeometry();
            const { specs, panelWidth, panelDepth, cRadius, backCRadius, alpha, angleOffsetRad } = geom;

            // Clear canvas
            canvas.innerHTML = '';

            // Set viewBox based on arena size
            const viewSize = backCRadius * 1.5;
            canvas.setAttribute('viewBox', `${-viewSize} ${-viewSize} ${viewSize * 2} ${viewSize * 2}`);

            // Draw axes
            const axisLen = viewSize * 0.95;
            addLine(-axisLen, 0, axisLen, 0, '#ccc', 0.015);
            addLine(0, -axisLen, 0, axisLen, '#ccc', 0.015);

            // Draw inner radius dimension line (on right side)
            drawDimensionLine(geom, viewSize);

            // Draw panels
            for (let j = 1; j <= state.numPanels; j++) {
                const alphaJ = (j - 1) * alpha + angleOffsetRad;
                const pAngle = alphaJ + Math.PI / 2;
                const isInstalled = state.panelsInstalled.has(j);

                // Panel center
                const cx = cRadius * Math.cos(alphaJ);
                const cy = cRadius * Math.sin(alphaJ);

                // Front vertices
                const fx1 = cx - (panelWidth / 2) * Math.cos(pAngle);
                const fy1 = cy - (panelWidth / 2) * Math.sin(pAngle);
                const fx2 = cx + (panelWidth / 2) * Math.cos(pAngle);
                const fy2 = cy + (panelWidth / 2) * Math.sin(pAngle);

                // Back center and vertices
                const bcx = backCRadius * Math.cos(alphaJ);
                const bcy = backCRadius * Math.sin(alphaJ);
                const bx1 = bcx - (panelWidth / 2) * Math.cos(pAngle);
                const by1 = bcy - (panelWidth / 2) * Math.sin(pAngle);
                const bx2 = bcx + (panelWidth / 2) * Math.cos(pAngle);
                const by2 = bcy + (panelWidth / 2) * Math.sin(pAngle);

                // Draw panel (clickable group)
                const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                g.style.cursor = 'pointer';
                g.addEventListener('click', () => togglePanel(j));

                // Colors based on installed state (dimmer for inactive)
                const frontColor = isInstalled ? '#00c853' : '#333';
                const edgeColor = isInstalled ? '#333' : '#222';
                const frontWidth = isInstalled ? 0.08 : 0.04;
                const edgeWidth = isInstalled ? 0.04 : 0.02;
                const opacity = isInstalled ? 1 : 0.4;

                g.setAttribute('opacity', opacity);

                // Front edge (green if installed)
                const frontLine = createLine(fx1, -fy1, fx2, -fy2, frontColor, frontWidth);
                g.appendChild(frontLine);

                // Back edge
                const backLine = createLine(bx1, -by1, bx2, -by2, edgeColor, edgeWidth);
                g.appendChild(backLine);

                // Side edges
                g.appendChild(createLine(bx1, -by1, fx1, -fy1, edgeColor, edgeWidth));
                g.appendChild(createLine(bx2, -by2, fx2, -fy2, edgeColor, edgeWidth));

                // Draw pins if installed
                if (isInstalled) {
                    drawPins(g, geom, alphaJ, pAngle);
                }

                canvas.appendChild(g);
            }

            // Update metrics display
            updateMetrics(geom);
        }

        function drawDimensionLine(geom, viewSize) {
            const { cRadius } = geom;
            const unitScale = state.units === 'mm' ? 25.4 : 1;
            const unitLabel = state.units === 'mm' ? 'mm' : 'in';
            const radiusValue = (cRadius * unitScale).toFixed(2);

            // Draw dimension line along positive X axis
            const lineY = 0;
            const tickSize = viewSize * 0.03;
            const dimColor = '#666';
            const strokeWidth = 0.02;

            // Main dimension line from origin to inner radius
            addLine(0, lineY, cRadius, lineY, dimColor, strokeWidth);

            // Tick marks at ends
            addLine(0, lineY - tickSize, 0, lineY + tickSize, dimColor, strokeWidth);
            addLine(cRadius, lineY - tickSize, cRadius, lineY + tickSize, dimColor, strokeWidth);

            // Small arrows
            const arrowSize = viewSize * 0.025;
            // Arrow at radius end pointing right
            addLine(cRadius, lineY, cRadius - arrowSize, lineY - arrowSize * 0.5, dimColor, strokeWidth);
            addLine(cRadius, lineY, cRadius - arrowSize, lineY + arrowSize * 0.5, dimColor, strokeWidth);
            // Arrow at origin pointing left
            addLine(0, lineY, arrowSize, lineY - arrowSize * 0.5, dimColor, strokeWidth);
            addLine(0, lineY, arrowSize, lineY + arrowSize * 0.5, dimColor, strokeWidth);

            // Label
            const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            text.setAttribute('x', cRadius / 2);
            text.setAttribute('y', -viewSize * 0.06);
            text.setAttribute('text-anchor', 'middle');
            text.setAttribute('font-size', viewSize * 0.07);
            text.setAttribute('font-family', 'JetBrains Mono, monospace');
            text.setAttribute('fill', '#333');
            text.textContent = `r = ${radiusValue} ${unitLabel}`;
            canvas.appendChild(text);
        }

        function drawPins(g, geom, alphaJ, pAngle) {
            const { specs, cRadius } = geom;
            const pinDist = specs.pin_dist_mm / 25.4;
            const pinSpacing = 2.54 / 25.4; // 0.1 inch

            const pcx = (cRadius + pinDist) * Math.cos(alphaJ);
            const pcy = (cRadius + pinDist) * Math.sin(alphaJ);

            if (specs.pin_config === 'dual') {
                // Dual headers (G6)
                const headerSep = specs.header_separation_mm / 25.4;
                const pinsPerHeader = 5;
                const pinWidth = (pinsPerHeader - 1) * pinSpacing;

                // Left header
                const lcx = pcx + (-headerSep / 2) * Math.cos(pAngle);
                const lcy = pcy + (-headerSep / 2) * Math.sin(pAngle);
                drawPinRow(g, lcx, lcy, pAngle, pinsPerHeader, pinSpacing);

                // Right header
                const rcx = pcx + (headerSep / 2) * Math.cos(pAngle);
                const rcy = pcy + (headerSep / 2) * Math.sin(pAngle);
                drawPinRow(g, rcx, rcy, pAngle, pinsPerHeader, pinSpacing);
            } else {
                // Single header
                drawPinRow(g, pcx, pcy, pAngle, specs.num_pins, pinSpacing);
            }
        }

        function drawPinRow(g, cx, cy, pAngle, numPins, pinSpacing) {
            const pinWidth = (numPins - 1) * pinSpacing;
            let px = cx - (pinWidth / 2) * Math.cos(pAngle);
            let py = cy - (pinWidth / 2) * Math.sin(pAngle);

            for (let i = 0; i < numPins; i++) {
                const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                circle.setAttribute('cx', px);
                circle.setAttribute('cy', -py);
                circle.setAttribute('r', 0.03);
                circle.setAttribute('fill', '#333');
                g.appendChild(circle);

                px += pinSpacing * Math.cos(pAngle);
                py += pinSpacing * Math.sin(pAngle);
            }
        }

        function createLine(x1, y1, x2, y2, color, width) {
            const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            line.setAttribute('x1', x1);
            line.setAttribute('y1', y1);
            line.setAttribute('x2', x2);
            line.setAttribute('y2', y2);
            line.setAttribute('stroke', color);
            line.setAttribute('stroke-width', width);
            line.setAttribute('stroke-linecap', 'round');
            return line;
        }

        function addLine(x1, y1, x2, y2, color, width) {
            canvas.appendChild(createLine(x1, y1, x2, y2, color, width));
        }

        function updateMetrics(geom) {
            const { specs, cRadius, backCRadius, degsPerPixel, azimuthalPixels, azimuthCoverage, azimuthGap } = geom;

            // Unit conversion
            const unitScale = state.units === 'mm' ? 25.4 : 1;
            const unitLabel = state.units === 'mm' ? 'mm' : 'in';

            // Update displays
            document.getElementById('deg-per-pixel').textContent = degsPerPixel.toFixed(2) + '°';
            document.getElementById('azimuthal-pixels').textContent = azimuthalPixels;
            document.getElementById('panel-type').textContent = `${state.panelType} (${specs.panel_width_mm.toFixed(1)} mm)`;
            document.getElementById('inner-radius').textContent = (cRadius * unitScale).toFixed(2) + ' ' + unitLabel;
            document.getElementById('outer-radius').textContent = (backCRadius * unitScale).toFixed(2) + ' ' + unitLabel;
            document.getElementById('azimuth-coverage').textContent = azimuthCoverage.toFixed(1) + '°';
            document.getElementById('azimuth-gap').textContent = azimuthGap.toFixed(1) + '°';
            document.getElementById('active-panels').textContent = `${state.panelsInstalled.size} / ${state.numPanels}`;
            document.getElementById('title-info').textContent =
                `${state.panelsInstalled.size} of ${state.numPanels} Panel (${state.panelType}) Arena Layout`;

            // Disable 3D view button for custom panels
            const view3dBtn = document.getElementById('view-3d');
            const customWarning = document.getElementById('custom-3d-warning');
            if (state.panelType === 'Custom') {
                view3dBtn.classList.add('disabled');
                customWarning.style.display = 'block';
            } else {
                view3dBtn.classList.remove('disabled');
                customWarning.style.display = 'none';
            }
        }

        function exportPDF() {
            // Create a new window with printable content
            const geom = calculateGeometry();
            const unitScale = state.units === 'mm' ? 25.4 : 1;
            const unitLabel = state.units === 'mm' ? 'mm' : 'inches';

            const svgClone = canvas.cloneNode(true);
            svgClone.setAttribute('width', '600');
            svgClone.setAttribute('height', '600');
            svgClone.style.background = 'white';

            const printWindow = window.open('', '_blank');
            printWindow.document.write(`
                <!DOCTYPE html>
                <html>
                <head>
                    <title>${state.panelsInstalled.size} of ${state.numPanels} Panel (${state.panelType}) Arena</title>
                    <style>
                        body {
                            font-family: Arial, sans-serif;
                            padding: 20px;
                            max-width: 800px;
                            margin: 0 auto;
                        }
                        h1 { font-size: 18px; margin-bottom: 5px; }
                        .info { font-size: 12px; color: #666; margin-bottom: 20px; }
                        svg { display: block; margin: 0 auto; border: 1px solid #ccc; }
                        .metrics {
                            display: grid;
                            grid-template-columns: 1fr 1fr;
                            gap: 10px;
                            margin-top: 20px;
                            font-size: 12px;
                        }
                        .metric {
                            padding: 8px;
                            background: #f5f5f5;
                            border-radius: 4px;
                        }
                        .resolution-box {
                            text-align: center;
                            padding: 15px;
                            background: #e8f5e9;
                            border: 2px solid #4caf50;
                            border-radius: 8px;
                            margin-bottom: 20px;
                        }
                        .resolution-box .label { font-size: 11px; color: #2e7d32; text-transform: uppercase; }
                        .resolution-box .value { font-size: 24px; font-weight: bold; color: #2e7d32; }
                        @media print { body { padding: 0; } }
                    </style>
                </head>
                <body>
                    <h1>${state.panelsInstalled.size} of ${state.numPanels} Panel (${state.panelType}) Arena Layout</h1>
                    <div class="info">
                        ${geom.azimuthCoverage.toFixed(1)}° azimuthal coverage, ${geom.azimuthGap.toFixed(1)}° gap |
                        Radius: ${(geom.cRadius * unitScale).toFixed(2)} ${unitLabel} | Dimensions in ${unitLabel}
                    </div>
                    <div class="resolution-box">
                        <div class="label">Azimuthal Resolution (from center)</div>
                        <div class="value">${geom.degsPerPixel.toFixed(2)}° / pixel</div>
                        <div>(${geom.azimuthalPixels} pixels around)</div>
                    </div>
                    ${svgClone.outerHTML}
                    <div class="metrics">
                        <div class="metric"><strong>Panel:</strong> ${state.panelType} (${geom.specs.panel_width_mm.toFixed(1)} mm)</div>
                        <div class="metric"><strong>Inner radius:</strong> ${(geom.cRadius * unitScale).toFixed(2)} ${unitLabel}</div>
                        <div class="metric"><strong>Outer radius:</strong> ${(geom.backCRadius * unitScale).toFixed(2)} ${unitLabel}</div>
                        <div class="metric"><strong>Pixels/panel:</strong> ${geom.specs.pixels_per_panel}×${geom.specs.pixels_per_panel}</div>
                    </div>
                    <script>window.print();<\/script>
                </body>
                </html>
            `);
            printWindow.document.close();
        }

        function exportData() {
            const geom = calculateGeometry();
            const pinCoords = calculatePinCoordinates(geom);

            const exportObj = {
                generated: new Date().toISOString(),
                source: 'Arena Layout Editor (Web)',
                configuration: {
                    panel_type: state.panelType,
                    num_panels: state.numPanels,
                    panels_installed: Array.from(state.panelsInstalled).sort((a, b) => a - b),
                    angle_offset_deg: state.angleOffset
                },
                panel_specs: {
                    panel_width_mm: geom.specs.panel_width_mm,
                    panel_depth_mm: geom.specs.panel_depth_mm,
                    pixels_per_panel: geom.specs.pixels_per_panel,
                    num_pins: geom.specs.num_pins,
                    pin_dist_mm: geom.specs.pin_dist_mm,
                    pin_config: geom.specs.pin_config
                },
                geometry: {
                    inner_radius_inches: geom.cRadius,
                    inner_radius_mm: geom.cRadius * 25.4,
                    outer_radius_inches: geom.backCRadius,
                    outer_radius_mm: geom.backCRadius * 25.4,
                    degs_per_pixel: geom.degsPerPixel,
                    azimuthal_pixels: geom.azimuthalPixels,
                    azimuth_coverage_deg: geom.azimuthCoverage,
                    azimuth_gap_deg: geom.azimuthGap
                },
                pin_coordinates: pinCoords
            };

            // Create downloadable JSON file
            const jsonStr = JSON.stringify(exportObj, null, 2);
            const blob = new Blob([jsonStr], { type: 'application/json' });
            const url = URL.createObjectURL(blob);

            const a = document.createElement('a');
            a.href = url;
            a.download = `arena_${state.panelType}_${state.numPanels}panels.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        // Validation against MATLAB reference (hidden feature)
        async function validateAgainstReference() {
            try {
                const response = await fetch('https://raw.githubusercontent.com/reiserlab/maDisplayTools/main/docs/arena-designs/reference_data.json');
                const refData = await response.json();

                const statusEl = document.getElementById('validation-status');
                const geom = calculateGeometry();

                // Find matching reference
                const typeKey = state.panelType.replace('.', '');
                const ref = refData.arenas.find(a =>
                    a.panel_type.replace('.', '') === typeKey &&
                    a.num_panels === state.numPanels
                );

                if (!ref) {
                    statusEl.textContent = 'No reference data for this configuration';
                    statusEl.className = 'validation-status';
                    return;
                }

                // Compare (tolerance for floating point)
                const tolerance = 0.001;
                const radiusMatch = Math.abs(geom.cRadius - ref.c_radius_inches) < tolerance;
                const resMatch = Math.abs(geom.degsPerPixel - ref.degs_per_pixel) < tolerance;

                if (radiusMatch && resMatch) {
                    statusEl.textContent = '✓ Matches MATLAB reference';
                    statusEl.className = 'validation-status pass';
                } else {
                    statusEl.textContent = `✗ Mismatch: r=${geom.cRadius.toFixed(4)} vs ${ref.c_radius_inches.toFixed(4)}`;
                    statusEl.className = 'validation-status fail';
                }
            } catch (e) {
                console.log('Validation not available:', e);
            }
        }

        // Run validation on load (silent unless there's an issue)
        setTimeout(validateAgainstReference, 1000);
    </script>
</body>
</html>
